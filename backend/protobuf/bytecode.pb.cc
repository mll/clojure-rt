// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bytecode.proto

#include "bytecode.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace clojureRT {
namespace protobuf {
PROTOBUF_CONSTEXPR Subnode::Subnode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.types_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct SubnodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SubnodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SubnodeDefaultTypeInternal() {}
  union {
    Subnode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SubnodeDefaultTypeInternal _Subnode_default_instance_;
PROTOBUF_CONSTEXPR BindingNode::BindingNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.init_)*/nullptr
  , /*decltype(_impl_.argid_)*/0u
  , /*decltype(_impl_.local_)*/0
  , /*decltype(_impl_.isvariadic_)*/false} {}
struct BindingNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BindingNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BindingNodeDefaultTypeInternal() {}
  union {
    BindingNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BindingNodeDefaultTypeInternal _BindingNode_default_instance_;
PROTOBUF_CONSTEXPR CaseNode::CaseNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.tests_)*/{}
  , /*decltype(_impl_.thens_)*/{}
  , /*decltype(_impl_.high_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.low_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.isskipcheck_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.default__)*/nullptr
  , /*decltype(_impl_.test_)*/nullptr
  , /*decltype(_impl_.mask_)*/0u
  , /*decltype(_impl_.shift_)*/0u
  , /*decltype(_impl_.switchtype_)*/0
  , /*decltype(_impl_.testtype_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CaseNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CaseNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CaseNodeDefaultTypeInternal() {}
  union {
    CaseNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CaseNodeDefaultTypeInternal _CaseNode_default_instance_;
PROTOBUF_CONSTEXPR CaseTestNode::CaseTestNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.test_)*/nullptr
  , /*decltype(_impl_.hash_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CaseTestNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CaseTestNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CaseTestNodeDefaultTypeInternal() {}
  union {
    CaseTestNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CaseTestNodeDefaultTypeInternal _CaseTestNode_default_instance_;
PROTOBUF_CONSTEXPR CaseThenNode::CaseThenNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.then_)*/nullptr
  , /*decltype(_impl_.hash_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CaseThenNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CaseThenNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CaseThenNodeDefaultTypeInternal() {}
  union {
    CaseThenNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CaseThenNodeDefaultTypeInternal _CaseThenNode_default_instance_;
PROTOBUF_CONSTEXPR CatchNode::CatchNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.body_)*/nullptr
  , /*decltype(_impl_.class__)*/nullptr
  , /*decltype(_impl_.local_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CatchNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CatchNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CatchNodeDefaultTypeInternal() {}
  union {
    CatchNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CatchNodeDefaultTypeInternal _CatchNode_default_instance_;
PROTOBUF_CONSTEXPR ConstNode::ConstNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.val_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.meta_)*/nullptr
  , /*decltype(_impl_.isliteral_)*/false
  , /*decltype(_impl_.type_)*/0} {}
struct ConstNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConstNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConstNodeDefaultTypeInternal() {}
  union {
    ConstNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConstNodeDefaultTypeInternal _ConstNode_default_instance_;
PROTOBUF_CONSTEXPR DefNode::DefNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.doc_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.var_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.init_)*/nullptr
  , /*decltype(_impl_.meta_)*/nullptr} {}
struct DefNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DefNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DefNodeDefaultTypeInternal() {}
  union {
    DefNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DefNodeDefaultTypeInternal _DefNode_default_instance_;
PROTOBUF_CONSTEXPR DeftypeNode::DeftypeNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.fields_)*/{}
  , /*decltype(_impl_.interfaces_)*/{}
  , /*decltype(_impl_.methods_)*/{}
  , /*decltype(_impl_.classname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DeftypeNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeftypeNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeftypeNodeDefaultTypeInternal() {}
  union {
    DeftypeNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeftypeNodeDefaultTypeInternal _DeftypeNode_default_instance_;
PROTOBUF_CONSTEXPR DoNode::DoNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.statements_)*/{}
  , /*decltype(_impl_.ret_)*/nullptr
  , /*decltype(_impl_.isbody_)*/false} {}
struct DoNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DoNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DoNodeDefaultTypeInternal() {}
  union {
    DoNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DoNodeDefaultTypeInternal _DoNode_default_instance_;
PROTOBUF_CONSTEXPR FnNode::FnNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.methods_)*/{}
  , /*decltype(_impl_.local_)*/nullptr
  , /*decltype(_impl_.maxfixedarity_)*/0u
  , /*decltype(_impl_.once_)*/false
  , /*decltype(_impl_.isvariadic_)*/false} {}
struct FnNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FnNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FnNodeDefaultTypeInternal() {}
  union {
    FnNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FnNodeDefaultTypeInternal _FnNode_default_instance_;
PROTOBUF_CONSTEXPR FnMethodNode::FnMethodNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.params_)*/{}
  , /*decltype(_impl_.loopid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.body_)*/nullptr
  , /*decltype(_impl_.fixedarity_)*/0u
  , /*decltype(_impl_.isvariadic_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct FnMethodNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FnMethodNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FnMethodNodeDefaultTypeInternal() {}
  union {
    FnMethodNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FnMethodNodeDefaultTypeInternal _FnMethodNode_default_instance_;
PROTOBUF_CONSTEXPR HostInteropNode::HostInteropNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.morf_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.target_)*/nullptr
  , /*decltype(_impl_.isassignable_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct HostInteropNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HostInteropNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~HostInteropNodeDefaultTypeInternal() {}
  union {
    HostInteropNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HostInteropNodeDefaultTypeInternal _HostInteropNode_default_instance_;
PROTOBUF_CONSTEXPR IfNode::IfNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.else__)*/nullptr
  , /*decltype(_impl_.test_)*/nullptr
  , /*decltype(_impl_.then_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct IfNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IfNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IfNodeDefaultTypeInternal() {}
  union {
    IfNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IfNodeDefaultTypeInternal _IfNode_default_instance_;
PROTOBUF_CONSTEXPR ImportNode::ImportNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.class__)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ImportNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ImportNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ImportNodeDefaultTypeInternal() {}
  union {
    ImportNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ImportNodeDefaultTypeInternal _ImportNode_default_instance_;
PROTOBUF_CONSTEXPR InstanceCallNode::InstanceCallNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.args_)*/{}
  , /*decltype(_impl_.class__)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.method_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.instance_)*/nullptr
  , /*decltype(_impl_.isvalidated_)*/false} {}
struct InstanceCallNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InstanceCallNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~InstanceCallNodeDefaultTypeInternal() {}
  union {
    InstanceCallNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InstanceCallNodeDefaultTypeInternal _InstanceCallNode_default_instance_;
PROTOBUF_CONSTEXPR InstanceFieldNode::InstanceFieldNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.class__)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.field_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.instance_)*/nullptr
  , /*decltype(_impl_.isassignable_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct InstanceFieldNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InstanceFieldNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~InstanceFieldNodeDefaultTypeInternal() {}
  union {
    InstanceFieldNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InstanceFieldNodeDefaultTypeInternal _InstanceFieldNode_default_instance_;
PROTOBUF_CONSTEXPR IsInstanceNode::IsInstanceNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.class__)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.target_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct IsInstanceNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IsInstanceNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IsInstanceNodeDefaultTypeInternal() {}
  union {
    IsInstanceNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IsInstanceNodeDefaultTypeInternal _IsInstanceNode_default_instance_;
PROTOBUF_CONSTEXPR InvokeNode::InvokeNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.args_)*/{}
  , /*decltype(_impl_.meta_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.fn_)*/nullptr} {}
struct InvokeNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InvokeNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~InvokeNodeDefaultTypeInternal() {}
  union {
    InvokeNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InvokeNodeDefaultTypeInternal _InvokeNode_default_instance_;
PROTOBUF_CONSTEXPR KeywordInvokeNode::KeywordInvokeNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.keyword_)*/nullptr
  , /*decltype(_impl_.target_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct KeywordInvokeNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KeywordInvokeNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KeywordInvokeNodeDefaultTypeInternal() {}
  union {
    KeywordInvokeNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KeywordInvokeNodeDefaultTypeInternal _KeywordInvokeNode_default_instance_;
PROTOBUF_CONSTEXPR LetNode::LetNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.bindings_)*/{}
  , /*decltype(_impl_.body_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LetNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LetNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LetNodeDefaultTypeInternal() {}
  union {
    LetNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LetNodeDefaultTypeInternal _LetNode_default_instance_;
PROTOBUF_CONSTEXPR LetfnNode::LetfnNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.bindings_)*/{}
  , /*decltype(_impl_.body_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LetfnNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LetfnNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LetfnNodeDefaultTypeInternal() {}
  union {
    LetfnNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LetfnNodeDefaultTypeInternal _LetfnNode_default_instance_;
PROTOBUF_CONSTEXPR LocalNode::LocalNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.argid_)*/0u
  , /*decltype(_impl_.local_)*/0
  , /*decltype(_impl_.isassignable_)*/false
  , /*decltype(_impl_.isvariadic_)*/false} {}
struct LocalNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LocalNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LocalNodeDefaultTypeInternal() {}
  union {
    LocalNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LocalNodeDefaultTypeInternal _LocalNode_default_instance_;
PROTOBUF_CONSTEXPR LoopNode::LoopNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.bindings_)*/{}
  , /*decltype(_impl_.loopid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.body_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LoopNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LoopNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LoopNodeDefaultTypeInternal() {}
  union {
    LoopNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LoopNodeDefaultTypeInternal _LoopNode_default_instance_;
PROTOBUF_CONSTEXPR MapNode::MapNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.keys_)*/{}
  , /*decltype(_impl_.vals_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MapNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MapNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MapNodeDefaultTypeInternal() {}
  union {
    MapNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MapNodeDefaultTypeInternal _MapNode_default_instance_;
PROTOBUF_CONSTEXPR MethodNode::MethodNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.bridges_)*/{}
  , /*decltype(_impl_.params_)*/{}
  , /*decltype(_impl_.interface_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.loopid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.body_)*/nullptr
  , /*decltype(_impl_.this__)*/nullptr
  , /*decltype(_impl_.fixedarity_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MethodNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MethodNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MethodNodeDefaultTypeInternal() {}
  union {
    MethodNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MethodNodeDefaultTypeInternal _MethodNode_default_instance_;
PROTOBUF_CONSTEXPR MonitorEnterNode::MonitorEnterNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.target_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MonitorEnterNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MonitorEnterNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MonitorEnterNodeDefaultTypeInternal() {}
  union {
    MonitorEnterNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MonitorEnterNodeDefaultTypeInternal _MonitorEnterNode_default_instance_;
PROTOBUF_CONSTEXPR MonitorExitNode::MonitorExitNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.target_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MonitorExitNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MonitorExitNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MonitorExitNodeDefaultTypeInternal() {}
  union {
    MonitorExitNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MonitorExitNodeDefaultTypeInternal _MonitorExitNode_default_instance_;
PROTOBUF_CONSTEXPR NewNode::NewNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.args_)*/{}
  , /*decltype(_impl_.class__)*/nullptr
  , /*decltype(_impl_.isvalidated_)*/false} {}
struct NewNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NewNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NewNodeDefaultTypeInternal() {}
  union {
    NewNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NewNodeDefaultTypeInternal _NewNode_default_instance_;
PROTOBUF_CONSTEXPR PrimInvokeNode::PrimInvokeNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.args_)*/{}
  , /*decltype(_impl_.meta_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.priminterface_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.fn_)*/nullptr} {}
struct PrimInvokeNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PrimInvokeNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PrimInvokeNodeDefaultTypeInternal() {}
  union {
    PrimInvokeNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PrimInvokeNodeDefaultTypeInternal _PrimInvokeNode_default_instance_;
PROTOBUF_CONSTEXPR ProtocolInvokeNode::ProtocolInvokeNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.args_)*/{}
  , /*decltype(_impl_.protocolfn_)*/nullptr
  , /*decltype(_impl_.target_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ProtocolInvokeNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ProtocolInvokeNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ProtocolInvokeNodeDefaultTypeInternal() {}
  union {
    ProtocolInvokeNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ProtocolInvokeNodeDefaultTypeInternal _ProtocolInvokeNode_default_instance_;
PROTOBUF_CONSTEXPR QuoteNode::QuoteNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.expr_)*/nullptr
  , /*decltype(_impl_.isliteral_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct QuoteNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR QuoteNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~QuoteNodeDefaultTypeInternal() {}
  union {
    QuoteNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 QuoteNodeDefaultTypeInternal _QuoteNode_default_instance_;
PROTOBUF_CONSTEXPR RecurNode::RecurNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.exprs_)*/{}
  , /*decltype(_impl_.loopid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RecurNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RecurNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RecurNodeDefaultTypeInternal() {}
  union {
    RecurNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RecurNodeDefaultTypeInternal _RecurNode_default_instance_;
PROTOBUF_CONSTEXPR ReifyNode::ReifyNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.interfaces_)*/{}
  , /*decltype(_impl_.methods_)*/{}
  , /*decltype(_impl_.classname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ReifyNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReifyNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReifyNodeDefaultTypeInternal() {}
  union {
    ReifyNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReifyNodeDefaultTypeInternal _ReifyNode_default_instance_;
PROTOBUF_CONSTEXPR SetNode::SetNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.items_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SetNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SetNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SetNodeDefaultTypeInternal() {}
  union {
    SetNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SetNodeDefaultTypeInternal _SetNode_default_instance_;
PROTOBUF_CONSTEXPR MutateSetNode::MutateSetNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.target_)*/nullptr
  , /*decltype(_impl_.val_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MutateSetNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MutateSetNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MutateSetNodeDefaultTypeInternal() {}
  union {
    MutateSetNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MutateSetNodeDefaultTypeInternal _MutateSetNode_default_instance_;
PROTOBUF_CONSTEXPR StaticCallNode::StaticCallNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.args_)*/{}
  , /*decltype(_impl_.class__)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.method_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.isvalidated_)*/false} {}
struct StaticCallNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StaticCallNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StaticCallNodeDefaultTypeInternal() {}
  union {
    StaticCallNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StaticCallNodeDefaultTypeInternal _StaticCallNode_default_instance_;
PROTOBUF_CONSTEXPR StaticFieldNode::StaticFieldNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.class__)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.field_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.isassignable_)*/false} {}
struct StaticFieldNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StaticFieldNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StaticFieldNodeDefaultTypeInternal() {}
  union {
    StaticFieldNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StaticFieldNodeDefaultTypeInternal _StaticFieldNode_default_instance_;
PROTOBUF_CONSTEXPR TheVarNode::TheVarNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.var_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TheVarNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TheVarNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TheVarNodeDefaultTypeInternal() {}
  union {
    TheVarNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TheVarNodeDefaultTypeInternal _TheVarNode_default_instance_;
PROTOBUF_CONSTEXPR ThrowNode::ThrowNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.exception_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ThrowNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ThrowNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ThrowNodeDefaultTypeInternal() {}
  union {
    ThrowNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ThrowNodeDefaultTypeInternal _ThrowNode_default_instance_;
PROTOBUF_CONSTEXPR TryNode::TryNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.catches_)*/{}
  , /*decltype(_impl_.body_)*/nullptr
  , /*decltype(_impl_.finally_)*/nullptr} {}
struct TryNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TryNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TryNodeDefaultTypeInternal() {}
  union {
    TryNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TryNodeDefaultTypeInternal _TryNode_default_instance_;
PROTOBUF_CONSTEXPR VarNode::VarNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.var_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.isassignable_)*/false} {}
struct VarNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VarNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VarNodeDefaultTypeInternal() {}
  union {
    VarNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VarNodeDefaultTypeInternal _VarNode_default_instance_;
PROTOBUF_CONSTEXPR VectorNode::VectorNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.items_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct VectorNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VectorNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VectorNodeDefaultTypeInternal() {}
  union {
    VectorNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VectorNodeDefaultTypeInternal _VectorNode_default_instance_;
PROTOBUF_CONSTEXPR WithMetaNode::WithMetaNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.expr_)*/nullptr
  , /*decltype(_impl_.meta_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct WithMetaNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WithMetaNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~WithMetaNodeDefaultTypeInternal() {}
  union {
    WithMetaNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WithMetaNodeDefaultTypeInternal _WithMetaNode_default_instance_;
PROTOBUF_CONSTEXPR Node::Node(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.loops_)*/{}
  , /*decltype(_impl_.rawforms_)*/{}
  , /*decltype(_impl_.env_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.form_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.otag_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.tag_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.subnode_)*/nullptr
  , /*decltype(_impl_.op_)*/0
  , /*decltype(_impl_.ignoretag_)*/false
  , /*decltype(_impl_.toplevel_)*/false} {}
struct NodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NodeDefaultTypeInternal() {}
  union {
    Node _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NodeDefaultTypeInternal _Node_default_instance_;
}  // namespace protobuf
}  // namespace clojureRT
static ::_pb::Metadata file_level_metadata_bytecode_2eproto[45];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_bytecode_2eproto[5];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_bytecode_2eproto = nullptr;

const uint32_t TableStruct_bytecode_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::Subnode, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::Subnode, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::Subnode, _impl_.types_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::BindingNode, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::BindingNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::BindingNode, _impl_.argid_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::BindingNode, _impl_.init_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::BindingNode, _impl_.local_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::BindingNode, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::BindingNode, _impl_.isvariadic_),
  1,
  0,
  ~0u,
  ~0u,
  2,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::CaseNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::CaseNode, _impl_.default__),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::CaseNode, _impl_.high_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::CaseNode, _impl_.low_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::CaseNode, _impl_.mask_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::CaseNode, _impl_.shift_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::CaseNode, _impl_.isskipcheck_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::CaseNode, _impl_.switchtype_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::CaseNode, _impl_.test_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::CaseNode, _impl_.testtype_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::CaseNode, _impl_.tests_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::CaseNode, _impl_.thens_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::CaseTestNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::CaseTestNode, _impl_.hash_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::CaseTestNode, _impl_.test_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::CaseThenNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::CaseThenNode, _impl_.hash_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::CaseThenNode, _impl_.then_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::CatchNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::CatchNode, _impl_.body_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::CatchNode, _impl_.class__),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::CatchNode, _impl_.local_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::ConstNode, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::ConstNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::ConstNode, _impl_.isliteral_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::ConstNode, _impl_.meta_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::ConstNode, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::ConstNode, _impl_.val_),
  ~0u,
  0,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::DefNode, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::DefNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::DefNode, _impl_.doc_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::DefNode, _impl_.init_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::DefNode, _impl_.meta_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::DefNode, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::DefNode, _impl_.var_),
  0,
  1,
  2,
  ~0u,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::DeftypeNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::DeftypeNode, _impl_.classname_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::DeftypeNode, _impl_.fields_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::DeftypeNode, _impl_.interfaces_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::DeftypeNode, _impl_.methods_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::DeftypeNode, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::DoNode, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::DoNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::DoNode, _impl_.isbody_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::DoNode, _impl_.ret_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::DoNode, _impl_.statements_),
  0,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::FnNode, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::FnNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::FnNode, _impl_.local_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::FnNode, _impl_.maxfixedarity_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::FnNode, _impl_.methods_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::FnNode, _impl_.once_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::FnNode, _impl_.isvariadic_),
  0,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::FnMethodNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::FnMethodNode, _impl_.body_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::FnMethodNode, _impl_.fixedarity_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::FnMethodNode, _impl_.loopid_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::FnMethodNode, _impl_.params_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::FnMethodNode, _impl_.isvariadic_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::HostInteropNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::HostInteropNode, _impl_.isassignable_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::HostInteropNode, _impl_.morf_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::HostInteropNode, _impl_.target_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::IfNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::IfNode, _impl_.else__),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::IfNode, _impl_.test_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::IfNode, _impl_.then_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::ImportNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::ImportNode, _impl_.class__),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::InstanceCallNode, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::InstanceCallNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::InstanceCallNode, _impl_.args_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::InstanceCallNode, _impl_.class__),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::InstanceCallNode, _impl_.instance_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::InstanceCallNode, _impl_.method_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::InstanceCallNode, _impl_.isvalidated_),
  ~0u,
  0,
  ~0u,
  ~0u,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::InstanceFieldNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::InstanceFieldNode, _impl_.isassignable_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::InstanceFieldNode, _impl_.class__),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::InstanceFieldNode, _impl_.field_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::InstanceFieldNode, _impl_.instance_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::IsInstanceNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::IsInstanceNode, _impl_.class__),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::IsInstanceNode, _impl_.target_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::InvokeNode, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::InvokeNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::InvokeNode, _impl_.args_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::InvokeNode, _impl_.fn_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::InvokeNode, _impl_.meta_),
  ~0u,
  ~0u,
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::KeywordInvokeNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::KeywordInvokeNode, _impl_.keyword_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::KeywordInvokeNode, _impl_.target_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::LetNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::LetNode, _impl_.bindings_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::LetNode, _impl_.body_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::LetfnNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::LetfnNode, _impl_.bindings_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::LetfnNode, _impl_.body_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::LocalNode, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::LocalNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::LocalNode, _impl_.argid_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::LocalNode, _impl_.isassignable_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::LocalNode, _impl_.local_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::LocalNode, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::LocalNode, _impl_.isvariadic_),
  0,
  ~0u,
  ~0u,
  ~0u,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::LoopNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::LoopNode, _impl_.bindings_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::LoopNode, _impl_.body_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::LoopNode, _impl_.loopid_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::MapNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::MapNode, _impl_.keys_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::MapNode, _impl_.vals_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::MethodNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::MethodNode, _impl_.body_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::MethodNode, _impl_.bridges_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::MethodNode, _impl_.fixedarity_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::MethodNode, _impl_.interface_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::MethodNode, _impl_.loopid_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::MethodNode, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::MethodNode, _impl_.params_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::MethodNode, _impl_.this__),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::MonitorEnterNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::MonitorEnterNode, _impl_.target_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::MonitorExitNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::MonitorExitNode, _impl_.target_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::NewNode, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::NewNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::NewNode, _impl_.args_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::NewNode, _impl_.class__),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::NewNode, _impl_.isvalidated_),
  ~0u,
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::PrimInvokeNode, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::PrimInvokeNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::PrimInvokeNode, _impl_.args_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::PrimInvokeNode, _impl_.fn_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::PrimInvokeNode, _impl_.meta_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::PrimInvokeNode, _impl_.priminterface_),
  ~0u,
  ~0u,
  0,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::ProtocolInvokeNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::ProtocolInvokeNode, _impl_.args_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::ProtocolInvokeNode, _impl_.protocolfn_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::ProtocolInvokeNode, _impl_.target_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::QuoteNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::QuoteNode, _impl_.expr_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::QuoteNode, _impl_.isliteral_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::RecurNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::RecurNode, _impl_.exprs_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::RecurNode, _impl_.loopid_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::ReifyNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::ReifyNode, _impl_.classname_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::ReifyNode, _impl_.interfaces_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::ReifyNode, _impl_.methods_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::SetNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::SetNode, _impl_.items_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::MutateSetNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::MutateSetNode, _impl_.target_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::MutateSetNode, _impl_.val_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::StaticCallNode, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::StaticCallNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::StaticCallNode, _impl_.args_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::StaticCallNode, _impl_.class__),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::StaticCallNode, _impl_.method_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::StaticCallNode, _impl_.isvalidated_),
  ~0u,
  ~0u,
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::StaticFieldNode, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::StaticFieldNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::StaticFieldNode, _impl_.isassignable_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::StaticFieldNode, _impl_.class__),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::StaticFieldNode, _impl_.field_),
  0,
  ~0u,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::TheVarNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::TheVarNode, _impl_.var_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::ThrowNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::ThrowNode, _impl_.exception_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::TryNode, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::TryNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::TryNode, _impl_.body_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::TryNode, _impl_.catches_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::TryNode, _impl_.finally_),
  ~0u,
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::VarNode, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::VarNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::VarNode, _impl_.isassignable_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::VarNode, _impl_.var_),
  0,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::VectorNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::VectorNode, _impl_.items_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::WithMetaNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::WithMetaNode, _impl_.expr_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::WithMetaNode, _impl_.meta_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::Node, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::Node, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::Node, _impl_.env_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::Node, _impl_.form_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::Node, _impl_.ignoretag_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::Node, _impl_.loops_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::Node, _impl_.otag_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::Node, _impl_.op_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::Node, _impl_.rawforms_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::Node, _impl_.subnode_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::Node, _impl_.tag_),
  PROTOBUF_FIELD_OFFSET(::clojureRT::protobuf::Node, _impl_.toplevel_),
  ~0u,
  ~0u,
  0,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  1,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::clojureRT::protobuf::Subnode)},
  { 50, 61, -1, sizeof(::clojureRT::protobuf::BindingNode)},
  { 66, -1, -1, sizeof(::clojureRT::protobuf::CaseNode)},
  { 83, -1, -1, sizeof(::clojureRT::protobuf::CaseTestNode)},
  { 91, -1, -1, sizeof(::clojureRT::protobuf::CaseThenNode)},
  { 99, -1, -1, sizeof(::clojureRT::protobuf::CatchNode)},
  { 108, 118, -1, sizeof(::clojureRT::protobuf::ConstNode)},
  { 122, 133, -1, sizeof(::clojureRT::protobuf::DefNode)},
  { 138, -1, -1, sizeof(::clojureRT::protobuf::DeftypeNode)},
  { 149, 158, -1, sizeof(::clojureRT::protobuf::DoNode)},
  { 161, 172, -1, sizeof(::clojureRT::protobuf::FnNode)},
  { 177, -1, -1, sizeof(::clojureRT::protobuf::FnMethodNode)},
  { 188, -1, -1, sizeof(::clojureRT::protobuf::HostInteropNode)},
  { 197, -1, -1, sizeof(::clojureRT::protobuf::IfNode)},
  { 206, -1, -1, sizeof(::clojureRT::protobuf::ImportNode)},
  { 213, 224, -1, sizeof(::clojureRT::protobuf::InstanceCallNode)},
  { 229, -1, -1, sizeof(::clojureRT::protobuf::InstanceFieldNode)},
  { 239, -1, -1, sizeof(::clojureRT::protobuf::IsInstanceNode)},
  { 247, 256, -1, sizeof(::clojureRT::protobuf::InvokeNode)},
  { 259, -1, -1, sizeof(::clojureRT::protobuf::KeywordInvokeNode)},
  { 267, -1, -1, sizeof(::clojureRT::protobuf::LetNode)},
  { 275, -1, -1, sizeof(::clojureRT::protobuf::LetfnNode)},
  { 283, 294, -1, sizeof(::clojureRT::protobuf::LocalNode)},
  { 299, -1, -1, sizeof(::clojureRT::protobuf::LoopNode)},
  { 308, -1, -1, sizeof(::clojureRT::protobuf::MapNode)},
  { 316, -1, -1, sizeof(::clojureRT::protobuf::MethodNode)},
  { 330, -1, -1, sizeof(::clojureRT::protobuf::MonitorEnterNode)},
  { 337, -1, -1, sizeof(::clojureRT::protobuf::MonitorExitNode)},
  { 344, 353, -1, sizeof(::clojureRT::protobuf::NewNode)},
  { 356, 366, -1, sizeof(::clojureRT::protobuf::PrimInvokeNode)},
  { 370, -1, -1, sizeof(::clojureRT::protobuf::ProtocolInvokeNode)},
  { 379, -1, -1, sizeof(::clojureRT::protobuf::QuoteNode)},
  { 387, -1, -1, sizeof(::clojureRT::protobuf::RecurNode)},
  { 395, -1, -1, sizeof(::clojureRT::protobuf::ReifyNode)},
  { 404, -1, -1, sizeof(::clojureRT::protobuf::SetNode)},
  { 411, -1, -1, sizeof(::clojureRT::protobuf::MutateSetNode)},
  { 419, 429, -1, sizeof(::clojureRT::protobuf::StaticCallNode)},
  { 433, 442, -1, sizeof(::clojureRT::protobuf::StaticFieldNode)},
  { 445, -1, -1, sizeof(::clojureRT::protobuf::TheVarNode)},
  { 452, -1, -1, sizeof(::clojureRT::protobuf::ThrowNode)},
  { 459, 468, -1, sizeof(::clojureRT::protobuf::TryNode)},
  { 471, 479, -1, sizeof(::clojureRT::protobuf::VarNode)},
  { 481, -1, -1, sizeof(::clojureRT::protobuf::VectorNode)},
  { 488, -1, -1, sizeof(::clojureRT::protobuf::WithMetaNode)},
  { 496, 512, -1, sizeof(::clojureRT::protobuf::Node)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::clojureRT::protobuf::_Subnode_default_instance_._instance,
  &::clojureRT::protobuf::_BindingNode_default_instance_._instance,
  &::clojureRT::protobuf::_CaseNode_default_instance_._instance,
  &::clojureRT::protobuf::_CaseTestNode_default_instance_._instance,
  &::clojureRT::protobuf::_CaseThenNode_default_instance_._instance,
  &::clojureRT::protobuf::_CatchNode_default_instance_._instance,
  &::clojureRT::protobuf::_ConstNode_default_instance_._instance,
  &::clojureRT::protobuf::_DefNode_default_instance_._instance,
  &::clojureRT::protobuf::_DeftypeNode_default_instance_._instance,
  &::clojureRT::protobuf::_DoNode_default_instance_._instance,
  &::clojureRT::protobuf::_FnNode_default_instance_._instance,
  &::clojureRT::protobuf::_FnMethodNode_default_instance_._instance,
  &::clojureRT::protobuf::_HostInteropNode_default_instance_._instance,
  &::clojureRT::protobuf::_IfNode_default_instance_._instance,
  &::clojureRT::protobuf::_ImportNode_default_instance_._instance,
  &::clojureRT::protobuf::_InstanceCallNode_default_instance_._instance,
  &::clojureRT::protobuf::_InstanceFieldNode_default_instance_._instance,
  &::clojureRT::protobuf::_IsInstanceNode_default_instance_._instance,
  &::clojureRT::protobuf::_InvokeNode_default_instance_._instance,
  &::clojureRT::protobuf::_KeywordInvokeNode_default_instance_._instance,
  &::clojureRT::protobuf::_LetNode_default_instance_._instance,
  &::clojureRT::protobuf::_LetfnNode_default_instance_._instance,
  &::clojureRT::protobuf::_LocalNode_default_instance_._instance,
  &::clojureRT::protobuf::_LoopNode_default_instance_._instance,
  &::clojureRT::protobuf::_MapNode_default_instance_._instance,
  &::clojureRT::protobuf::_MethodNode_default_instance_._instance,
  &::clojureRT::protobuf::_MonitorEnterNode_default_instance_._instance,
  &::clojureRT::protobuf::_MonitorExitNode_default_instance_._instance,
  &::clojureRT::protobuf::_NewNode_default_instance_._instance,
  &::clojureRT::protobuf::_PrimInvokeNode_default_instance_._instance,
  &::clojureRT::protobuf::_ProtocolInvokeNode_default_instance_._instance,
  &::clojureRT::protobuf::_QuoteNode_default_instance_._instance,
  &::clojureRT::protobuf::_RecurNode_default_instance_._instance,
  &::clojureRT::protobuf::_ReifyNode_default_instance_._instance,
  &::clojureRT::protobuf::_SetNode_default_instance_._instance,
  &::clojureRT::protobuf::_MutateSetNode_default_instance_._instance,
  &::clojureRT::protobuf::_StaticCallNode_default_instance_._instance,
  &::clojureRT::protobuf::_StaticFieldNode_default_instance_._instance,
  &::clojureRT::protobuf::_TheVarNode_default_instance_._instance,
  &::clojureRT::protobuf::_ThrowNode_default_instance_._instance,
  &::clojureRT::protobuf::_TryNode_default_instance_._instance,
  &::clojureRT::protobuf::_VarNode_default_instance_._instance,
  &::clojureRT::protobuf::_VectorNode_default_instance_._instance,
  &::clojureRT::protobuf::_WithMetaNode_default_instance_._instance,
  &::clojureRT::protobuf::_Node_default_instance_._instance,
};

const char descriptor_table_protodef_bytecode_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\016bytecode.proto\022\022clojureRT.protobuf\"\262\021\n"
  "\007Subnode\0222\n\007binding\030\001 \001(\0132\037.clojureRT.pr"
  "otobuf.BindingNodeH\000\022,\n\004case\030\002 \001(\0132\034.clo"
  "jureRT.protobuf.CaseNodeH\000\0224\n\010caseTest\030\003"
  " \001(\0132 .clojureRT.protobuf.CaseTestNodeH\000"
  "\0224\n\010caseThen\030\004 \001(\0132 .clojureRT.protobuf."
  "CaseThenNodeH\000\022.\n\005catch\030\005 \001(\0132\035.clojureR"
  "T.protobuf.CatchNodeH\000\022.\n\005const\030\006 \001(\0132\035."
  "clojureRT.protobuf.ConstNodeH\000\022*\n\003def\030\007 "
  "\001(\0132\033.clojureRT.protobuf.DefNodeH\000\0222\n\007de"
  "ftype\030\010 \001(\0132\037.clojureRT.protobuf.Deftype"
  "NodeH\000\022(\n\002do\030\t \001(\0132\032.clojureRT.protobuf."
  "DoNodeH\000\022(\n\002fn\030\n \001(\0132\032.clojureRT.protobu"
  "f.FnNodeH\000\0224\n\010fnMethod\030\013 \001(\0132 .clojureRT"
  ".protobuf.FnMethodNodeH\000\022:\n\013hostInterop\030"
  "\014 \001(\0132#.clojureRT.protobuf.HostInteropNo"
  "deH\000\022(\n\002if\030\r \001(\0132\032.clojureRT.protobuf.If"
  "NodeH\000\0220\n\006import\030\016 \001(\0132\036.clojureRT.proto"
  "buf.ImportNodeH\000\022<\n\014instanceCall\030\017 \001(\0132$"
  ".clojureRT.protobuf.InstanceCallNodeH\000\022>"
  "\n\rinstanceField\030\020 \001(\0132%.clojureRT.protob"
  "uf.InstanceFieldNodeH\000\0228\n\nisInstance\030\021 \001"
  "(\0132\".clojureRT.protobuf.IsInstanceNodeH\000"
  "\0220\n\006invoke\030\022 \001(\0132\036.clojureRT.protobuf.In"
  "vokeNodeH\000\022>\n\rkeywordInvoke\030\023 \001(\0132%.cloj"
  "ureRT.protobuf.KeywordInvokeNodeH\000\022*\n\003le"
  "t\030\024 \001(\0132\033.clojureRT.protobuf.LetNodeH\000\022."
  "\n\005letfn\030\025 \001(\0132\035.clojureRT.protobuf.Letfn"
  "NodeH\000\022.\n\005local\030\026 \001(\0132\035.clojureRT.protob"
  "uf.LocalNodeH\000\022,\n\004loop\030\027 \001(\0132\034.clojureRT"
  ".protobuf.LoopNodeH\000\022*\n\003map\030\030 \001(\0132\033.cloj"
  "ureRT.protobuf.MapNodeH\000\0220\n\006method\030\031 \001(\013"
  "2\036.clojureRT.protobuf.MethodNodeH\000\022<\n\014mo"
  "nitorEnter\030\032 \001(\0132$.clojureRT.protobuf.Mo"
  "nitorEnterNodeH\000\022:\n\013monitorExit\030\033 \001(\0132#."
  "clojureRT.protobuf.MonitorExitNodeH\000\022*\n\003"
  "new\030\034 \001(\0132\033.clojureRT.protobuf.NewNodeH\000"
  "\0228\n\nprimInvoke\030\035 \001(\0132\".clojureRT.protobu"
  "f.PrimInvokeNodeH\000\022@\n\016protocolInvoke\030\036 \001"
  "(\0132&.clojureRT.protobuf.ProtocolInvokeNo"
  "deH\000\022.\n\005quote\030\037 \001(\0132\035.clojureRT.protobuf"
  ".QuoteNodeH\000\022.\n\005recur\030  \001(\0132\035.clojureRT."
  "protobuf.RecurNodeH\000\022.\n\005reify\030! \001(\0132\035.cl"
  "ojureRT.protobuf.ReifyNodeH\000\022*\n\003set\030\" \001("
  "\0132\033.clojureRT.protobuf.SetNodeH\000\0226\n\tmuta"
  "teSet\030# \001(\0132!.clojureRT.protobuf.MutateS"
  "etNodeH\000\0228\n\nstaticCall\030$ \001(\0132\".clojureRT"
  ".protobuf.StaticCallNodeH\000\022:\n\013staticFiel"
  "d\030% \001(\0132#.clojureRT.protobuf.StaticField"
  "NodeH\000\0220\n\006theVar\030& \001(\0132\036.clojureRT.proto"
  "buf.TheVarNodeH\000\022.\n\005throw\030\' \001(\0132\035.clojur"
  "eRT.protobuf.ThrowNodeH\000\022*\n\003try\030( \001(\0132\033."
  "clojureRT.protobuf.TryNodeH\000\022*\n\003var\030) \001("
  "\0132\033.clojureRT.protobuf.VarNodeH\000\0220\n\006vect"
  "or\030* \001(\0132\036.clojureRT.protobuf.VectorNode"
  "H\000\0224\n\010withMeta\030+ \001(\0132 .clojureRT.protobu"
  "f.WithMetaNodeH\000B\007\n\005types\"\305\001\n\013BindingNod"
  "e\022\022\n\005argId\030\001 \001(\rH\000\210\001\001\022+\n\004init\030\002 \001(\0132\030.cl"
  "ojureRT.protobuf.NodeH\001\210\001\001\022,\n\005local\030\003 \001("
  "\0162\035.clojureRT.protobuf.LocalType\022\014\n\004name"
  "\030\004 \001(\t\022\027\n\nisVariadic\030\005 \001(\010H\002\210\001\001B\010\n\006_argI"
  "dB\007\n\005_initB\r\n\013_isVariadic\"\373\003\n\010CaseNode\022)"
  "\n\007default\030\001 \001(\0132\030.clojureRT.protobuf.Nod"
  "e\022\014\n\004high\030\002 \001(\t\022\013\n\003low\030\003 \001(\t\022\014\n\004mask\030\004 \001"
  "(\r\022\r\n\005shift\030\005 \001(\r\022\023\n\013isSkipCheck\030\006 \001(\t\022;"
  "\n\nswitchType\030\007 \001(\0162\'.clojureRT.protobuf."
  "CaseNode.SwitchType\022&\n\004test\030\010 \001(\0132\030.cloj"
  "ureRT.protobuf.Node\0227\n\010testType\030\t \001(\0162%."
  "clojureRT.protobuf.CaseNode.TestType\022\'\n\005"
  "tests\030\n \003(\0132\030.clojureRT.protobuf.Node\022\'\n"
  "\005thens\030\013 \003(\0132\030.clojureRT.protobuf.Node\"9"
  "\n\nSwitchType\022\024\n\020switchTypeSparse\020\000\022\025\n\021sw"
  "itchTypeCompact\020\001\"L\n\010TestType\022\017\n\013testTyp"
  "eInt\020\000\022\025\n\021testTypeHashEquiv\020\001\022\030\n\024testTyp"
  "eHashIdentity\020\002\"D\n\014CaseTestNode\022\014\n\004hash\030"
  "\001 \001(\r\022&\n\004test\030\002 \001(\0132\030.clojureRT.protobuf"
  ".Node\"D\n\014CaseThenNode\022\014\n\004hash\030\001 \001(\r\022&\n\004t"
  "hen\030\002 \001(\0132\030.clojureRT.protobuf.Node\"\205\001\n\t"
  "CatchNode\022&\n\004body\030\001 \001(\0132\030.clojureRT.prot"
  "obuf.Node\022\'\n\005class\030\002 \001(\0132\030.clojureRT.pro"
  "tobuf.Node\022\'\n\005local\030\003 \001(\0132\030.clojureRT.pr"
  "otobuf.Node\"\366\003\n\tConstNode\022\021\n\tisLiteral\030\001"
  " \001(\010\022+\n\004meta\030\002 \001(\0132\030.clojureRT.protobuf."
  "NodeH\000\210\001\001\0225\n\004type\030\003 \001(\0162\'.clojureRT.prot"
  "obuf.ConstNode.ConstType\022\013\n\003val\030\004 \001(\t\"\333\002"
  "\n\tConstType\022\020\n\014constTypeNil\020\000\022\021\n\rconstTy"
  "peBool\020\001\022\024\n\020constTypeKeyword\020\002\022\023\n\017constT"
  "ypeSymbol\020\003\022\023\n\017constTypeString\020\004\022\023\n\017cons"
  "tTypeNumber\020\005\022\021\n\rconstTypeType\020\006\022\023\n\017cons"
  "tTypeRecord\020\007\022\020\n\014constTypeMap\020\010\022\023\n\017const"
  "TypeVector\020\t\022\020\n\014constTypeSet\020\n\022\020\n\014constT"
  "ypeSeq\020\013\022\021\n\rconstTypeChar\020\014\022\022\n\016constType"
  "Regex\020\r\022\022\n\016constTypeClass\020\016\022\020\n\014constType"
  "Var\020\017\022\024\n\020constTypeUnknown\020\020B\007\n\005_meta\"\252\001\n"
  "\007DefNode\022\020\n\003doc\030\001 \001(\tH\000\210\001\001\022+\n\004init\030\002 \001(\013"
  "2\030.clojureRT.protobuf.NodeH\001\210\001\001\022+\n\004meta\030"
  "\003 \001(\0132\030.clojureRT.protobuf.NodeH\002\210\001\001\022\014\n\004"
  "name\030\004 \001(\t\022\013\n\003var\030\005 \001(\tB\006\n\004_docB\007\n\005_init"
  "B\007\n\005_meta\"\227\001\n\013DeftypeNode\022\021\n\tclassName\030\001"
  " \001(\t\022(\n\006fields\030\002 \003(\0132\030.clojureRT.protobu"
  "f.Node\022\022\n\ninterfaces\030\003 \003(\t\022)\n\007methods\030\004 "
  "\003(\0132\030.clojureRT.protobuf.Node\022\014\n\004name\030\005 "
  "\001(\t\"}\n\006DoNode\022\023\n\006isBody\030\001 \001(\010H\000\210\001\001\022%\n\003re"
  "t\030\002 \001(\0132\030.clojureRT.protobuf.Node\022,\n\nsta"
  "tements\030\003 \003(\0132\030.clojureRT.protobuf.NodeB"
  "\t\n\007_isBody\"\244\001\n\006FnNode\022,\n\005local\030\001 \001(\0132\030.c"
  "lojureRT.protobuf.NodeH\000\210\001\001\022\025\n\rmaxFixedA"
  "rity\030\002 \001(\r\022)\n\007methods\030\003 \003(\0132\030.clojureRT."
  "protobuf.Node\022\014\n\004once\030\004 \001(\010\022\022\n\nisVariadi"
  "c\030\005 \001(\010B\010\n\006_local\"\230\001\n\014FnMethodNode\022&\n\004bo"
  "dy\030\001 \001(\0132\030.clojureRT.protobuf.Node\022\022\n\nfi"
  "xedArity\030\002 \001(\r\022\016\n\006loopId\030\003 \001(\t\022(\n\006params"
  "\030\004 \003(\0132\030.clojureRT.protobuf.Node\022\022\n\nisVa"
  "riadic\030\005 \001(\010\"_\n\017HostInteropNode\022\024\n\014isAss"
  "ignable\030\001 \001(\010\022\014\n\004mOrF\030\002 \001(\t\022(\n\006target\030\003 "
  "\001(\0132\030.clojureRT.protobuf.Node\"\200\001\n\006IfNode"
  "\022&\n\004else\030\001 \001(\0132\030.clojureRT.protobuf.Node"
  "\022&\n\004test\030\002 \001(\0132\030.clojureRT.protobuf.Node"
  "\022&\n\004then\030\003 \001(\0132\030.clojureRT.protobuf.Node"
  "\"\033\n\nImportNode\022\r\n\005class\030\001 \001(\t\"\276\001\n\020Instan"
  "ceCallNode\022&\n\004args\030\001 \003(\0132\030.clojureRT.pro"
  "tobuf.Node\022\022\n\005class\030\002 \001(\tH\000\210\001\001\022*\n\010instan"
  "ce\030\003 \001(\0132\030.clojureRT.protobuf.Node\022\016\n\006me"
  "thod\030\004 \001(\t\022\030\n\013isValidated\030\005 \001(\010H\001\210\001\001B\010\n\006"
  "_classB\016\n\014_isValidated\"s\n\021InstanceFieldN"
  "ode\022\024\n\014isAssignable\030\001 \001(\010\022\r\n\005class\030\002 \001(\t"
  "\022\r\n\005field\030\003 \001(\t\022*\n\010instance\030\004 \001(\0132\030.cloj"
  "ureRT.protobuf.Node\"I\n\016IsInstanceNode\022\r\n"
  "\005class\030\001 \001(\t\022(\n\006target\030\002 \001(\0132\030.clojureRT"
  ".protobuf.Node\"v\n\nInvokeNode\022&\n\004args\030\001 \003"
  "(\0132\030.clojureRT.protobuf.Node\022$\n\002fn\030\002 \001(\013"
  "2\030.clojureRT.protobuf.Node\022\021\n\004meta\030\003 \001(\t"
  "H\000\210\001\001B\007\n\005_meta\"h\n\021KeywordInvokeNode\022)\n\007k"
  "eyword\030\001 \001(\0132\030.clojureRT.protobuf.Node\022("
  "\n\006target\030\002 \001(\0132\030.clojureRT.protobuf.Node"
  "\"]\n\007LetNode\022*\n\010bindings\030\001 \003(\0132\030.clojureR"
  "T.protobuf.Node\022&\n\004body\030\002 \001(\0132\030.clojureR"
  "T.protobuf.Node\"_\n\tLetfnNode\022*\n\010bindings"
  "\030\001 \003(\0132\030.clojureRT.protobuf.Node\022&\n\004body"
  "\030\002 \001(\0132\030.clojureRT.protobuf.Node\"\243\001\n\tLoc"
  "alNode\022\022\n\005argId\030\001 \001(\rH\000\210\001\001\022\024\n\014isAssignab"
  "le\030\002 \001(\010\022,\n\005local\030\003 \001(\0162\035.clojureRT.prot"
  "obuf.LocalType\022\014\n\004name\030\004 \001(\t\022\027\n\nisVariad"
  "ic\030\005 \001(\010H\001\210\001\001B\010\n\006_argIdB\r\n\013_isVariadic\"n"
  "\n\010LoopNode\022*\n\010bindings\030\001 \003(\0132\030.clojureRT"
  ".protobuf.Node\022&\n\004body\030\002 \001(\0132\030.clojureRT"
  ".protobuf.Node\022\016\n\006loopId\030\003 \001(\t\"Y\n\007MapNod"
  "e\022&\n\004keys\030\001 \003(\0132\030.clojureRT.protobuf.Nod"
  "e\022&\n\004vals\030\002 \003(\0132\030.clojureRT.protobuf.Nod"
  "e\"\334\001\n\nMethodNode\022&\n\004body\030\001 \001(\0132\030.clojure"
  "RT.protobuf.Node\022\017\n\007bridges\030\002 \003(\t\022\022\n\nfix"
  "edArity\030\003 \001(\r\022\021\n\tinterface\030\004 \001(\t\022\016\n\006loop"
  "Id\030\005 \001(\t\022\014\n\004name\030\006 \001(\t\022(\n\006params\030\007 \003(\0132\030"
  ".clojureRT.protobuf.Node\022&\n\004this\030\010 \001(\0132\030"
  ".clojureRT.protobuf.Node\"<\n\020MonitorEnter"
  "Node\022(\n\006target\030\001 \001(\0132\030.clojureRT.protobu"
  "f.Node\";\n\017MonitorExitNode\022(\n\006target\030\001 \001("
  "\0132\030.clojureRT.protobuf.Node\"\204\001\n\007NewNode\022"
  "&\n\004args\030\001 \003(\0132\030.clojureRT.protobuf.Node\022"
  "\'\n\005class\030\002 \001(\0132\030.clojureRT.protobuf.Node"
  "\022\030\n\013isValidated\030\003 \001(\010H\000\210\001\001B\016\n\014_isValidat"
  "ed\"\221\001\n\016PrimInvokeNode\022&\n\004args\030\001 \003(\0132\030.cl"
  "ojureRT.protobuf.Node\022$\n\002fn\030\002 \001(\0132\030.cloj"
  "ureRT.protobuf.Node\022\021\n\004meta\030\003 \001(\tH\000\210\001\001\022\025"
  "\n\rprimInterface\030\004 \001(\tB\007\n\005_meta\"\224\001\n\022Proto"
  "colInvokeNode\022&\n\004args\030\001 \003(\0132\030.clojureRT."
  "protobuf.Node\022,\n\nprotocolFn\030\002 \001(\0132\030.cloj"
  "ureRT.protobuf.Node\022(\n\006target\030\003 \001(\0132\030.cl"
  "ojureRT.protobuf.Node\"F\n\tQuoteNode\022&\n\004ex"
  "pr\030\001 \001(\0132\030.clojureRT.protobuf.Node\022\021\n\tis"
  "Literal\030\002 \001(\010\"D\n\tRecurNode\022\'\n\005exprs\030\001 \003("
  "\0132\030.clojureRT.protobuf.Node\022\016\n\006loopId\030\002 "
  "\001(\t\"]\n\tReifyNode\022\021\n\tclassName\030\001 \001(\t\022\022\n\ni"
  "nterfaces\030\002 \003(\t\022)\n\007methods\030\003 \003(\0132\030.cloju"
  "reRT.protobuf.Node\"2\n\007SetNode\022\'\n\005items\030\001"
  " \003(\0132\030.clojureRT.protobuf.Node\"`\n\rMutate"
  "SetNode\022(\n\006target\030\001 \001(\0132\030.clojureRT.prot"
  "obuf.Node\022%\n\003val\030\002 \001(\0132\030.clojureRT.proto"
  "buf.Node\"\201\001\n\016StaticCallNode\022&\n\004args\030\001 \003("
  "\0132\030.clojureRT.protobuf.Node\022\r\n\005class\030\002 \001"
  "(\t\022\016\n\006method\030\003 \001(\t\022\030\n\013isValidated\030\004 \001(\010H"
  "\000\210\001\001B\016\n\014_isValidated\"[\n\017StaticFieldNode\022"
  "\031\n\014isAssignable\030\001 \001(\010H\000\210\001\001\022\r\n\005class\030\002 \001("
  "\t\022\r\n\005field\030\003 \001(\tB\017\n\r_isAssignable\"\031\n\nThe"
  "VarNode\022\013\n\003var\030\001 \001(\t\"8\n\tThrowNode\022+\n\texc"
  "eption\030\001 \001(\0132\030.clojureRT.protobuf.Node\"\230"
  "\001\n\007TryNode\022&\n\004body\030\001 \001(\0132\030.clojureRT.pro"
  "tobuf.Node\022)\n\007catches\030\002 \003(\0132\030.clojureRT."
  "protobuf.Node\022.\n\007finally\030\003 \001(\0132\030.clojure"
  "RT.protobuf.NodeH\000\210\001\001B\n\n\010_finally\"B\n\007Var"
  "Node\022\031\n\014isAssignable\030\001 \001(\010H\000\210\001\001\022\013\n\003var\030\002"
  " \001(\tB\017\n\r_isAssignable\"5\n\nVectorNode\022\'\n\005i"
  "tems\030\001 \003(\0132\030.clojureRT.protobuf.Node\"^\n\014"
  "WithMetaNode\022&\n\004expr\030\001 \001(\0132\030.clojureRT.p"
  "rotobuf.Node\022&\n\004meta\030\002 \001(\0132\030.clojureRT.p"
  "rotobuf.Node\"\371\001\n\004Node\022\013\n\003env\030\001 \001(\t\022\014\n\004fo"
  "rm\030\002 \001(\t\022\026\n\tignoreTag\030\003 \001(\010H\000\210\001\001\022\r\n\005loop"
  "s\030\004 \003(\t\022\014\n\004oTag\030\005 \001(\t\022\"\n\002op\030\006 \001(\0162\026.cloj"
  "ureRT.protobuf.Op\022\020\n\010rawForms\030\007 \003(\t\022,\n\007s"
  "ubnode\030\010 \001(\0132\033.clojureRT.protobuf.Subnod"
  "e\022\013\n\003tag\030\t \001(\t\022\025\n\010topLevel\030\n \001(\010H\001\210\001\001B\014\n"
  "\n_ignoreTagB\013\n\t_topLevel*\373\004\n\002Op\022\r\n\topBin"
  "ding\020\000\022\n\n\006opCase\020\001\022\016\n\nopCaseTest\020\002\022\016\n\nop"
  "CaseThen\020\003\022\013\n\007opCatch\020\004\022\013\n\007opConst\020\005\022\t\n\005"
  "opDef\020\006\022\r\n\topDeftype\020\007\022\010\n\004opDo\020\010\022\010\n\004opFn"
  "\020\t\022\016\n\nopFnMethod\020\n\022\021\n\ropHostInterop\020\013\022\010\n"
  "\004opIf\020\014\022\014\n\010opImport\020\r\022\022\n\016opInstanceCall\020"
  "\016\022\023\n\017opInstanceField\020\017\022\020\n\014opIsInstance\020\020"
  "\022\014\n\010opInvoke\020\021\022\023\n\017opKeywordInvoke\020\022\022\t\n\005o"
  "pLet\020\023\022\013\n\007opLetfn\020\024\022\013\n\007opLocal\020\025\022\n\n\006opLo"
  "op\020\026\022\t\n\005opMap\020\027\022\014\n\010opMethod\020\030\022\022\n\016opMonit"
  "orEnter\020\031\022\021\n\ropMonitorExit\020\032\022\t\n\005opNew\020\033\022"
  "\020\n\014opPrimInvoke\020\034\022\024\n\020opProtocolInvoke\020\035\022"
  "\013\n\007opQuote\020\036\022\013\n\007opRecur\020\037\022\013\n\007opReify\020 \022\t"
  "\n\005opSet\020!\022\017\n\013opMutateSet\020\"\022\020\n\014opStaticCa"
  "ll\020#\022\021\n\ropStaticField\020$\022\014\n\010opTheVar\020%\022\013\n"
  "\007opThrow\020&\022\t\n\005opTry\020\'\022\t\n\005opVar\020(\022\014\n\010opVe"
  "ctor\020)\022\016\n\nopWithMeta\020**\242\001\n\tLocalType\022\020\n\014"
  "localTypeArg\020\000\022\022\n\016localTypeCatch\020\001\022\017\n\013lo"
  "calTypeFn\020\002\022\020\n\014localTypeLet\020\003\022\022\n\016localTy"
  "peLetfn\020\004\022\021\n\rlocalTypeLoop\020\005\022\022\n\016localTyp"
  "eField\020\006\022\021\n\rlocalTypeThis\020\007B\nB\010Protobufb"
  "\006proto3"
  ;
static ::_pbi::once_flag descriptor_table_bytecode_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_bytecode_2eproto = {
    false, false, 8887, descriptor_table_protodef_bytecode_2eproto,
    "bytecode.proto",
    &descriptor_table_bytecode_2eproto_once, nullptr, 0, 45,
    schemas, file_default_instances, TableStruct_bytecode_2eproto::offsets,
    file_level_metadata_bytecode_2eproto, file_level_enum_descriptors_bytecode_2eproto,
    file_level_service_descriptors_bytecode_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_bytecode_2eproto_getter() {
  return &descriptor_table_bytecode_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_bytecode_2eproto(&descriptor_table_bytecode_2eproto);
namespace clojureRT {
namespace protobuf {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CaseNode_SwitchType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_bytecode_2eproto);
  return file_level_enum_descriptors_bytecode_2eproto[0];
}
bool CaseNode_SwitchType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CaseNode_SwitchType CaseNode::switchTypeSparse;
constexpr CaseNode_SwitchType CaseNode::switchTypeCompact;
constexpr CaseNode_SwitchType CaseNode::SwitchType_MIN;
constexpr CaseNode_SwitchType CaseNode::SwitchType_MAX;
constexpr int CaseNode::SwitchType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CaseNode_TestType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_bytecode_2eproto);
  return file_level_enum_descriptors_bytecode_2eproto[1];
}
bool CaseNode_TestType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CaseNode_TestType CaseNode::testTypeInt;
constexpr CaseNode_TestType CaseNode::testTypeHashEquiv;
constexpr CaseNode_TestType CaseNode::testTypeHashIdentity;
constexpr CaseNode_TestType CaseNode::TestType_MIN;
constexpr CaseNode_TestType CaseNode::TestType_MAX;
constexpr int CaseNode::TestType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ConstNode_ConstType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_bytecode_2eproto);
  return file_level_enum_descriptors_bytecode_2eproto[2];
}
bool ConstNode_ConstType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ConstNode_ConstType ConstNode::constTypeNil;
constexpr ConstNode_ConstType ConstNode::constTypeBool;
constexpr ConstNode_ConstType ConstNode::constTypeKeyword;
constexpr ConstNode_ConstType ConstNode::constTypeSymbol;
constexpr ConstNode_ConstType ConstNode::constTypeString;
constexpr ConstNode_ConstType ConstNode::constTypeNumber;
constexpr ConstNode_ConstType ConstNode::constTypeType;
constexpr ConstNode_ConstType ConstNode::constTypeRecord;
constexpr ConstNode_ConstType ConstNode::constTypeMap;
constexpr ConstNode_ConstType ConstNode::constTypeVector;
constexpr ConstNode_ConstType ConstNode::constTypeSet;
constexpr ConstNode_ConstType ConstNode::constTypeSeq;
constexpr ConstNode_ConstType ConstNode::constTypeChar;
constexpr ConstNode_ConstType ConstNode::constTypeRegex;
constexpr ConstNode_ConstType ConstNode::constTypeClass;
constexpr ConstNode_ConstType ConstNode::constTypeVar;
constexpr ConstNode_ConstType ConstNode::constTypeUnknown;
constexpr ConstNode_ConstType ConstNode::ConstType_MIN;
constexpr ConstNode_ConstType ConstNode::ConstType_MAX;
constexpr int ConstNode::ConstType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Op_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_bytecode_2eproto);
  return file_level_enum_descriptors_bytecode_2eproto[3];
}
bool Op_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LocalType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_bytecode_2eproto);
  return file_level_enum_descriptors_bytecode_2eproto[4];
}
bool LocalType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class Subnode::_Internal {
 public:
  static const ::clojureRT::protobuf::BindingNode& binding(const Subnode* msg);
  static const ::clojureRT::protobuf::CaseNode& case_(const Subnode* msg);
  static const ::clojureRT::protobuf::CaseTestNode& casetest(const Subnode* msg);
  static const ::clojureRT::protobuf::CaseThenNode& casethen(const Subnode* msg);
  static const ::clojureRT::protobuf::CatchNode& catch_(const Subnode* msg);
  static const ::clojureRT::protobuf::ConstNode& const_(const Subnode* msg);
  static const ::clojureRT::protobuf::DefNode& def(const Subnode* msg);
  static const ::clojureRT::protobuf::DeftypeNode& deftype(const Subnode* msg);
  static const ::clojureRT::protobuf::DoNode& do_(const Subnode* msg);
  static const ::clojureRT::protobuf::FnNode& fn(const Subnode* msg);
  static const ::clojureRT::protobuf::FnMethodNode& fnmethod(const Subnode* msg);
  static const ::clojureRT::protobuf::HostInteropNode& hostinterop(const Subnode* msg);
  static const ::clojureRT::protobuf::IfNode& if_(const Subnode* msg);
  static const ::clojureRT::protobuf::ImportNode& import(const Subnode* msg);
  static const ::clojureRT::protobuf::InstanceCallNode& instancecall(const Subnode* msg);
  static const ::clojureRT::protobuf::InstanceFieldNode& instancefield(const Subnode* msg);
  static const ::clojureRT::protobuf::IsInstanceNode& isinstance(const Subnode* msg);
  static const ::clojureRT::protobuf::InvokeNode& invoke(const Subnode* msg);
  static const ::clojureRT::protobuf::KeywordInvokeNode& keywordinvoke(const Subnode* msg);
  static const ::clojureRT::protobuf::LetNode& let(const Subnode* msg);
  static const ::clojureRT::protobuf::LetfnNode& letfn(const Subnode* msg);
  static const ::clojureRT::protobuf::LocalNode& local(const Subnode* msg);
  static const ::clojureRT::protobuf::LoopNode& loop(const Subnode* msg);
  static const ::clojureRT::protobuf::MapNode& map(const Subnode* msg);
  static const ::clojureRT::protobuf::MethodNode& method(const Subnode* msg);
  static const ::clojureRT::protobuf::MonitorEnterNode& monitorenter(const Subnode* msg);
  static const ::clojureRT::protobuf::MonitorExitNode& monitorexit(const Subnode* msg);
  static const ::clojureRT::protobuf::NewNode& new_(const Subnode* msg);
  static const ::clojureRT::protobuf::PrimInvokeNode& priminvoke(const Subnode* msg);
  static const ::clojureRT::protobuf::ProtocolInvokeNode& protocolinvoke(const Subnode* msg);
  static const ::clojureRT::protobuf::QuoteNode& quote(const Subnode* msg);
  static const ::clojureRT::protobuf::RecurNode& recur(const Subnode* msg);
  static const ::clojureRT::protobuf::ReifyNode& reify(const Subnode* msg);
  static const ::clojureRT::protobuf::SetNode& set(const Subnode* msg);
  static const ::clojureRT::protobuf::MutateSetNode& mutateset(const Subnode* msg);
  static const ::clojureRT::protobuf::StaticCallNode& staticcall(const Subnode* msg);
  static const ::clojureRT::protobuf::StaticFieldNode& staticfield(const Subnode* msg);
  static const ::clojureRT::protobuf::TheVarNode& thevar(const Subnode* msg);
  static const ::clojureRT::protobuf::ThrowNode& throw_(const Subnode* msg);
  static const ::clojureRT::protobuf::TryNode& try_(const Subnode* msg);
  static const ::clojureRT::protobuf::VarNode& var(const Subnode* msg);
  static const ::clojureRT::protobuf::VectorNode& vector(const Subnode* msg);
  static const ::clojureRT::protobuf::WithMetaNode& withmeta(const Subnode* msg);
};

const ::clojureRT::protobuf::BindingNode&
Subnode::_Internal::binding(const Subnode* msg) {
  return *msg->_impl_.types_.binding_;
}
const ::clojureRT::protobuf::CaseNode&
Subnode::_Internal::case_(const Subnode* msg) {
  return *msg->_impl_.types_.case__;
}
const ::clojureRT::protobuf::CaseTestNode&
Subnode::_Internal::casetest(const Subnode* msg) {
  return *msg->_impl_.types_.casetest_;
}
const ::clojureRT::protobuf::CaseThenNode&
Subnode::_Internal::casethen(const Subnode* msg) {
  return *msg->_impl_.types_.casethen_;
}
const ::clojureRT::protobuf::CatchNode&
Subnode::_Internal::catch_(const Subnode* msg) {
  return *msg->_impl_.types_.catch__;
}
const ::clojureRT::protobuf::ConstNode&
Subnode::_Internal::const_(const Subnode* msg) {
  return *msg->_impl_.types_.const__;
}
const ::clojureRT::protobuf::DefNode&
Subnode::_Internal::def(const Subnode* msg) {
  return *msg->_impl_.types_.def_;
}
const ::clojureRT::protobuf::DeftypeNode&
Subnode::_Internal::deftype(const Subnode* msg) {
  return *msg->_impl_.types_.deftype_;
}
const ::clojureRT::protobuf::DoNode&
Subnode::_Internal::do_(const Subnode* msg) {
  return *msg->_impl_.types_.do__;
}
const ::clojureRT::protobuf::FnNode&
Subnode::_Internal::fn(const Subnode* msg) {
  return *msg->_impl_.types_.fn_;
}
const ::clojureRT::protobuf::FnMethodNode&
Subnode::_Internal::fnmethod(const Subnode* msg) {
  return *msg->_impl_.types_.fnmethod_;
}
const ::clojureRT::protobuf::HostInteropNode&
Subnode::_Internal::hostinterop(const Subnode* msg) {
  return *msg->_impl_.types_.hostinterop_;
}
const ::clojureRT::protobuf::IfNode&
Subnode::_Internal::if_(const Subnode* msg) {
  return *msg->_impl_.types_.if__;
}
const ::clojureRT::protobuf::ImportNode&
Subnode::_Internal::import(const Subnode* msg) {
  return *msg->_impl_.types_.import_;
}
const ::clojureRT::protobuf::InstanceCallNode&
Subnode::_Internal::instancecall(const Subnode* msg) {
  return *msg->_impl_.types_.instancecall_;
}
const ::clojureRT::protobuf::InstanceFieldNode&
Subnode::_Internal::instancefield(const Subnode* msg) {
  return *msg->_impl_.types_.instancefield_;
}
const ::clojureRT::protobuf::IsInstanceNode&
Subnode::_Internal::isinstance(const Subnode* msg) {
  return *msg->_impl_.types_.isinstance_;
}
const ::clojureRT::protobuf::InvokeNode&
Subnode::_Internal::invoke(const Subnode* msg) {
  return *msg->_impl_.types_.invoke_;
}
const ::clojureRT::protobuf::KeywordInvokeNode&
Subnode::_Internal::keywordinvoke(const Subnode* msg) {
  return *msg->_impl_.types_.keywordinvoke_;
}
const ::clojureRT::protobuf::LetNode&
Subnode::_Internal::let(const Subnode* msg) {
  return *msg->_impl_.types_.let_;
}
const ::clojureRT::protobuf::LetfnNode&
Subnode::_Internal::letfn(const Subnode* msg) {
  return *msg->_impl_.types_.letfn_;
}
const ::clojureRT::protobuf::LocalNode&
Subnode::_Internal::local(const Subnode* msg) {
  return *msg->_impl_.types_.local_;
}
const ::clojureRT::protobuf::LoopNode&
Subnode::_Internal::loop(const Subnode* msg) {
  return *msg->_impl_.types_.loop_;
}
const ::clojureRT::protobuf::MapNode&
Subnode::_Internal::map(const Subnode* msg) {
  return *msg->_impl_.types_.map_;
}
const ::clojureRT::protobuf::MethodNode&
Subnode::_Internal::method(const Subnode* msg) {
  return *msg->_impl_.types_.method_;
}
const ::clojureRT::protobuf::MonitorEnterNode&
Subnode::_Internal::monitorenter(const Subnode* msg) {
  return *msg->_impl_.types_.monitorenter_;
}
const ::clojureRT::protobuf::MonitorExitNode&
Subnode::_Internal::monitorexit(const Subnode* msg) {
  return *msg->_impl_.types_.monitorexit_;
}
const ::clojureRT::protobuf::NewNode&
Subnode::_Internal::new_(const Subnode* msg) {
  return *msg->_impl_.types_.new__;
}
const ::clojureRT::protobuf::PrimInvokeNode&
Subnode::_Internal::priminvoke(const Subnode* msg) {
  return *msg->_impl_.types_.priminvoke_;
}
const ::clojureRT::protobuf::ProtocolInvokeNode&
Subnode::_Internal::protocolinvoke(const Subnode* msg) {
  return *msg->_impl_.types_.protocolinvoke_;
}
const ::clojureRT::protobuf::QuoteNode&
Subnode::_Internal::quote(const Subnode* msg) {
  return *msg->_impl_.types_.quote_;
}
const ::clojureRT::protobuf::RecurNode&
Subnode::_Internal::recur(const Subnode* msg) {
  return *msg->_impl_.types_.recur_;
}
const ::clojureRT::protobuf::ReifyNode&
Subnode::_Internal::reify(const Subnode* msg) {
  return *msg->_impl_.types_.reify_;
}
const ::clojureRT::protobuf::SetNode&
Subnode::_Internal::set(const Subnode* msg) {
  return *msg->_impl_.types_.set_;
}
const ::clojureRT::protobuf::MutateSetNode&
Subnode::_Internal::mutateset(const Subnode* msg) {
  return *msg->_impl_.types_.mutateset_;
}
const ::clojureRT::protobuf::StaticCallNode&
Subnode::_Internal::staticcall(const Subnode* msg) {
  return *msg->_impl_.types_.staticcall_;
}
const ::clojureRT::protobuf::StaticFieldNode&
Subnode::_Internal::staticfield(const Subnode* msg) {
  return *msg->_impl_.types_.staticfield_;
}
const ::clojureRT::protobuf::TheVarNode&
Subnode::_Internal::thevar(const Subnode* msg) {
  return *msg->_impl_.types_.thevar_;
}
const ::clojureRT::protobuf::ThrowNode&
Subnode::_Internal::throw_(const Subnode* msg) {
  return *msg->_impl_.types_.throw__;
}
const ::clojureRT::protobuf::TryNode&
Subnode::_Internal::try_(const Subnode* msg) {
  return *msg->_impl_.types_.try__;
}
const ::clojureRT::protobuf::VarNode&
Subnode::_Internal::var(const Subnode* msg) {
  return *msg->_impl_.types_.var_;
}
const ::clojureRT::protobuf::VectorNode&
Subnode::_Internal::vector(const Subnode* msg) {
  return *msg->_impl_.types_.vector_;
}
const ::clojureRT::protobuf::WithMetaNode&
Subnode::_Internal::withmeta(const Subnode* msg) {
  return *msg->_impl_.types_.withmeta_;
}
void Subnode::set_allocated_binding(::clojureRT::protobuf::BindingNode* binding) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (binding) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(binding);
    if (message_arena != submessage_arena) {
      binding = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, binding, submessage_arena);
    }
    set_has_binding();
    _impl_.types_.binding_ = binding;
  }
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.Subnode.binding)
}
void Subnode::set_allocated_case_(::clojureRT::protobuf::CaseNode* case_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (case_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(case_);
    if (message_arena != submessage_arena) {
      case_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, case_, submessage_arena);
    }
    set_has_case_();
    _impl_.types_.case__ = case_;
  }
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.Subnode.case)
}
void Subnode::set_allocated_casetest(::clojureRT::protobuf::CaseTestNode* casetest) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (casetest) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(casetest);
    if (message_arena != submessage_arena) {
      casetest = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, casetest, submessage_arena);
    }
    set_has_casetest();
    _impl_.types_.casetest_ = casetest;
  }
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.Subnode.caseTest)
}
void Subnode::set_allocated_casethen(::clojureRT::protobuf::CaseThenNode* casethen) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (casethen) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(casethen);
    if (message_arena != submessage_arena) {
      casethen = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, casethen, submessage_arena);
    }
    set_has_casethen();
    _impl_.types_.casethen_ = casethen;
  }
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.Subnode.caseThen)
}
void Subnode::set_allocated_catch_(::clojureRT::protobuf::CatchNode* catch_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (catch_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(catch_);
    if (message_arena != submessage_arena) {
      catch_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, catch_, submessage_arena);
    }
    set_has_catch_();
    _impl_.types_.catch__ = catch_;
  }
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.Subnode.catch)
}
void Subnode::set_allocated_const_(::clojureRT::protobuf::ConstNode* const_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (const_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(const_);
    if (message_arena != submessage_arena) {
      const_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, const_, submessage_arena);
    }
    set_has_const_();
    _impl_.types_.const__ = const_;
  }
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.Subnode.const)
}
void Subnode::set_allocated_def(::clojureRT::protobuf::DefNode* def) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (def) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(def);
    if (message_arena != submessage_arena) {
      def = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, def, submessage_arena);
    }
    set_has_def();
    _impl_.types_.def_ = def;
  }
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.Subnode.def)
}
void Subnode::set_allocated_deftype(::clojureRT::protobuf::DeftypeNode* deftype) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (deftype) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(deftype);
    if (message_arena != submessage_arena) {
      deftype = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, deftype, submessage_arena);
    }
    set_has_deftype();
    _impl_.types_.deftype_ = deftype;
  }
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.Subnode.deftype)
}
void Subnode::set_allocated_do_(::clojureRT::protobuf::DoNode* do_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (do_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(do_);
    if (message_arena != submessage_arena) {
      do_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, do_, submessage_arena);
    }
    set_has_do_();
    _impl_.types_.do__ = do_;
  }
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.Subnode.do)
}
void Subnode::set_allocated_fn(::clojureRT::protobuf::FnNode* fn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (fn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fn);
    if (message_arena != submessage_arena) {
      fn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fn, submessage_arena);
    }
    set_has_fn();
    _impl_.types_.fn_ = fn;
  }
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.Subnode.fn)
}
void Subnode::set_allocated_fnmethod(::clojureRT::protobuf::FnMethodNode* fnmethod) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (fnmethod) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fnmethod);
    if (message_arena != submessage_arena) {
      fnmethod = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fnmethod, submessage_arena);
    }
    set_has_fnmethod();
    _impl_.types_.fnmethod_ = fnmethod;
  }
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.Subnode.fnMethod)
}
void Subnode::set_allocated_hostinterop(::clojureRT::protobuf::HostInteropNode* hostinterop) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (hostinterop) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(hostinterop);
    if (message_arena != submessage_arena) {
      hostinterop = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hostinterop, submessage_arena);
    }
    set_has_hostinterop();
    _impl_.types_.hostinterop_ = hostinterop;
  }
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.Subnode.hostInterop)
}
void Subnode::set_allocated_if_(::clojureRT::protobuf::IfNode* if_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (if_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(if_);
    if (message_arena != submessage_arena) {
      if_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, if_, submessage_arena);
    }
    set_has_if_();
    _impl_.types_.if__ = if_;
  }
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.Subnode.if)
}
void Subnode::set_allocated_import(::clojureRT::protobuf::ImportNode* import) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (import) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(import);
    if (message_arena != submessage_arena) {
      import = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, import, submessage_arena);
    }
    set_has_import();
    _impl_.types_.import_ = import;
  }
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.Subnode.import)
}
void Subnode::set_allocated_instancecall(::clojureRT::protobuf::InstanceCallNode* instancecall) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (instancecall) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(instancecall);
    if (message_arena != submessage_arena) {
      instancecall = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, instancecall, submessage_arena);
    }
    set_has_instancecall();
    _impl_.types_.instancecall_ = instancecall;
  }
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.Subnode.instanceCall)
}
void Subnode::set_allocated_instancefield(::clojureRT::protobuf::InstanceFieldNode* instancefield) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (instancefield) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(instancefield);
    if (message_arena != submessage_arena) {
      instancefield = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, instancefield, submessage_arena);
    }
    set_has_instancefield();
    _impl_.types_.instancefield_ = instancefield;
  }
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.Subnode.instanceField)
}
void Subnode::set_allocated_isinstance(::clojureRT::protobuf::IsInstanceNode* isinstance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (isinstance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(isinstance);
    if (message_arena != submessage_arena) {
      isinstance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, isinstance, submessage_arena);
    }
    set_has_isinstance();
    _impl_.types_.isinstance_ = isinstance;
  }
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.Subnode.isInstance)
}
void Subnode::set_allocated_invoke(::clojureRT::protobuf::InvokeNode* invoke) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (invoke) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(invoke);
    if (message_arena != submessage_arena) {
      invoke = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, invoke, submessage_arena);
    }
    set_has_invoke();
    _impl_.types_.invoke_ = invoke;
  }
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.Subnode.invoke)
}
void Subnode::set_allocated_keywordinvoke(::clojureRT::protobuf::KeywordInvokeNode* keywordinvoke) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (keywordinvoke) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(keywordinvoke);
    if (message_arena != submessage_arena) {
      keywordinvoke = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, keywordinvoke, submessage_arena);
    }
    set_has_keywordinvoke();
    _impl_.types_.keywordinvoke_ = keywordinvoke;
  }
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.Subnode.keywordInvoke)
}
void Subnode::set_allocated_let(::clojureRT::protobuf::LetNode* let) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (let) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(let);
    if (message_arena != submessage_arena) {
      let = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, let, submessage_arena);
    }
    set_has_let();
    _impl_.types_.let_ = let;
  }
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.Subnode.let)
}
void Subnode::set_allocated_letfn(::clojureRT::protobuf::LetfnNode* letfn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (letfn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(letfn);
    if (message_arena != submessage_arena) {
      letfn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, letfn, submessage_arena);
    }
    set_has_letfn();
    _impl_.types_.letfn_ = letfn;
  }
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.Subnode.letfn)
}
void Subnode::set_allocated_local(::clojureRT::protobuf::LocalNode* local) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (local) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(local);
    if (message_arena != submessage_arena) {
      local = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, local, submessage_arena);
    }
    set_has_local();
    _impl_.types_.local_ = local;
  }
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.Subnode.local)
}
void Subnode::set_allocated_loop(::clojureRT::protobuf::LoopNode* loop) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (loop) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(loop);
    if (message_arena != submessage_arena) {
      loop = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, loop, submessage_arena);
    }
    set_has_loop();
    _impl_.types_.loop_ = loop;
  }
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.Subnode.loop)
}
void Subnode::set_allocated_map(::clojureRT::protobuf::MapNode* map) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (map) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(map);
    if (message_arena != submessage_arena) {
      map = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, map, submessage_arena);
    }
    set_has_map();
    _impl_.types_.map_ = map;
  }
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.Subnode.map)
}
void Subnode::set_allocated_method(::clojureRT::protobuf::MethodNode* method) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (method) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(method);
    if (message_arena != submessage_arena) {
      method = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, method, submessage_arena);
    }
    set_has_method();
    _impl_.types_.method_ = method;
  }
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.Subnode.method)
}
void Subnode::set_allocated_monitorenter(::clojureRT::protobuf::MonitorEnterNode* monitorenter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (monitorenter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(monitorenter);
    if (message_arena != submessage_arena) {
      monitorenter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, monitorenter, submessage_arena);
    }
    set_has_monitorenter();
    _impl_.types_.monitorenter_ = monitorenter;
  }
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.Subnode.monitorEnter)
}
void Subnode::set_allocated_monitorexit(::clojureRT::protobuf::MonitorExitNode* monitorexit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (monitorexit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(monitorexit);
    if (message_arena != submessage_arena) {
      monitorexit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, monitorexit, submessage_arena);
    }
    set_has_monitorexit();
    _impl_.types_.monitorexit_ = monitorexit;
  }
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.Subnode.monitorExit)
}
void Subnode::set_allocated_new_(::clojureRT::protobuf::NewNode* new_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (new_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(new_);
    if (message_arena != submessage_arena) {
      new_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, new_, submessage_arena);
    }
    set_has_new_();
    _impl_.types_.new__ = new_;
  }
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.Subnode.new)
}
void Subnode::set_allocated_priminvoke(::clojureRT::protobuf::PrimInvokeNode* priminvoke) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (priminvoke) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(priminvoke);
    if (message_arena != submessage_arena) {
      priminvoke = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, priminvoke, submessage_arena);
    }
    set_has_priminvoke();
    _impl_.types_.priminvoke_ = priminvoke;
  }
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.Subnode.primInvoke)
}
void Subnode::set_allocated_protocolinvoke(::clojureRT::protobuf::ProtocolInvokeNode* protocolinvoke) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (protocolinvoke) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(protocolinvoke);
    if (message_arena != submessage_arena) {
      protocolinvoke = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, protocolinvoke, submessage_arena);
    }
    set_has_protocolinvoke();
    _impl_.types_.protocolinvoke_ = protocolinvoke;
  }
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.Subnode.protocolInvoke)
}
void Subnode::set_allocated_quote(::clojureRT::protobuf::QuoteNode* quote) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (quote) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(quote);
    if (message_arena != submessage_arena) {
      quote = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, quote, submessage_arena);
    }
    set_has_quote();
    _impl_.types_.quote_ = quote;
  }
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.Subnode.quote)
}
void Subnode::set_allocated_recur(::clojureRT::protobuf::RecurNode* recur) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (recur) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(recur);
    if (message_arena != submessage_arena) {
      recur = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, recur, submessage_arena);
    }
    set_has_recur();
    _impl_.types_.recur_ = recur;
  }
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.Subnode.recur)
}
void Subnode::set_allocated_reify(::clojureRT::protobuf::ReifyNode* reify) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (reify) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reify);
    if (message_arena != submessage_arena) {
      reify = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reify, submessage_arena);
    }
    set_has_reify();
    _impl_.types_.reify_ = reify;
  }
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.Subnode.reify)
}
void Subnode::set_allocated_set(::clojureRT::protobuf::SetNode* set) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (set) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(set);
    if (message_arena != submessage_arena) {
      set = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, set, submessage_arena);
    }
    set_has_set();
    _impl_.types_.set_ = set;
  }
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.Subnode.set)
}
void Subnode::set_allocated_mutateset(::clojureRT::protobuf::MutateSetNode* mutateset) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (mutateset) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(mutateset);
    if (message_arena != submessage_arena) {
      mutateset = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mutateset, submessage_arena);
    }
    set_has_mutateset();
    _impl_.types_.mutateset_ = mutateset;
  }
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.Subnode.mutateSet)
}
void Subnode::set_allocated_staticcall(::clojureRT::protobuf::StaticCallNode* staticcall) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (staticcall) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(staticcall);
    if (message_arena != submessage_arena) {
      staticcall = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, staticcall, submessage_arena);
    }
    set_has_staticcall();
    _impl_.types_.staticcall_ = staticcall;
  }
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.Subnode.staticCall)
}
void Subnode::set_allocated_staticfield(::clojureRT::protobuf::StaticFieldNode* staticfield) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (staticfield) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(staticfield);
    if (message_arena != submessage_arena) {
      staticfield = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, staticfield, submessage_arena);
    }
    set_has_staticfield();
    _impl_.types_.staticfield_ = staticfield;
  }
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.Subnode.staticField)
}
void Subnode::set_allocated_thevar(::clojureRT::protobuf::TheVarNode* thevar) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (thevar) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(thevar);
    if (message_arena != submessage_arena) {
      thevar = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, thevar, submessage_arena);
    }
    set_has_thevar();
    _impl_.types_.thevar_ = thevar;
  }
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.Subnode.theVar)
}
void Subnode::set_allocated_throw_(::clojureRT::protobuf::ThrowNode* throw_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (throw_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(throw_);
    if (message_arena != submessage_arena) {
      throw_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, throw_, submessage_arena);
    }
    set_has_throw_();
    _impl_.types_.throw__ = throw_;
  }
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.Subnode.throw)
}
void Subnode::set_allocated_try_(::clojureRT::protobuf::TryNode* try_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (try_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(try_);
    if (message_arena != submessage_arena) {
      try_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, try_, submessage_arena);
    }
    set_has_try_();
    _impl_.types_.try__ = try_;
  }
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.Subnode.try)
}
void Subnode::set_allocated_var(::clojureRT::protobuf::VarNode* var) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (var) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(var);
    if (message_arena != submessage_arena) {
      var = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, var, submessage_arena);
    }
    set_has_var();
    _impl_.types_.var_ = var;
  }
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.Subnode.var)
}
void Subnode::set_allocated_vector(::clojureRT::protobuf::VectorNode* vector) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (vector) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(vector);
    if (message_arena != submessage_arena) {
      vector = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vector, submessage_arena);
    }
    set_has_vector();
    _impl_.types_.vector_ = vector;
  }
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.Subnode.vector)
}
void Subnode::set_allocated_withmeta(::clojureRT::protobuf::WithMetaNode* withmeta) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (withmeta) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(withmeta);
    if (message_arena != submessage_arena) {
      withmeta = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, withmeta, submessage_arena);
    }
    set_has_withmeta();
    _impl_.types_.withmeta_ = withmeta;
  }
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.Subnode.withMeta)
}
Subnode::Subnode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojureRT.protobuf.Subnode)
}
Subnode::Subnode(const Subnode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Subnode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.types_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_types();
  switch (from.types_case()) {
    case kBinding: {
      _this->_internal_mutable_binding()->::clojureRT::protobuf::BindingNode::MergeFrom(
          from._internal_binding());
      break;
    }
    case kCase: {
      _this->_internal_mutable_case_()->::clojureRT::protobuf::CaseNode::MergeFrom(
          from._internal_case_());
      break;
    }
    case kCaseTest: {
      _this->_internal_mutable_casetest()->::clojureRT::protobuf::CaseTestNode::MergeFrom(
          from._internal_casetest());
      break;
    }
    case kCaseThen: {
      _this->_internal_mutable_casethen()->::clojureRT::protobuf::CaseThenNode::MergeFrom(
          from._internal_casethen());
      break;
    }
    case kCatch: {
      _this->_internal_mutable_catch_()->::clojureRT::protobuf::CatchNode::MergeFrom(
          from._internal_catch_());
      break;
    }
    case kConst: {
      _this->_internal_mutable_const_()->::clojureRT::protobuf::ConstNode::MergeFrom(
          from._internal_const_());
      break;
    }
    case kDef: {
      _this->_internal_mutable_def()->::clojureRT::protobuf::DefNode::MergeFrom(
          from._internal_def());
      break;
    }
    case kDeftype: {
      _this->_internal_mutable_deftype()->::clojureRT::protobuf::DeftypeNode::MergeFrom(
          from._internal_deftype());
      break;
    }
    case kDo: {
      _this->_internal_mutable_do_()->::clojureRT::protobuf::DoNode::MergeFrom(
          from._internal_do_());
      break;
    }
    case kFn: {
      _this->_internal_mutable_fn()->::clojureRT::protobuf::FnNode::MergeFrom(
          from._internal_fn());
      break;
    }
    case kFnMethod: {
      _this->_internal_mutable_fnmethod()->::clojureRT::protobuf::FnMethodNode::MergeFrom(
          from._internal_fnmethod());
      break;
    }
    case kHostInterop: {
      _this->_internal_mutable_hostinterop()->::clojureRT::protobuf::HostInteropNode::MergeFrom(
          from._internal_hostinterop());
      break;
    }
    case kIf: {
      _this->_internal_mutable_if_()->::clojureRT::protobuf::IfNode::MergeFrom(
          from._internal_if_());
      break;
    }
    case kImport: {
      _this->_internal_mutable_import()->::clojureRT::protobuf::ImportNode::MergeFrom(
          from._internal_import());
      break;
    }
    case kInstanceCall: {
      _this->_internal_mutable_instancecall()->::clojureRT::protobuf::InstanceCallNode::MergeFrom(
          from._internal_instancecall());
      break;
    }
    case kInstanceField: {
      _this->_internal_mutable_instancefield()->::clojureRT::protobuf::InstanceFieldNode::MergeFrom(
          from._internal_instancefield());
      break;
    }
    case kIsInstance: {
      _this->_internal_mutable_isinstance()->::clojureRT::protobuf::IsInstanceNode::MergeFrom(
          from._internal_isinstance());
      break;
    }
    case kInvoke: {
      _this->_internal_mutable_invoke()->::clojureRT::protobuf::InvokeNode::MergeFrom(
          from._internal_invoke());
      break;
    }
    case kKeywordInvoke: {
      _this->_internal_mutable_keywordinvoke()->::clojureRT::protobuf::KeywordInvokeNode::MergeFrom(
          from._internal_keywordinvoke());
      break;
    }
    case kLet: {
      _this->_internal_mutable_let()->::clojureRT::protobuf::LetNode::MergeFrom(
          from._internal_let());
      break;
    }
    case kLetfn: {
      _this->_internal_mutable_letfn()->::clojureRT::protobuf::LetfnNode::MergeFrom(
          from._internal_letfn());
      break;
    }
    case kLocal: {
      _this->_internal_mutable_local()->::clojureRT::protobuf::LocalNode::MergeFrom(
          from._internal_local());
      break;
    }
    case kLoop: {
      _this->_internal_mutable_loop()->::clojureRT::protobuf::LoopNode::MergeFrom(
          from._internal_loop());
      break;
    }
    case kMap: {
      _this->_internal_mutable_map()->::clojureRT::protobuf::MapNode::MergeFrom(
          from._internal_map());
      break;
    }
    case kMethod: {
      _this->_internal_mutable_method()->::clojureRT::protobuf::MethodNode::MergeFrom(
          from._internal_method());
      break;
    }
    case kMonitorEnter: {
      _this->_internal_mutable_monitorenter()->::clojureRT::protobuf::MonitorEnterNode::MergeFrom(
          from._internal_monitorenter());
      break;
    }
    case kMonitorExit: {
      _this->_internal_mutable_monitorexit()->::clojureRT::protobuf::MonitorExitNode::MergeFrom(
          from._internal_monitorexit());
      break;
    }
    case kNew: {
      _this->_internal_mutable_new_()->::clojureRT::protobuf::NewNode::MergeFrom(
          from._internal_new_());
      break;
    }
    case kPrimInvoke: {
      _this->_internal_mutable_priminvoke()->::clojureRT::protobuf::PrimInvokeNode::MergeFrom(
          from._internal_priminvoke());
      break;
    }
    case kProtocolInvoke: {
      _this->_internal_mutable_protocolinvoke()->::clojureRT::protobuf::ProtocolInvokeNode::MergeFrom(
          from._internal_protocolinvoke());
      break;
    }
    case kQuote: {
      _this->_internal_mutable_quote()->::clojureRT::protobuf::QuoteNode::MergeFrom(
          from._internal_quote());
      break;
    }
    case kRecur: {
      _this->_internal_mutable_recur()->::clojureRT::protobuf::RecurNode::MergeFrom(
          from._internal_recur());
      break;
    }
    case kReify: {
      _this->_internal_mutable_reify()->::clojureRT::protobuf::ReifyNode::MergeFrom(
          from._internal_reify());
      break;
    }
    case kSet: {
      _this->_internal_mutable_set()->::clojureRT::protobuf::SetNode::MergeFrom(
          from._internal_set());
      break;
    }
    case kMutateSet: {
      _this->_internal_mutable_mutateset()->::clojureRT::protobuf::MutateSetNode::MergeFrom(
          from._internal_mutateset());
      break;
    }
    case kStaticCall: {
      _this->_internal_mutable_staticcall()->::clojureRT::protobuf::StaticCallNode::MergeFrom(
          from._internal_staticcall());
      break;
    }
    case kStaticField: {
      _this->_internal_mutable_staticfield()->::clojureRT::protobuf::StaticFieldNode::MergeFrom(
          from._internal_staticfield());
      break;
    }
    case kTheVar: {
      _this->_internal_mutable_thevar()->::clojureRT::protobuf::TheVarNode::MergeFrom(
          from._internal_thevar());
      break;
    }
    case kThrow: {
      _this->_internal_mutable_throw_()->::clojureRT::protobuf::ThrowNode::MergeFrom(
          from._internal_throw_());
      break;
    }
    case kTry: {
      _this->_internal_mutable_try_()->::clojureRT::protobuf::TryNode::MergeFrom(
          from._internal_try_());
      break;
    }
    case kVar: {
      _this->_internal_mutable_var()->::clojureRT::protobuf::VarNode::MergeFrom(
          from._internal_var());
      break;
    }
    case kVector: {
      _this->_internal_mutable_vector()->::clojureRT::protobuf::VectorNode::MergeFrom(
          from._internal_vector());
      break;
    }
    case kWithMeta: {
      _this->_internal_mutable_withmeta()->::clojureRT::protobuf::WithMetaNode::MergeFrom(
          from._internal_withmeta());
      break;
    }
    case TYPES_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:clojureRT.protobuf.Subnode)
}

inline void Subnode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.types_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_types();
}

Subnode::~Subnode() {
  // @@protoc_insertion_point(destructor:clojureRT.protobuf.Subnode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Subnode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_types()) {
    clear_types();
  }
}

void Subnode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Subnode::clear_types() {
// @@protoc_insertion_point(one_of_clear_start:clojureRT.protobuf.Subnode)
  switch (types_case()) {
    case kBinding: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.binding_;
      }
      break;
    }
    case kCase: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.case__;
      }
      break;
    }
    case kCaseTest: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.casetest_;
      }
      break;
    }
    case kCaseThen: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.casethen_;
      }
      break;
    }
    case kCatch: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.catch__;
      }
      break;
    }
    case kConst: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.const__;
      }
      break;
    }
    case kDef: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.def_;
      }
      break;
    }
    case kDeftype: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.deftype_;
      }
      break;
    }
    case kDo: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.do__;
      }
      break;
    }
    case kFn: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.fn_;
      }
      break;
    }
    case kFnMethod: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.fnmethod_;
      }
      break;
    }
    case kHostInterop: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.hostinterop_;
      }
      break;
    }
    case kIf: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.if__;
      }
      break;
    }
    case kImport: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.import_;
      }
      break;
    }
    case kInstanceCall: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.instancecall_;
      }
      break;
    }
    case kInstanceField: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.instancefield_;
      }
      break;
    }
    case kIsInstance: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.isinstance_;
      }
      break;
    }
    case kInvoke: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.invoke_;
      }
      break;
    }
    case kKeywordInvoke: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.keywordinvoke_;
      }
      break;
    }
    case kLet: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.let_;
      }
      break;
    }
    case kLetfn: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.letfn_;
      }
      break;
    }
    case kLocal: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.local_;
      }
      break;
    }
    case kLoop: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.loop_;
      }
      break;
    }
    case kMap: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.map_;
      }
      break;
    }
    case kMethod: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.method_;
      }
      break;
    }
    case kMonitorEnter: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.monitorenter_;
      }
      break;
    }
    case kMonitorExit: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.monitorexit_;
      }
      break;
    }
    case kNew: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.new__;
      }
      break;
    }
    case kPrimInvoke: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.priminvoke_;
      }
      break;
    }
    case kProtocolInvoke: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.protocolinvoke_;
      }
      break;
    }
    case kQuote: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.quote_;
      }
      break;
    }
    case kRecur: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.recur_;
      }
      break;
    }
    case kReify: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.reify_;
      }
      break;
    }
    case kSet: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.set_;
      }
      break;
    }
    case kMutateSet: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.mutateset_;
      }
      break;
    }
    case kStaticCall: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.staticcall_;
      }
      break;
    }
    case kStaticField: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.staticfield_;
      }
      break;
    }
    case kTheVar: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.thevar_;
      }
      break;
    }
    case kThrow: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.throw__;
      }
      break;
    }
    case kTry: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.try__;
      }
      break;
    }
    case kVar: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.var_;
      }
      break;
    }
    case kVector: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.vector_;
      }
      break;
    }
    case kWithMeta: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.withmeta_;
      }
      break;
    }
    case TYPES_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = TYPES_NOT_SET;
}


void Subnode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojureRT.protobuf.Subnode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_types();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Subnode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .clojureRT.protobuf.BindingNode binding = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_binding(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.CaseNode case = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_case_(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.CaseTestNode caseTest = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_casetest(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.CaseThenNode caseThen = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_casethen(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.CatchNode catch = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_catch_(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.ConstNode const = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_const_(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.DefNode def = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_def(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.DeftypeNode deftype = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_deftype(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.DoNode do = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_do_(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.FnNode fn = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_fn(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.FnMethodNode fnMethod = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_fnmethod(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.HostInteropNode hostInterop = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_hostinterop(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.IfNode if = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_if_(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.ImportNode import = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_import(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.InstanceCallNode instanceCall = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_instancecall(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.InstanceFieldNode instanceField = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_instancefield(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.IsInstanceNode isInstance = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_isinstance(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.InvokeNode invoke = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_invoke(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.KeywordInvokeNode keywordInvoke = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_keywordinvoke(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.LetNode let = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_let(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.LetfnNode letfn = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          ptr = ctx->ParseMessage(_internal_mutable_letfn(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.LocalNode local = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          ptr = ctx->ParseMessage(_internal_mutable_local(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.LoopNode loop = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 186)) {
          ptr = ctx->ParseMessage(_internal_mutable_loop(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.MapNode map = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 194)) {
          ptr = ctx->ParseMessage(_internal_mutable_map(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.MethodNode method = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 202)) {
          ptr = ctx->ParseMessage(_internal_mutable_method(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.MonitorEnterNode monitorEnter = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 210)) {
          ptr = ctx->ParseMessage(_internal_mutable_monitorenter(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.MonitorExitNode monitorExit = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 218)) {
          ptr = ctx->ParseMessage(_internal_mutable_monitorexit(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.NewNode new = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 226)) {
          ptr = ctx->ParseMessage(_internal_mutable_new_(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.PrimInvokeNode primInvoke = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 234)) {
          ptr = ctx->ParseMessage(_internal_mutable_priminvoke(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.ProtocolInvokeNode protocolInvoke = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 242)) {
          ptr = ctx->ParseMessage(_internal_mutable_protocolinvoke(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.QuoteNode quote = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 250)) {
          ptr = ctx->ParseMessage(_internal_mutable_quote(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.RecurNode recur = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 2)) {
          ptr = ctx->ParseMessage(_internal_mutable_recur(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.ReifyNode reify = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_reify(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.SetNode set = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_set(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.MutateSetNode mutateSet = 35;
      case 35:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_mutateset(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.StaticCallNode staticCall = 36;
      case 36:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_staticcall(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.StaticFieldNode staticField = 37;
      case 37:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_staticfield(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.TheVarNode theVar = 38;
      case 38:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_thevar(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.ThrowNode throw = 39;
      case 39:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_throw_(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.TryNode try = 40;
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_try_(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.VarNode var = 41;
      case 41:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_var(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.VectorNode vector = 42;
      case 42:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_vector(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.WithMetaNode withMeta = 43;
      case 43:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_withmeta(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Subnode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojureRT.protobuf.Subnode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .clojureRT.protobuf.BindingNode binding = 1;
  if (_internal_has_binding()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::binding(this),
        _Internal::binding(this).GetCachedSize(), target, stream);
  }

  // .clojureRT.protobuf.CaseNode case = 2;
  if (_internal_has_case_()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::case_(this),
        _Internal::case_(this).GetCachedSize(), target, stream);
  }

  // .clojureRT.protobuf.CaseTestNode caseTest = 3;
  if (_internal_has_casetest()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::casetest(this),
        _Internal::casetest(this).GetCachedSize(), target, stream);
  }

  // .clojureRT.protobuf.CaseThenNode caseThen = 4;
  if (_internal_has_casethen()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::casethen(this),
        _Internal::casethen(this).GetCachedSize(), target, stream);
  }

  // .clojureRT.protobuf.CatchNode catch = 5;
  if (_internal_has_catch_()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::catch_(this),
        _Internal::catch_(this).GetCachedSize(), target, stream);
  }

  // .clojureRT.protobuf.ConstNode const = 6;
  if (_internal_has_const_()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::const_(this),
        _Internal::const_(this).GetCachedSize(), target, stream);
  }

  // .clojureRT.protobuf.DefNode def = 7;
  if (_internal_has_def()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::def(this),
        _Internal::def(this).GetCachedSize(), target, stream);
  }

  // .clojureRT.protobuf.DeftypeNode deftype = 8;
  if (_internal_has_deftype()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::deftype(this),
        _Internal::deftype(this).GetCachedSize(), target, stream);
  }

  // .clojureRT.protobuf.DoNode do = 9;
  if (_internal_has_do_()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::do_(this),
        _Internal::do_(this).GetCachedSize(), target, stream);
  }

  // .clojureRT.protobuf.FnNode fn = 10;
  if (_internal_has_fn()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::fn(this),
        _Internal::fn(this).GetCachedSize(), target, stream);
  }

  // .clojureRT.protobuf.FnMethodNode fnMethod = 11;
  if (_internal_has_fnmethod()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::fnmethod(this),
        _Internal::fnmethod(this).GetCachedSize(), target, stream);
  }

  // .clojureRT.protobuf.HostInteropNode hostInterop = 12;
  if (_internal_has_hostinterop()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::hostinterop(this),
        _Internal::hostinterop(this).GetCachedSize(), target, stream);
  }

  // .clojureRT.protobuf.IfNode if = 13;
  if (_internal_has_if_()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, _Internal::if_(this),
        _Internal::if_(this).GetCachedSize(), target, stream);
  }

  // .clojureRT.protobuf.ImportNode import = 14;
  if (_internal_has_import()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(14, _Internal::import(this),
        _Internal::import(this).GetCachedSize(), target, stream);
  }

  // .clojureRT.protobuf.InstanceCallNode instanceCall = 15;
  if (_internal_has_instancecall()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(15, _Internal::instancecall(this),
        _Internal::instancecall(this).GetCachedSize(), target, stream);
  }

  // .clojureRT.protobuf.InstanceFieldNode instanceField = 16;
  if (_internal_has_instancefield()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(16, _Internal::instancefield(this),
        _Internal::instancefield(this).GetCachedSize(), target, stream);
  }

  // .clojureRT.protobuf.IsInstanceNode isInstance = 17;
  if (_internal_has_isinstance()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(17, _Internal::isinstance(this),
        _Internal::isinstance(this).GetCachedSize(), target, stream);
  }

  // .clojureRT.protobuf.InvokeNode invoke = 18;
  if (_internal_has_invoke()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(18, _Internal::invoke(this),
        _Internal::invoke(this).GetCachedSize(), target, stream);
  }

  // .clojureRT.protobuf.KeywordInvokeNode keywordInvoke = 19;
  if (_internal_has_keywordinvoke()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(19, _Internal::keywordinvoke(this),
        _Internal::keywordinvoke(this).GetCachedSize(), target, stream);
  }

  // .clojureRT.protobuf.LetNode let = 20;
  if (_internal_has_let()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(20, _Internal::let(this),
        _Internal::let(this).GetCachedSize(), target, stream);
  }

  // .clojureRT.protobuf.LetfnNode letfn = 21;
  if (_internal_has_letfn()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(21, _Internal::letfn(this),
        _Internal::letfn(this).GetCachedSize(), target, stream);
  }

  // .clojureRT.protobuf.LocalNode local = 22;
  if (_internal_has_local()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(22, _Internal::local(this),
        _Internal::local(this).GetCachedSize(), target, stream);
  }

  // .clojureRT.protobuf.LoopNode loop = 23;
  if (_internal_has_loop()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(23, _Internal::loop(this),
        _Internal::loop(this).GetCachedSize(), target, stream);
  }

  // .clojureRT.protobuf.MapNode map = 24;
  if (_internal_has_map()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(24, _Internal::map(this),
        _Internal::map(this).GetCachedSize(), target, stream);
  }

  // .clojureRT.protobuf.MethodNode method = 25;
  if (_internal_has_method()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(25, _Internal::method(this),
        _Internal::method(this).GetCachedSize(), target, stream);
  }

  // .clojureRT.protobuf.MonitorEnterNode monitorEnter = 26;
  if (_internal_has_monitorenter()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(26, _Internal::monitorenter(this),
        _Internal::monitorenter(this).GetCachedSize(), target, stream);
  }

  // .clojureRT.protobuf.MonitorExitNode monitorExit = 27;
  if (_internal_has_monitorexit()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(27, _Internal::monitorexit(this),
        _Internal::monitorexit(this).GetCachedSize(), target, stream);
  }

  // .clojureRT.protobuf.NewNode new = 28;
  if (_internal_has_new_()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(28, _Internal::new_(this),
        _Internal::new_(this).GetCachedSize(), target, stream);
  }

  // .clojureRT.protobuf.PrimInvokeNode primInvoke = 29;
  if (_internal_has_priminvoke()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(29, _Internal::priminvoke(this),
        _Internal::priminvoke(this).GetCachedSize(), target, stream);
  }

  // .clojureRT.protobuf.ProtocolInvokeNode protocolInvoke = 30;
  if (_internal_has_protocolinvoke()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(30, _Internal::protocolinvoke(this),
        _Internal::protocolinvoke(this).GetCachedSize(), target, stream);
  }

  // .clojureRT.protobuf.QuoteNode quote = 31;
  if (_internal_has_quote()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(31, _Internal::quote(this),
        _Internal::quote(this).GetCachedSize(), target, stream);
  }

  // .clojureRT.protobuf.RecurNode recur = 32;
  if (_internal_has_recur()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(32, _Internal::recur(this),
        _Internal::recur(this).GetCachedSize(), target, stream);
  }

  // .clojureRT.protobuf.ReifyNode reify = 33;
  if (_internal_has_reify()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(33, _Internal::reify(this),
        _Internal::reify(this).GetCachedSize(), target, stream);
  }

  // .clojureRT.protobuf.SetNode set = 34;
  if (_internal_has_set()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(34, _Internal::set(this),
        _Internal::set(this).GetCachedSize(), target, stream);
  }

  // .clojureRT.protobuf.MutateSetNode mutateSet = 35;
  if (_internal_has_mutateset()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(35, _Internal::mutateset(this),
        _Internal::mutateset(this).GetCachedSize(), target, stream);
  }

  // .clojureRT.protobuf.StaticCallNode staticCall = 36;
  if (_internal_has_staticcall()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(36, _Internal::staticcall(this),
        _Internal::staticcall(this).GetCachedSize(), target, stream);
  }

  // .clojureRT.protobuf.StaticFieldNode staticField = 37;
  if (_internal_has_staticfield()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(37, _Internal::staticfield(this),
        _Internal::staticfield(this).GetCachedSize(), target, stream);
  }

  // .clojureRT.protobuf.TheVarNode theVar = 38;
  if (_internal_has_thevar()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(38, _Internal::thevar(this),
        _Internal::thevar(this).GetCachedSize(), target, stream);
  }

  // .clojureRT.protobuf.ThrowNode throw = 39;
  if (_internal_has_throw_()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(39, _Internal::throw_(this),
        _Internal::throw_(this).GetCachedSize(), target, stream);
  }

  // .clojureRT.protobuf.TryNode try = 40;
  if (_internal_has_try_()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(40, _Internal::try_(this),
        _Internal::try_(this).GetCachedSize(), target, stream);
  }

  // .clojureRT.protobuf.VarNode var = 41;
  if (_internal_has_var()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(41, _Internal::var(this),
        _Internal::var(this).GetCachedSize(), target, stream);
  }

  // .clojureRT.protobuf.VectorNode vector = 42;
  if (_internal_has_vector()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(42, _Internal::vector(this),
        _Internal::vector(this).GetCachedSize(), target, stream);
  }

  // .clojureRT.protobuf.WithMetaNode withMeta = 43;
  if (_internal_has_withmeta()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(43, _Internal::withmeta(this),
        _Internal::withmeta(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojureRT.protobuf.Subnode)
  return target;
}

size_t Subnode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojureRT.protobuf.Subnode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (types_case()) {
    // .clojureRT.protobuf.BindingNode binding = 1;
    case kBinding: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.binding_);
      break;
    }
    // .clojureRT.protobuf.CaseNode case = 2;
    case kCase: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.case__);
      break;
    }
    // .clojureRT.protobuf.CaseTestNode caseTest = 3;
    case kCaseTest: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.casetest_);
      break;
    }
    // .clojureRT.protobuf.CaseThenNode caseThen = 4;
    case kCaseThen: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.casethen_);
      break;
    }
    // .clojureRT.protobuf.CatchNode catch = 5;
    case kCatch: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.catch__);
      break;
    }
    // .clojureRT.protobuf.ConstNode const = 6;
    case kConst: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.const__);
      break;
    }
    // .clojureRT.protobuf.DefNode def = 7;
    case kDef: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.def_);
      break;
    }
    // .clojureRT.protobuf.DeftypeNode deftype = 8;
    case kDeftype: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.deftype_);
      break;
    }
    // .clojureRT.protobuf.DoNode do = 9;
    case kDo: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.do__);
      break;
    }
    // .clojureRT.protobuf.FnNode fn = 10;
    case kFn: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.fn_);
      break;
    }
    // .clojureRT.protobuf.FnMethodNode fnMethod = 11;
    case kFnMethod: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.fnmethod_);
      break;
    }
    // .clojureRT.protobuf.HostInteropNode hostInterop = 12;
    case kHostInterop: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.hostinterop_);
      break;
    }
    // .clojureRT.protobuf.IfNode if = 13;
    case kIf: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.if__);
      break;
    }
    // .clojureRT.protobuf.ImportNode import = 14;
    case kImport: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.import_);
      break;
    }
    // .clojureRT.protobuf.InstanceCallNode instanceCall = 15;
    case kInstanceCall: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.instancecall_);
      break;
    }
    // .clojureRT.protobuf.InstanceFieldNode instanceField = 16;
    case kInstanceField: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.instancefield_);
      break;
    }
    // .clojureRT.protobuf.IsInstanceNode isInstance = 17;
    case kIsInstance: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.isinstance_);
      break;
    }
    // .clojureRT.protobuf.InvokeNode invoke = 18;
    case kInvoke: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.invoke_);
      break;
    }
    // .clojureRT.protobuf.KeywordInvokeNode keywordInvoke = 19;
    case kKeywordInvoke: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.keywordinvoke_);
      break;
    }
    // .clojureRT.protobuf.LetNode let = 20;
    case kLet: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.let_);
      break;
    }
    // .clojureRT.protobuf.LetfnNode letfn = 21;
    case kLetfn: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.letfn_);
      break;
    }
    // .clojureRT.protobuf.LocalNode local = 22;
    case kLocal: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.local_);
      break;
    }
    // .clojureRT.protobuf.LoopNode loop = 23;
    case kLoop: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.loop_);
      break;
    }
    // .clojureRT.protobuf.MapNode map = 24;
    case kMap: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.map_);
      break;
    }
    // .clojureRT.protobuf.MethodNode method = 25;
    case kMethod: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.method_);
      break;
    }
    // .clojureRT.protobuf.MonitorEnterNode monitorEnter = 26;
    case kMonitorEnter: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.monitorenter_);
      break;
    }
    // .clojureRT.protobuf.MonitorExitNode monitorExit = 27;
    case kMonitorExit: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.monitorexit_);
      break;
    }
    // .clojureRT.protobuf.NewNode new = 28;
    case kNew: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.new__);
      break;
    }
    // .clojureRT.protobuf.PrimInvokeNode primInvoke = 29;
    case kPrimInvoke: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.priminvoke_);
      break;
    }
    // .clojureRT.protobuf.ProtocolInvokeNode protocolInvoke = 30;
    case kProtocolInvoke: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.protocolinvoke_);
      break;
    }
    // .clojureRT.protobuf.QuoteNode quote = 31;
    case kQuote: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.quote_);
      break;
    }
    // .clojureRT.protobuf.RecurNode recur = 32;
    case kRecur: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.recur_);
      break;
    }
    // .clojureRT.protobuf.ReifyNode reify = 33;
    case kReify: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.reify_);
      break;
    }
    // .clojureRT.protobuf.SetNode set = 34;
    case kSet: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.set_);
      break;
    }
    // .clojureRT.protobuf.MutateSetNode mutateSet = 35;
    case kMutateSet: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.mutateset_);
      break;
    }
    // .clojureRT.protobuf.StaticCallNode staticCall = 36;
    case kStaticCall: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.staticcall_);
      break;
    }
    // .clojureRT.protobuf.StaticFieldNode staticField = 37;
    case kStaticField: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.staticfield_);
      break;
    }
    // .clojureRT.protobuf.TheVarNode theVar = 38;
    case kTheVar: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.thevar_);
      break;
    }
    // .clojureRT.protobuf.ThrowNode throw = 39;
    case kThrow: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.throw__);
      break;
    }
    // .clojureRT.protobuf.TryNode try = 40;
    case kTry: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.try__);
      break;
    }
    // .clojureRT.protobuf.VarNode var = 41;
    case kVar: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.var_);
      break;
    }
    // .clojureRT.protobuf.VectorNode vector = 42;
    case kVector: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.vector_);
      break;
    }
    // .clojureRT.protobuf.WithMetaNode withMeta = 43;
    case kWithMeta: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.withmeta_);
      break;
    }
    case TYPES_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Subnode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Subnode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Subnode::GetClassData() const { return &_class_data_; }


void Subnode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Subnode*>(&to_msg);
  auto& from = static_cast<const Subnode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojureRT.protobuf.Subnode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.types_case()) {
    case kBinding: {
      _this->_internal_mutable_binding()->::clojureRT::protobuf::BindingNode::MergeFrom(
          from._internal_binding());
      break;
    }
    case kCase: {
      _this->_internal_mutable_case_()->::clojureRT::protobuf::CaseNode::MergeFrom(
          from._internal_case_());
      break;
    }
    case kCaseTest: {
      _this->_internal_mutable_casetest()->::clojureRT::protobuf::CaseTestNode::MergeFrom(
          from._internal_casetest());
      break;
    }
    case kCaseThen: {
      _this->_internal_mutable_casethen()->::clojureRT::protobuf::CaseThenNode::MergeFrom(
          from._internal_casethen());
      break;
    }
    case kCatch: {
      _this->_internal_mutable_catch_()->::clojureRT::protobuf::CatchNode::MergeFrom(
          from._internal_catch_());
      break;
    }
    case kConst: {
      _this->_internal_mutable_const_()->::clojureRT::protobuf::ConstNode::MergeFrom(
          from._internal_const_());
      break;
    }
    case kDef: {
      _this->_internal_mutable_def()->::clojureRT::protobuf::DefNode::MergeFrom(
          from._internal_def());
      break;
    }
    case kDeftype: {
      _this->_internal_mutable_deftype()->::clojureRT::protobuf::DeftypeNode::MergeFrom(
          from._internal_deftype());
      break;
    }
    case kDo: {
      _this->_internal_mutable_do_()->::clojureRT::protobuf::DoNode::MergeFrom(
          from._internal_do_());
      break;
    }
    case kFn: {
      _this->_internal_mutable_fn()->::clojureRT::protobuf::FnNode::MergeFrom(
          from._internal_fn());
      break;
    }
    case kFnMethod: {
      _this->_internal_mutable_fnmethod()->::clojureRT::protobuf::FnMethodNode::MergeFrom(
          from._internal_fnmethod());
      break;
    }
    case kHostInterop: {
      _this->_internal_mutable_hostinterop()->::clojureRT::protobuf::HostInteropNode::MergeFrom(
          from._internal_hostinterop());
      break;
    }
    case kIf: {
      _this->_internal_mutable_if_()->::clojureRT::protobuf::IfNode::MergeFrom(
          from._internal_if_());
      break;
    }
    case kImport: {
      _this->_internal_mutable_import()->::clojureRT::protobuf::ImportNode::MergeFrom(
          from._internal_import());
      break;
    }
    case kInstanceCall: {
      _this->_internal_mutable_instancecall()->::clojureRT::protobuf::InstanceCallNode::MergeFrom(
          from._internal_instancecall());
      break;
    }
    case kInstanceField: {
      _this->_internal_mutable_instancefield()->::clojureRT::protobuf::InstanceFieldNode::MergeFrom(
          from._internal_instancefield());
      break;
    }
    case kIsInstance: {
      _this->_internal_mutable_isinstance()->::clojureRT::protobuf::IsInstanceNode::MergeFrom(
          from._internal_isinstance());
      break;
    }
    case kInvoke: {
      _this->_internal_mutable_invoke()->::clojureRT::protobuf::InvokeNode::MergeFrom(
          from._internal_invoke());
      break;
    }
    case kKeywordInvoke: {
      _this->_internal_mutable_keywordinvoke()->::clojureRT::protobuf::KeywordInvokeNode::MergeFrom(
          from._internal_keywordinvoke());
      break;
    }
    case kLet: {
      _this->_internal_mutable_let()->::clojureRT::protobuf::LetNode::MergeFrom(
          from._internal_let());
      break;
    }
    case kLetfn: {
      _this->_internal_mutable_letfn()->::clojureRT::protobuf::LetfnNode::MergeFrom(
          from._internal_letfn());
      break;
    }
    case kLocal: {
      _this->_internal_mutable_local()->::clojureRT::protobuf::LocalNode::MergeFrom(
          from._internal_local());
      break;
    }
    case kLoop: {
      _this->_internal_mutable_loop()->::clojureRT::protobuf::LoopNode::MergeFrom(
          from._internal_loop());
      break;
    }
    case kMap: {
      _this->_internal_mutable_map()->::clojureRT::protobuf::MapNode::MergeFrom(
          from._internal_map());
      break;
    }
    case kMethod: {
      _this->_internal_mutable_method()->::clojureRT::protobuf::MethodNode::MergeFrom(
          from._internal_method());
      break;
    }
    case kMonitorEnter: {
      _this->_internal_mutable_monitorenter()->::clojureRT::protobuf::MonitorEnterNode::MergeFrom(
          from._internal_monitorenter());
      break;
    }
    case kMonitorExit: {
      _this->_internal_mutable_monitorexit()->::clojureRT::protobuf::MonitorExitNode::MergeFrom(
          from._internal_monitorexit());
      break;
    }
    case kNew: {
      _this->_internal_mutable_new_()->::clojureRT::protobuf::NewNode::MergeFrom(
          from._internal_new_());
      break;
    }
    case kPrimInvoke: {
      _this->_internal_mutable_priminvoke()->::clojureRT::protobuf::PrimInvokeNode::MergeFrom(
          from._internal_priminvoke());
      break;
    }
    case kProtocolInvoke: {
      _this->_internal_mutable_protocolinvoke()->::clojureRT::protobuf::ProtocolInvokeNode::MergeFrom(
          from._internal_protocolinvoke());
      break;
    }
    case kQuote: {
      _this->_internal_mutable_quote()->::clojureRT::protobuf::QuoteNode::MergeFrom(
          from._internal_quote());
      break;
    }
    case kRecur: {
      _this->_internal_mutable_recur()->::clojureRT::protobuf::RecurNode::MergeFrom(
          from._internal_recur());
      break;
    }
    case kReify: {
      _this->_internal_mutable_reify()->::clojureRT::protobuf::ReifyNode::MergeFrom(
          from._internal_reify());
      break;
    }
    case kSet: {
      _this->_internal_mutable_set()->::clojureRT::protobuf::SetNode::MergeFrom(
          from._internal_set());
      break;
    }
    case kMutateSet: {
      _this->_internal_mutable_mutateset()->::clojureRT::protobuf::MutateSetNode::MergeFrom(
          from._internal_mutateset());
      break;
    }
    case kStaticCall: {
      _this->_internal_mutable_staticcall()->::clojureRT::protobuf::StaticCallNode::MergeFrom(
          from._internal_staticcall());
      break;
    }
    case kStaticField: {
      _this->_internal_mutable_staticfield()->::clojureRT::protobuf::StaticFieldNode::MergeFrom(
          from._internal_staticfield());
      break;
    }
    case kTheVar: {
      _this->_internal_mutable_thevar()->::clojureRT::protobuf::TheVarNode::MergeFrom(
          from._internal_thevar());
      break;
    }
    case kThrow: {
      _this->_internal_mutable_throw_()->::clojureRT::protobuf::ThrowNode::MergeFrom(
          from._internal_throw_());
      break;
    }
    case kTry: {
      _this->_internal_mutable_try_()->::clojureRT::protobuf::TryNode::MergeFrom(
          from._internal_try_());
      break;
    }
    case kVar: {
      _this->_internal_mutable_var()->::clojureRT::protobuf::VarNode::MergeFrom(
          from._internal_var());
      break;
    }
    case kVector: {
      _this->_internal_mutable_vector()->::clojureRT::protobuf::VectorNode::MergeFrom(
          from._internal_vector());
      break;
    }
    case kWithMeta: {
      _this->_internal_mutable_withmeta()->::clojureRT::protobuf::WithMetaNode::MergeFrom(
          from._internal_withmeta());
      break;
    }
    case TYPES_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Subnode::CopyFrom(const Subnode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojureRT.protobuf.Subnode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Subnode::IsInitialized() const {
  return true;
}

void Subnode::InternalSwap(Subnode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.types_, other->_impl_.types_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Subnode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[0]);
}

// ===================================================================

class BindingNode::_Internal {
 public:
  using HasBits = decltype(std::declval<BindingNode>()._impl_._has_bits_);
  static void set_has_argid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::clojureRT::protobuf::Node& init(const BindingNode* msg);
  static void set_has_init(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_isvariadic(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::clojureRT::protobuf::Node&
BindingNode::_Internal::init(const BindingNode* msg) {
  return *msg->_impl_.init_;
}
BindingNode::BindingNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojureRT.protobuf.BindingNode)
}
BindingNode::BindingNode(const BindingNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BindingNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.init_){nullptr}
    , decltype(_impl_.argid_){}
    , decltype(_impl_.local_){}
    , decltype(_impl_.isvariadic_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_init()) {
    _this->_impl_.init_ = new ::clojureRT::protobuf::Node(*from._impl_.init_);
  }
  ::memcpy(&_impl_.argid_, &from._impl_.argid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.isvariadic_) -
    reinterpret_cast<char*>(&_impl_.argid_)) + sizeof(_impl_.isvariadic_));
  // @@protoc_insertion_point(copy_constructor:clojureRT.protobuf.BindingNode)
}

inline void BindingNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.init_){nullptr}
    , decltype(_impl_.argid_){0u}
    , decltype(_impl_.local_){0}
    , decltype(_impl_.isvariadic_){false}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

BindingNode::~BindingNode() {
  // @@protoc_insertion_point(destructor:clojureRT.protobuf.BindingNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BindingNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.init_;
}

void BindingNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BindingNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojureRT.protobuf.BindingNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.init_ != nullptr);
    _impl_.init_->Clear();
  }
  _impl_.argid_ = 0u;
  _impl_.local_ = 0;
  _impl_.isvariadic_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BindingNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 argId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_argid(&has_bits);
          _impl_.argid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .clojureRT.protobuf.Node init = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_init(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.LocalType local = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_local(static_cast<::clojureRT::protobuf::LocalType>(val));
        } else
          goto handle_unusual;
        continue;
      // string name = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojureRT.protobuf.BindingNode.name"));
        } else
          goto handle_unusual;
        continue;
      // optional bool isVariadic = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_isvariadic(&has_bits);
          _impl_.isvariadic_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BindingNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojureRT.protobuf.BindingNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional uint32 argId = 1;
  if (_internal_has_argid()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_argid(), target);
  }

  // optional .clojureRT.protobuf.Node init = 2;
  if (_internal_has_init()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::init(this),
        _Internal::init(this).GetCachedSize(), target, stream);
  }

  // .clojureRT.protobuf.LocalType local = 3;
  if (this->_internal_local() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_local(), target);
  }

  // string name = 4;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojureRT.protobuf.BindingNode.name");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_name(), target);
  }

  // optional bool isVariadic = 5;
  if (_internal_has_isvariadic()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_isvariadic(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojureRT.protobuf.BindingNode)
  return target;
}

size_t BindingNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojureRT.protobuf.BindingNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 4;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .clojureRT.protobuf.Node init = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.init_);
    }

    // optional uint32 argId = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_argid());
    }

  }
  // .clojureRT.protobuf.LocalType local = 3;
  if (this->_internal_local() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_local());
  }

  // optional bool isVariadic = 5;
  if (cached_has_bits & 0x00000004u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BindingNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BindingNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BindingNode::GetClassData() const { return &_class_data_; }


void BindingNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BindingNode*>(&to_msg);
  auto& from = static_cast<const BindingNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojureRT.protobuf.BindingNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_init()->::clojureRT::protobuf::Node::MergeFrom(
          from._internal_init());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.argid_ = from._impl_.argid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (from._internal_local() != 0) {
    _this->_internal_set_local(from._internal_local());
  }
  if (cached_has_bits & 0x00000004u) {
    _this->_internal_set_isvariadic(from._internal_isvariadic());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BindingNode::CopyFrom(const BindingNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojureRT.protobuf.BindingNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BindingNode::IsInitialized() const {
  return true;
}

void BindingNode::InternalSwap(BindingNode* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BindingNode, _impl_.isvariadic_)
      + sizeof(BindingNode::_impl_.isvariadic_)
      - PROTOBUF_FIELD_OFFSET(BindingNode, _impl_.init_)>(
          reinterpret_cast<char*>(&_impl_.init_),
          reinterpret_cast<char*>(&other->_impl_.init_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BindingNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[1]);
}

// ===================================================================

class CaseNode::_Internal {
 public:
  static const ::clojureRT::protobuf::Node& default_(const CaseNode* msg);
  static const ::clojureRT::protobuf::Node& test(const CaseNode* msg);
};

const ::clojureRT::protobuf::Node&
CaseNode::_Internal::default_(const CaseNode* msg) {
  return *msg->_impl_.default__;
}
const ::clojureRT::protobuf::Node&
CaseNode::_Internal::test(const CaseNode* msg) {
  return *msg->_impl_.test_;
}
CaseNode::CaseNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojureRT.protobuf.CaseNode)
}
CaseNode::CaseNode(const CaseNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CaseNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.tests_){from._impl_.tests_}
    , decltype(_impl_.thens_){from._impl_.thens_}
    , decltype(_impl_.high_){}
    , decltype(_impl_.low_){}
    , decltype(_impl_.isskipcheck_){}
    , decltype(_impl_.default__){nullptr}
    , decltype(_impl_.test_){nullptr}
    , decltype(_impl_.mask_){}
    , decltype(_impl_.shift_){}
    , decltype(_impl_.switchtype_){}
    , decltype(_impl_.testtype_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.high_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.high_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_high().empty()) {
    _this->_impl_.high_.Set(from._internal_high(), 
      _this->GetArenaForAllocation());
  }
  _impl_.low_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.low_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_low().empty()) {
    _this->_impl_.low_.Set(from._internal_low(), 
      _this->GetArenaForAllocation());
  }
  _impl_.isskipcheck_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.isskipcheck_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_isskipcheck().empty()) {
    _this->_impl_.isskipcheck_.Set(from._internal_isskipcheck(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_default_()) {
    _this->_impl_.default__ = new ::clojureRT::protobuf::Node(*from._impl_.default__);
  }
  if (from._internal_has_test()) {
    _this->_impl_.test_ = new ::clojureRT::protobuf::Node(*from._impl_.test_);
  }
  ::memcpy(&_impl_.mask_, &from._impl_.mask_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.testtype_) -
    reinterpret_cast<char*>(&_impl_.mask_)) + sizeof(_impl_.testtype_));
  // @@protoc_insertion_point(copy_constructor:clojureRT.protobuf.CaseNode)
}

inline void CaseNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.tests_){arena}
    , decltype(_impl_.thens_){arena}
    , decltype(_impl_.high_){}
    , decltype(_impl_.low_){}
    , decltype(_impl_.isskipcheck_){}
    , decltype(_impl_.default__){nullptr}
    , decltype(_impl_.test_){nullptr}
    , decltype(_impl_.mask_){0u}
    , decltype(_impl_.shift_){0u}
    , decltype(_impl_.switchtype_){0}
    , decltype(_impl_.testtype_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.high_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.high_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.low_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.low_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.isskipcheck_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.isskipcheck_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CaseNode::~CaseNode() {
  // @@protoc_insertion_point(destructor:clojureRT.protobuf.CaseNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CaseNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.tests_.~RepeatedPtrField();
  _impl_.thens_.~RepeatedPtrField();
  _impl_.high_.Destroy();
  _impl_.low_.Destroy();
  _impl_.isskipcheck_.Destroy();
  if (this != internal_default_instance()) delete _impl_.default__;
  if (this != internal_default_instance()) delete _impl_.test_;
}

void CaseNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CaseNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojureRT.protobuf.CaseNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.tests_.Clear();
  _impl_.thens_.Clear();
  _impl_.high_.ClearToEmpty();
  _impl_.low_.ClearToEmpty();
  _impl_.isskipcheck_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.default__ != nullptr) {
    delete _impl_.default__;
  }
  _impl_.default__ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.test_ != nullptr) {
    delete _impl_.test_;
  }
  _impl_.test_ = nullptr;
  ::memset(&_impl_.mask_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.testtype_) -
      reinterpret_cast<char*>(&_impl_.mask_)) + sizeof(_impl_.testtype_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CaseNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .clojureRT.protobuf.Node default = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_default_(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string high = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_high();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojureRT.protobuf.CaseNode.high"));
        } else
          goto handle_unusual;
        continue;
      // string low = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_low();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojureRT.protobuf.CaseNode.low"));
        } else
          goto handle_unusual;
        continue;
      // uint32 mask = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.mask_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 shift = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.shift_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string isSkipCheck = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_isskipcheck();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojureRT.protobuf.CaseNode.isSkipCheck"));
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.CaseNode.SwitchType switchType = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_switchtype(static_cast<::clojureRT::protobuf::CaseNode_SwitchType>(val));
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.Node test = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_test(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.CaseNode.TestType testType = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_testtype(static_cast<::clojureRT::protobuf::CaseNode_TestType>(val));
        } else
          goto handle_unusual;
        continue;
      // repeated .clojureRT.protobuf.Node tests = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_tests(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .clojureRT.protobuf.Node thens = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_thens(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CaseNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojureRT.protobuf.CaseNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .clojureRT.protobuf.Node default = 1;
  if (this->_internal_has_default_()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::default_(this),
        _Internal::default_(this).GetCachedSize(), target, stream);
  }

  // string high = 2;
  if (!this->_internal_high().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_high().data(), static_cast<int>(this->_internal_high().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojureRT.protobuf.CaseNode.high");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_high(), target);
  }

  // string low = 3;
  if (!this->_internal_low().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_low().data(), static_cast<int>(this->_internal_low().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojureRT.protobuf.CaseNode.low");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_low(), target);
  }

  // uint32 mask = 4;
  if (this->_internal_mask() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_mask(), target);
  }

  // uint32 shift = 5;
  if (this->_internal_shift() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_shift(), target);
  }

  // string isSkipCheck = 6;
  if (!this->_internal_isskipcheck().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_isskipcheck().data(), static_cast<int>(this->_internal_isskipcheck().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojureRT.protobuf.CaseNode.isSkipCheck");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_isskipcheck(), target);
  }

  // .clojureRT.protobuf.CaseNode.SwitchType switchType = 7;
  if (this->_internal_switchtype() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      7, this->_internal_switchtype(), target);
  }

  // .clojureRT.protobuf.Node test = 8;
  if (this->_internal_has_test()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::test(this),
        _Internal::test(this).GetCachedSize(), target, stream);
  }

  // .clojureRT.protobuf.CaseNode.TestType testType = 9;
  if (this->_internal_testtype() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      9, this->_internal_testtype(), target);
  }

  // repeated .clojureRT.protobuf.Node tests = 10;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_tests_size()); i < n; i++) {
    const auto& repfield = this->_internal_tests(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(10, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .clojureRT.protobuf.Node thens = 11;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_thens_size()); i < n; i++) {
    const auto& repfield = this->_internal_thens(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(11, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojureRT.protobuf.CaseNode)
  return target;
}

size_t CaseNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojureRT.protobuf.CaseNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .clojureRT.protobuf.Node tests = 10;
  total_size += 1UL * this->_internal_tests_size();
  for (const auto& msg : this->_impl_.tests_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .clojureRT.protobuf.Node thens = 11;
  total_size += 1UL * this->_internal_thens_size();
  for (const auto& msg : this->_impl_.thens_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string high = 2;
  if (!this->_internal_high().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_high());
  }

  // string low = 3;
  if (!this->_internal_low().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_low());
  }

  // string isSkipCheck = 6;
  if (!this->_internal_isskipcheck().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_isskipcheck());
  }

  // .clojureRT.protobuf.Node default = 1;
  if (this->_internal_has_default_()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.default__);
  }

  // .clojureRT.protobuf.Node test = 8;
  if (this->_internal_has_test()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.test_);
  }

  // uint32 mask = 4;
  if (this->_internal_mask() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_mask());
  }

  // uint32 shift = 5;
  if (this->_internal_shift() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_shift());
  }

  // .clojureRT.protobuf.CaseNode.SwitchType switchType = 7;
  if (this->_internal_switchtype() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_switchtype());
  }

  // .clojureRT.protobuf.CaseNode.TestType testType = 9;
  if (this->_internal_testtype() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_testtype());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CaseNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CaseNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CaseNode::GetClassData() const { return &_class_data_; }


void CaseNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CaseNode*>(&to_msg);
  auto& from = static_cast<const CaseNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojureRT.protobuf.CaseNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.tests_.MergeFrom(from._impl_.tests_);
  _this->_impl_.thens_.MergeFrom(from._impl_.thens_);
  if (!from._internal_high().empty()) {
    _this->_internal_set_high(from._internal_high());
  }
  if (!from._internal_low().empty()) {
    _this->_internal_set_low(from._internal_low());
  }
  if (!from._internal_isskipcheck().empty()) {
    _this->_internal_set_isskipcheck(from._internal_isskipcheck());
  }
  if (from._internal_has_default_()) {
    _this->_internal_mutable_default_()->::clojureRT::protobuf::Node::MergeFrom(
        from._internal_default_());
  }
  if (from._internal_has_test()) {
    _this->_internal_mutable_test()->::clojureRT::protobuf::Node::MergeFrom(
        from._internal_test());
  }
  if (from._internal_mask() != 0) {
    _this->_internal_set_mask(from._internal_mask());
  }
  if (from._internal_shift() != 0) {
    _this->_internal_set_shift(from._internal_shift());
  }
  if (from._internal_switchtype() != 0) {
    _this->_internal_set_switchtype(from._internal_switchtype());
  }
  if (from._internal_testtype() != 0) {
    _this->_internal_set_testtype(from._internal_testtype());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CaseNode::CopyFrom(const CaseNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojureRT.protobuf.CaseNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CaseNode::IsInitialized() const {
  return true;
}

void CaseNode::InternalSwap(CaseNode* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.tests_.InternalSwap(&other->_impl_.tests_);
  _impl_.thens_.InternalSwap(&other->_impl_.thens_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.high_, lhs_arena,
      &other->_impl_.high_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.low_, lhs_arena,
      &other->_impl_.low_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.isskipcheck_, lhs_arena,
      &other->_impl_.isskipcheck_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CaseNode, _impl_.testtype_)
      + sizeof(CaseNode::_impl_.testtype_)
      - PROTOBUF_FIELD_OFFSET(CaseNode, _impl_.default__)>(
          reinterpret_cast<char*>(&_impl_.default__),
          reinterpret_cast<char*>(&other->_impl_.default__));
}

::PROTOBUF_NAMESPACE_ID::Metadata CaseNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[2]);
}

// ===================================================================

class CaseTestNode::_Internal {
 public:
  static const ::clojureRT::protobuf::Node& test(const CaseTestNode* msg);
};

const ::clojureRT::protobuf::Node&
CaseTestNode::_Internal::test(const CaseTestNode* msg) {
  return *msg->_impl_.test_;
}
CaseTestNode::CaseTestNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojureRT.protobuf.CaseTestNode)
}
CaseTestNode::CaseTestNode(const CaseTestNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CaseTestNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.test_){nullptr}
    , decltype(_impl_.hash_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_test()) {
    _this->_impl_.test_ = new ::clojureRT::protobuf::Node(*from._impl_.test_);
  }
  _this->_impl_.hash_ = from._impl_.hash_;
  // @@protoc_insertion_point(copy_constructor:clojureRT.protobuf.CaseTestNode)
}

inline void CaseTestNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.test_){nullptr}
    , decltype(_impl_.hash_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CaseTestNode::~CaseTestNode() {
  // @@protoc_insertion_point(destructor:clojureRT.protobuf.CaseTestNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CaseTestNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.test_;
}

void CaseTestNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CaseTestNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojureRT.protobuf.CaseTestNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.test_ != nullptr) {
    delete _impl_.test_;
  }
  _impl_.test_ = nullptr;
  _impl_.hash_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CaseTestNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 hash = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.hash_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.Node test = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_test(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CaseTestNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojureRT.protobuf.CaseTestNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 hash = 1;
  if (this->_internal_hash() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_hash(), target);
  }

  // .clojureRT.protobuf.Node test = 2;
  if (this->_internal_has_test()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::test(this),
        _Internal::test(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojureRT.protobuf.CaseTestNode)
  return target;
}

size_t CaseTestNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojureRT.protobuf.CaseTestNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .clojureRT.protobuf.Node test = 2;
  if (this->_internal_has_test()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.test_);
  }

  // uint32 hash = 1;
  if (this->_internal_hash() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_hash());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CaseTestNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CaseTestNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CaseTestNode::GetClassData() const { return &_class_data_; }


void CaseTestNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CaseTestNode*>(&to_msg);
  auto& from = static_cast<const CaseTestNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojureRT.protobuf.CaseTestNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_test()) {
    _this->_internal_mutable_test()->::clojureRT::protobuf::Node::MergeFrom(
        from._internal_test());
  }
  if (from._internal_hash() != 0) {
    _this->_internal_set_hash(from._internal_hash());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CaseTestNode::CopyFrom(const CaseTestNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojureRT.protobuf.CaseTestNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CaseTestNode::IsInitialized() const {
  return true;
}

void CaseTestNode::InternalSwap(CaseTestNode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CaseTestNode, _impl_.hash_)
      + sizeof(CaseTestNode::_impl_.hash_)
      - PROTOBUF_FIELD_OFFSET(CaseTestNode, _impl_.test_)>(
          reinterpret_cast<char*>(&_impl_.test_),
          reinterpret_cast<char*>(&other->_impl_.test_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CaseTestNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[3]);
}

// ===================================================================

class CaseThenNode::_Internal {
 public:
  static const ::clojureRT::protobuf::Node& then(const CaseThenNode* msg);
};

const ::clojureRT::protobuf::Node&
CaseThenNode::_Internal::then(const CaseThenNode* msg) {
  return *msg->_impl_.then_;
}
CaseThenNode::CaseThenNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojureRT.protobuf.CaseThenNode)
}
CaseThenNode::CaseThenNode(const CaseThenNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CaseThenNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.then_){nullptr}
    , decltype(_impl_.hash_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_then()) {
    _this->_impl_.then_ = new ::clojureRT::protobuf::Node(*from._impl_.then_);
  }
  _this->_impl_.hash_ = from._impl_.hash_;
  // @@protoc_insertion_point(copy_constructor:clojureRT.protobuf.CaseThenNode)
}

inline void CaseThenNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.then_){nullptr}
    , decltype(_impl_.hash_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CaseThenNode::~CaseThenNode() {
  // @@protoc_insertion_point(destructor:clojureRT.protobuf.CaseThenNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CaseThenNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.then_;
}

void CaseThenNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CaseThenNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojureRT.protobuf.CaseThenNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.then_ != nullptr) {
    delete _impl_.then_;
  }
  _impl_.then_ = nullptr;
  _impl_.hash_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CaseThenNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 hash = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.hash_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.Node then = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_then(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CaseThenNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojureRT.protobuf.CaseThenNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 hash = 1;
  if (this->_internal_hash() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_hash(), target);
  }

  // .clojureRT.protobuf.Node then = 2;
  if (this->_internal_has_then()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::then(this),
        _Internal::then(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojureRT.protobuf.CaseThenNode)
  return target;
}

size_t CaseThenNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojureRT.protobuf.CaseThenNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .clojureRT.protobuf.Node then = 2;
  if (this->_internal_has_then()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.then_);
  }

  // uint32 hash = 1;
  if (this->_internal_hash() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_hash());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CaseThenNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CaseThenNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CaseThenNode::GetClassData() const { return &_class_data_; }


void CaseThenNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CaseThenNode*>(&to_msg);
  auto& from = static_cast<const CaseThenNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojureRT.protobuf.CaseThenNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_then()) {
    _this->_internal_mutable_then()->::clojureRT::protobuf::Node::MergeFrom(
        from._internal_then());
  }
  if (from._internal_hash() != 0) {
    _this->_internal_set_hash(from._internal_hash());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CaseThenNode::CopyFrom(const CaseThenNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojureRT.protobuf.CaseThenNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CaseThenNode::IsInitialized() const {
  return true;
}

void CaseThenNode::InternalSwap(CaseThenNode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CaseThenNode, _impl_.hash_)
      + sizeof(CaseThenNode::_impl_.hash_)
      - PROTOBUF_FIELD_OFFSET(CaseThenNode, _impl_.then_)>(
          reinterpret_cast<char*>(&_impl_.then_),
          reinterpret_cast<char*>(&other->_impl_.then_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CaseThenNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[4]);
}

// ===================================================================

class CatchNode::_Internal {
 public:
  static const ::clojureRT::protobuf::Node& body(const CatchNode* msg);
  static const ::clojureRT::protobuf::Node& class_(const CatchNode* msg);
  static const ::clojureRT::protobuf::Node& local(const CatchNode* msg);
};

const ::clojureRT::protobuf::Node&
CatchNode::_Internal::body(const CatchNode* msg) {
  return *msg->_impl_.body_;
}
const ::clojureRT::protobuf::Node&
CatchNode::_Internal::class_(const CatchNode* msg) {
  return *msg->_impl_.class__;
}
const ::clojureRT::protobuf::Node&
CatchNode::_Internal::local(const CatchNode* msg) {
  return *msg->_impl_.local_;
}
CatchNode::CatchNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojureRT.protobuf.CatchNode)
}
CatchNode::CatchNode(const CatchNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CatchNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.body_){nullptr}
    , decltype(_impl_.class__){nullptr}
    , decltype(_impl_.local_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_body()) {
    _this->_impl_.body_ = new ::clojureRT::protobuf::Node(*from._impl_.body_);
  }
  if (from._internal_has_class_()) {
    _this->_impl_.class__ = new ::clojureRT::protobuf::Node(*from._impl_.class__);
  }
  if (from._internal_has_local()) {
    _this->_impl_.local_ = new ::clojureRT::protobuf::Node(*from._impl_.local_);
  }
  // @@protoc_insertion_point(copy_constructor:clojureRT.protobuf.CatchNode)
}

inline void CatchNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.body_){nullptr}
    , decltype(_impl_.class__){nullptr}
    , decltype(_impl_.local_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CatchNode::~CatchNode() {
  // @@protoc_insertion_point(destructor:clojureRT.protobuf.CatchNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CatchNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.body_;
  if (this != internal_default_instance()) delete _impl_.class__;
  if (this != internal_default_instance()) delete _impl_.local_;
}

void CatchNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CatchNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojureRT.protobuf.CatchNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.body_ != nullptr) {
    delete _impl_.body_;
  }
  _impl_.body_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.class__ != nullptr) {
    delete _impl_.class__;
  }
  _impl_.class__ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.local_ != nullptr) {
    delete _impl_.local_;
  }
  _impl_.local_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CatchNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .clojureRT.protobuf.Node body = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_body(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.Node class = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_class_(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.Node local = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_local(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CatchNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojureRT.protobuf.CatchNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .clojureRT.protobuf.Node body = 1;
  if (this->_internal_has_body()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::body(this),
        _Internal::body(this).GetCachedSize(), target, stream);
  }

  // .clojureRT.protobuf.Node class = 2;
  if (this->_internal_has_class_()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::class_(this),
        _Internal::class_(this).GetCachedSize(), target, stream);
  }

  // .clojureRT.protobuf.Node local = 3;
  if (this->_internal_has_local()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::local(this),
        _Internal::local(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojureRT.protobuf.CatchNode)
  return target;
}

size_t CatchNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojureRT.protobuf.CatchNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .clojureRT.protobuf.Node body = 1;
  if (this->_internal_has_body()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.body_);
  }

  // .clojureRT.protobuf.Node class = 2;
  if (this->_internal_has_class_()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.class__);
  }

  // .clojureRT.protobuf.Node local = 3;
  if (this->_internal_has_local()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.local_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CatchNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CatchNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CatchNode::GetClassData() const { return &_class_data_; }


void CatchNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CatchNode*>(&to_msg);
  auto& from = static_cast<const CatchNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojureRT.protobuf.CatchNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_body()) {
    _this->_internal_mutable_body()->::clojureRT::protobuf::Node::MergeFrom(
        from._internal_body());
  }
  if (from._internal_has_class_()) {
    _this->_internal_mutable_class_()->::clojureRT::protobuf::Node::MergeFrom(
        from._internal_class_());
  }
  if (from._internal_has_local()) {
    _this->_internal_mutable_local()->::clojureRT::protobuf::Node::MergeFrom(
        from._internal_local());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CatchNode::CopyFrom(const CatchNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojureRT.protobuf.CatchNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CatchNode::IsInitialized() const {
  return true;
}

void CatchNode::InternalSwap(CatchNode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CatchNode, _impl_.local_)
      + sizeof(CatchNode::_impl_.local_)
      - PROTOBUF_FIELD_OFFSET(CatchNode, _impl_.body_)>(
          reinterpret_cast<char*>(&_impl_.body_),
          reinterpret_cast<char*>(&other->_impl_.body_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CatchNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[5]);
}

// ===================================================================

class ConstNode::_Internal {
 public:
  using HasBits = decltype(std::declval<ConstNode>()._impl_._has_bits_);
  static const ::clojureRT::protobuf::Node& meta(const ConstNode* msg);
  static void set_has_meta(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::clojureRT::protobuf::Node&
ConstNode::_Internal::meta(const ConstNode* msg) {
  return *msg->_impl_.meta_;
}
ConstNode::ConstNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojureRT.protobuf.ConstNode)
}
ConstNode::ConstNode(const ConstNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ConstNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.val_){}
    , decltype(_impl_.meta_){nullptr}
    , decltype(_impl_.isliteral_){}
    , decltype(_impl_.type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.val_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.val_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_val().empty()) {
    _this->_impl_.val_.Set(from._internal_val(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_meta()) {
    _this->_impl_.meta_ = new ::clojureRT::protobuf::Node(*from._impl_.meta_);
  }
  ::memcpy(&_impl_.isliteral_, &from._impl_.isliteral_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.type_) -
    reinterpret_cast<char*>(&_impl_.isliteral_)) + sizeof(_impl_.type_));
  // @@protoc_insertion_point(copy_constructor:clojureRT.protobuf.ConstNode)
}

inline void ConstNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.val_){}
    , decltype(_impl_.meta_){nullptr}
    , decltype(_impl_.isliteral_){false}
    , decltype(_impl_.type_){0}
  };
  _impl_.val_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.val_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ConstNode::~ConstNode() {
  // @@protoc_insertion_point(destructor:clojureRT.protobuf.ConstNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ConstNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.val_.Destroy();
  if (this != internal_default_instance()) delete _impl_.meta_;
}

void ConstNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ConstNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojureRT.protobuf.ConstNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.val_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.meta_ != nullptr);
    _impl_.meta_->Clear();
  }
  ::memset(&_impl_.isliteral_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.type_) -
      reinterpret_cast<char*>(&_impl_.isliteral_)) + sizeof(_impl_.type_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ConstNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool isLiteral = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.isliteral_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .clojureRT.protobuf.Node meta = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_meta(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.ConstNode.ConstType type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::clojureRT::protobuf::ConstNode_ConstType>(val));
        } else
          goto handle_unusual;
        continue;
      // string val = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_val();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojureRT.protobuf.ConstNode.val"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ConstNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojureRT.protobuf.ConstNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool isLiteral = 1;
  if (this->_internal_isliteral() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_isliteral(), target);
  }

  // optional .clojureRT.protobuf.Node meta = 2;
  if (_internal_has_meta()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::meta(this),
        _Internal::meta(this).GetCachedSize(), target, stream);
  }

  // .clojureRT.protobuf.ConstNode.ConstType type = 3;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_type(), target);
  }

  // string val = 4;
  if (!this->_internal_val().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_val().data(), static_cast<int>(this->_internal_val().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojureRT.protobuf.ConstNode.val");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_val(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojureRT.protobuf.ConstNode)
  return target;
}

size_t ConstNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojureRT.protobuf.ConstNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string val = 4;
  if (!this->_internal_val().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_val());
  }

  // optional .clojureRT.protobuf.Node meta = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.meta_);
  }

  // bool isLiteral = 1;
  if (this->_internal_isliteral() != 0) {
    total_size += 1 + 1;
  }

  // .clojureRT.protobuf.ConstNode.ConstType type = 3;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ConstNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ConstNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ConstNode::GetClassData() const { return &_class_data_; }


void ConstNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ConstNode*>(&to_msg);
  auto& from = static_cast<const ConstNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojureRT.protobuf.ConstNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_val().empty()) {
    _this->_internal_set_val(from._internal_val());
  }
  if (from._internal_has_meta()) {
    _this->_internal_mutable_meta()->::clojureRT::protobuf::Node::MergeFrom(
        from._internal_meta());
  }
  if (from._internal_isliteral() != 0) {
    _this->_internal_set_isliteral(from._internal_isliteral());
  }
  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ConstNode::CopyFrom(const ConstNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojureRT.protobuf.ConstNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConstNode::IsInitialized() const {
  return true;
}

void ConstNode::InternalSwap(ConstNode* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.val_, lhs_arena,
      &other->_impl_.val_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ConstNode, _impl_.type_)
      + sizeof(ConstNode::_impl_.type_)
      - PROTOBUF_FIELD_OFFSET(ConstNode, _impl_.meta_)>(
          reinterpret_cast<char*>(&_impl_.meta_),
          reinterpret_cast<char*>(&other->_impl_.meta_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ConstNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[6]);
}

// ===================================================================

class DefNode::_Internal {
 public:
  using HasBits = decltype(std::declval<DefNode>()._impl_._has_bits_);
  static void set_has_doc(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::clojureRT::protobuf::Node& init(const DefNode* msg);
  static void set_has_init(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::clojureRT::protobuf::Node& meta(const DefNode* msg);
  static void set_has_meta(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::clojureRT::protobuf::Node&
DefNode::_Internal::init(const DefNode* msg) {
  return *msg->_impl_.init_;
}
const ::clojureRT::protobuf::Node&
DefNode::_Internal::meta(const DefNode* msg) {
  return *msg->_impl_.meta_;
}
DefNode::DefNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojureRT.protobuf.DefNode)
}
DefNode::DefNode(const DefNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DefNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.doc_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.var_){}
    , decltype(_impl_.init_){nullptr}
    , decltype(_impl_.meta_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.doc_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.doc_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_doc()) {
    _this->_impl_.doc_.Set(from._internal_doc(), 
      _this->GetArenaForAllocation());
  }
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.var_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.var_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_var().empty()) {
    _this->_impl_.var_.Set(from._internal_var(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_init()) {
    _this->_impl_.init_ = new ::clojureRT::protobuf::Node(*from._impl_.init_);
  }
  if (from._internal_has_meta()) {
    _this->_impl_.meta_ = new ::clojureRT::protobuf::Node(*from._impl_.meta_);
  }
  // @@protoc_insertion_point(copy_constructor:clojureRT.protobuf.DefNode)
}

inline void DefNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.doc_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.var_){}
    , decltype(_impl_.init_){nullptr}
    , decltype(_impl_.meta_){nullptr}
  };
  _impl_.doc_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.doc_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.var_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.var_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DefNode::~DefNode() {
  // @@protoc_insertion_point(destructor:clojureRT.protobuf.DefNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DefNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.doc_.Destroy();
  _impl_.name_.Destroy();
  _impl_.var_.Destroy();
  if (this != internal_default_instance()) delete _impl_.init_;
  if (this != internal_default_instance()) delete _impl_.meta_;
}

void DefNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DefNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojureRT.protobuf.DefNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.doc_.ClearNonDefaultToEmpty();
  }
  _impl_.name_.ClearToEmpty();
  _impl_.var_.ClearToEmpty();
  if (cached_has_bits & 0x00000006u) {
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.init_ != nullptr);
      _impl_.init_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.meta_ != nullptr);
      _impl_.meta_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DefNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string doc = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_doc();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojureRT.protobuf.DefNode.doc"));
        } else
          goto handle_unusual;
        continue;
      // optional .clojureRT.protobuf.Node init = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_init(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .clojureRT.protobuf.Node meta = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_meta(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string name = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojureRT.protobuf.DefNode.name"));
        } else
          goto handle_unusual;
        continue;
      // string var = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_var();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojureRT.protobuf.DefNode.var"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DefNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojureRT.protobuf.DefNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional string doc = 1;
  if (_internal_has_doc()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_doc().data(), static_cast<int>(this->_internal_doc().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojureRT.protobuf.DefNode.doc");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_doc(), target);
  }

  // optional .clojureRT.protobuf.Node init = 2;
  if (_internal_has_init()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::init(this),
        _Internal::init(this).GetCachedSize(), target, stream);
  }

  // optional .clojureRT.protobuf.Node meta = 3;
  if (_internal_has_meta()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::meta(this),
        _Internal::meta(this).GetCachedSize(), target, stream);
  }

  // string name = 4;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojureRT.protobuf.DefNode.name");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_name(), target);
  }

  // string var = 5;
  if (!this->_internal_var().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_var().data(), static_cast<int>(this->_internal_var().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojureRT.protobuf.DefNode.var");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_var(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojureRT.protobuf.DefNode)
  return target;
}

size_t DefNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojureRT.protobuf.DefNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string doc = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_doc());
  }

  // string name = 4;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string var = 5;
  if (!this->_internal_var().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_var());
  }

  if (cached_has_bits & 0x00000006u) {
    // optional .clojureRT.protobuf.Node init = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.init_);
    }

    // optional .clojureRT.protobuf.Node meta = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.meta_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DefNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DefNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DefNode::GetClassData() const { return &_class_data_; }


void DefNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DefNode*>(&to_msg);
  auto& from = static_cast<const DefNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojureRT.protobuf.DefNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_doc()) {
    _this->_internal_set_doc(from._internal_doc());
  }
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_var().empty()) {
    _this->_internal_set_var(from._internal_var());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_init()->::clojureRT::protobuf::Node::MergeFrom(
          from._internal_init());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_meta()->::clojureRT::protobuf::Node::MergeFrom(
          from._internal_meta());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DefNode::CopyFrom(const DefNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojureRT.protobuf.DefNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DefNode::IsInitialized() const {
  return true;
}

void DefNode::InternalSwap(DefNode* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.doc_, lhs_arena,
      &other->_impl_.doc_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.var_, lhs_arena,
      &other->_impl_.var_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DefNode, _impl_.meta_)
      + sizeof(DefNode::_impl_.meta_)
      - PROTOBUF_FIELD_OFFSET(DefNode, _impl_.init_)>(
          reinterpret_cast<char*>(&_impl_.init_),
          reinterpret_cast<char*>(&other->_impl_.init_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DefNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[7]);
}

// ===================================================================

class DeftypeNode::_Internal {
 public:
};

DeftypeNode::DeftypeNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojureRT.protobuf.DeftypeNode)
}
DeftypeNode::DeftypeNode(const DeftypeNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DeftypeNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.fields_){from._impl_.fields_}
    , decltype(_impl_.interfaces_){from._impl_.interfaces_}
    , decltype(_impl_.methods_){from._impl_.methods_}
    , decltype(_impl_.classname_){}
    , decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.classname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.classname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_classname().empty()) {
    _this->_impl_.classname_.Set(from._internal_classname(), 
      _this->GetArenaForAllocation());
  }
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:clojureRT.protobuf.DeftypeNode)
}

inline void DeftypeNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.fields_){arena}
    , decltype(_impl_.interfaces_){arena}
    , decltype(_impl_.methods_){arena}
    , decltype(_impl_.classname_){}
    , decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.classname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.classname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DeftypeNode::~DeftypeNode() {
  // @@protoc_insertion_point(destructor:clojureRT.protobuf.DeftypeNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeftypeNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.fields_.~RepeatedPtrField();
  _impl_.interfaces_.~RepeatedPtrField();
  _impl_.methods_.~RepeatedPtrField();
  _impl_.classname_.Destroy();
  _impl_.name_.Destroy();
}

void DeftypeNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeftypeNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojureRT.protobuf.DeftypeNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.fields_.Clear();
  _impl_.interfaces_.Clear();
  _impl_.methods_.Clear();
  _impl_.classname_.ClearToEmpty();
  _impl_.name_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DeftypeNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string className = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_classname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojureRT.protobuf.DeftypeNode.className"));
        } else
          goto handle_unusual;
        continue;
      // repeated .clojureRT.protobuf.Node fields = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_fields(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string interfaces = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_interfaces();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "clojureRT.protobuf.DeftypeNode.interfaces"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .clojureRT.protobuf.Node methods = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_methods(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string name = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojureRT.protobuf.DeftypeNode.name"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeftypeNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojureRT.protobuf.DeftypeNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string className = 1;
  if (!this->_internal_classname().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_classname().data(), static_cast<int>(this->_internal_classname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojureRT.protobuf.DeftypeNode.className");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_classname(), target);
  }

  // repeated .clojureRT.protobuf.Node fields = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_fields_size()); i < n; i++) {
    const auto& repfield = this->_internal_fields(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated string interfaces = 3;
  for (int i = 0, n = this->_internal_interfaces_size(); i < n; i++) {
    const auto& s = this->_internal_interfaces(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojureRT.protobuf.DeftypeNode.interfaces");
    target = stream->WriteString(3, s, target);
  }

  // repeated .clojureRT.protobuf.Node methods = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_methods_size()); i < n; i++) {
    const auto& repfield = this->_internal_methods(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // string name = 5;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojureRT.protobuf.DeftypeNode.name");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojureRT.protobuf.DeftypeNode)
  return target;
}

size_t DeftypeNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojureRT.protobuf.DeftypeNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .clojureRT.protobuf.Node fields = 2;
  total_size += 1UL * this->_internal_fields_size();
  for (const auto& msg : this->_impl_.fields_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated string interfaces = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.interfaces_.size());
  for (int i = 0, n = _impl_.interfaces_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.interfaces_.Get(i));
  }

  // repeated .clojureRT.protobuf.Node methods = 4;
  total_size += 1UL * this->_internal_methods_size();
  for (const auto& msg : this->_impl_.methods_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string className = 1;
  if (!this->_internal_classname().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_classname());
  }

  // string name = 5;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DeftypeNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DeftypeNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DeftypeNode::GetClassData() const { return &_class_data_; }


void DeftypeNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DeftypeNode*>(&to_msg);
  auto& from = static_cast<const DeftypeNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojureRT.protobuf.DeftypeNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.fields_.MergeFrom(from._impl_.fields_);
  _this->_impl_.interfaces_.MergeFrom(from._impl_.interfaces_);
  _this->_impl_.methods_.MergeFrom(from._impl_.methods_);
  if (!from._internal_classname().empty()) {
    _this->_internal_set_classname(from._internal_classname());
  }
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DeftypeNode::CopyFrom(const DeftypeNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojureRT.protobuf.DeftypeNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeftypeNode::IsInitialized() const {
  return true;
}

void DeftypeNode::InternalSwap(DeftypeNode* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.fields_.InternalSwap(&other->_impl_.fields_);
  _impl_.interfaces_.InternalSwap(&other->_impl_.interfaces_);
  _impl_.methods_.InternalSwap(&other->_impl_.methods_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.classname_, lhs_arena,
      &other->_impl_.classname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata DeftypeNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[8]);
}

// ===================================================================

class DoNode::_Internal {
 public:
  using HasBits = decltype(std::declval<DoNode>()._impl_._has_bits_);
  static void set_has_isbody(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::clojureRT::protobuf::Node& ret(const DoNode* msg);
};

const ::clojureRT::protobuf::Node&
DoNode::_Internal::ret(const DoNode* msg) {
  return *msg->_impl_.ret_;
}
DoNode::DoNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojureRT.protobuf.DoNode)
}
DoNode::DoNode(const DoNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DoNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.statements_){from._impl_.statements_}
    , decltype(_impl_.ret_){nullptr}
    , decltype(_impl_.isbody_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_ret()) {
    _this->_impl_.ret_ = new ::clojureRT::protobuf::Node(*from._impl_.ret_);
  }
  _this->_impl_.isbody_ = from._impl_.isbody_;
  // @@protoc_insertion_point(copy_constructor:clojureRT.protobuf.DoNode)
}

inline void DoNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.statements_){arena}
    , decltype(_impl_.ret_){nullptr}
    , decltype(_impl_.isbody_){false}
  };
}

DoNode::~DoNode() {
  // @@protoc_insertion_point(destructor:clojureRT.protobuf.DoNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DoNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.statements_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.ret_;
}

void DoNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DoNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojureRT.protobuf.DoNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.statements_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.ret_ != nullptr) {
    delete _impl_.ret_;
  }
  _impl_.ret_ = nullptr;
  _impl_.isbody_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DoNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool isBody = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_isbody(&has_bits);
          _impl_.isbody_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.Node ret = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_ret(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .clojureRT.protobuf.Node statements = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_statements(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DoNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojureRT.protobuf.DoNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional bool isBody = 1;
  if (_internal_has_isbody()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_isbody(), target);
  }

  // .clojureRT.protobuf.Node ret = 2;
  if (this->_internal_has_ret()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::ret(this),
        _Internal::ret(this).GetCachedSize(), target, stream);
  }

  // repeated .clojureRT.protobuf.Node statements = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_statements_size()); i < n; i++) {
    const auto& repfield = this->_internal_statements(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojureRT.protobuf.DoNode)
  return target;
}

size_t DoNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojureRT.protobuf.DoNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .clojureRT.protobuf.Node statements = 3;
  total_size += 1UL * this->_internal_statements_size();
  for (const auto& msg : this->_impl_.statements_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .clojureRT.protobuf.Node ret = 2;
  if (this->_internal_has_ret()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.ret_);
  }

  // optional bool isBody = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DoNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DoNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DoNode::GetClassData() const { return &_class_data_; }


void DoNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DoNode*>(&to_msg);
  auto& from = static_cast<const DoNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojureRT.protobuf.DoNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.statements_.MergeFrom(from._impl_.statements_);
  if (from._internal_has_ret()) {
    _this->_internal_mutable_ret()->::clojureRT::protobuf::Node::MergeFrom(
        from._internal_ret());
  }
  if (from._internal_has_isbody()) {
    _this->_internal_set_isbody(from._internal_isbody());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DoNode::CopyFrom(const DoNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojureRT.protobuf.DoNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DoNode::IsInitialized() const {
  return true;
}

void DoNode::InternalSwap(DoNode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.statements_.InternalSwap(&other->_impl_.statements_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DoNode, _impl_.isbody_)
      + sizeof(DoNode::_impl_.isbody_)
      - PROTOBUF_FIELD_OFFSET(DoNode, _impl_.ret_)>(
          reinterpret_cast<char*>(&_impl_.ret_),
          reinterpret_cast<char*>(&other->_impl_.ret_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DoNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[9]);
}

// ===================================================================

class FnNode::_Internal {
 public:
  using HasBits = decltype(std::declval<FnNode>()._impl_._has_bits_);
  static const ::clojureRT::protobuf::Node& local(const FnNode* msg);
  static void set_has_local(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::clojureRT::protobuf::Node&
FnNode::_Internal::local(const FnNode* msg) {
  return *msg->_impl_.local_;
}
FnNode::FnNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojureRT.protobuf.FnNode)
}
FnNode::FnNode(const FnNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FnNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.methods_){from._impl_.methods_}
    , decltype(_impl_.local_){nullptr}
    , decltype(_impl_.maxfixedarity_){}
    , decltype(_impl_.once_){}
    , decltype(_impl_.isvariadic_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_local()) {
    _this->_impl_.local_ = new ::clojureRT::protobuf::Node(*from._impl_.local_);
  }
  ::memcpy(&_impl_.maxfixedarity_, &from._impl_.maxfixedarity_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.isvariadic_) -
    reinterpret_cast<char*>(&_impl_.maxfixedarity_)) + sizeof(_impl_.isvariadic_));
  // @@protoc_insertion_point(copy_constructor:clojureRT.protobuf.FnNode)
}

inline void FnNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.methods_){arena}
    , decltype(_impl_.local_){nullptr}
    , decltype(_impl_.maxfixedarity_){0u}
    , decltype(_impl_.once_){false}
    , decltype(_impl_.isvariadic_){false}
  };
}

FnNode::~FnNode() {
  // @@protoc_insertion_point(destructor:clojureRT.protobuf.FnNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FnNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.methods_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.local_;
}

void FnNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FnNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojureRT.protobuf.FnNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.methods_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.local_ != nullptr);
    _impl_.local_->Clear();
  }
  ::memset(&_impl_.maxfixedarity_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.isvariadic_) -
      reinterpret_cast<char*>(&_impl_.maxfixedarity_)) + sizeof(_impl_.isvariadic_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FnNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .clojureRT.protobuf.Node local = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_local(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 maxFixedArity = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.maxfixedarity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .clojureRT.protobuf.Node methods = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_methods(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // bool once = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.once_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool isVariadic = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.isvariadic_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FnNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojureRT.protobuf.FnNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .clojureRT.protobuf.Node local = 1;
  if (_internal_has_local()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::local(this),
        _Internal::local(this).GetCachedSize(), target, stream);
  }

  // uint32 maxFixedArity = 2;
  if (this->_internal_maxfixedarity() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_maxfixedarity(), target);
  }

  // repeated .clojureRT.protobuf.Node methods = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_methods_size()); i < n; i++) {
    const auto& repfield = this->_internal_methods(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // bool once = 4;
  if (this->_internal_once() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_once(), target);
  }

  // bool isVariadic = 5;
  if (this->_internal_isvariadic() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_isvariadic(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojureRT.protobuf.FnNode)
  return target;
}

size_t FnNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojureRT.protobuf.FnNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .clojureRT.protobuf.Node methods = 3;
  total_size += 1UL * this->_internal_methods_size();
  for (const auto& msg : this->_impl_.methods_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .clojureRT.protobuf.Node local = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.local_);
  }

  // uint32 maxFixedArity = 2;
  if (this->_internal_maxfixedarity() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_maxfixedarity());
  }

  // bool once = 4;
  if (this->_internal_once() != 0) {
    total_size += 1 + 1;
  }

  // bool isVariadic = 5;
  if (this->_internal_isvariadic() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FnNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FnNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FnNode::GetClassData() const { return &_class_data_; }


void FnNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FnNode*>(&to_msg);
  auto& from = static_cast<const FnNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojureRT.protobuf.FnNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.methods_.MergeFrom(from._impl_.methods_);
  if (from._internal_has_local()) {
    _this->_internal_mutable_local()->::clojureRT::protobuf::Node::MergeFrom(
        from._internal_local());
  }
  if (from._internal_maxfixedarity() != 0) {
    _this->_internal_set_maxfixedarity(from._internal_maxfixedarity());
  }
  if (from._internal_once() != 0) {
    _this->_internal_set_once(from._internal_once());
  }
  if (from._internal_isvariadic() != 0) {
    _this->_internal_set_isvariadic(from._internal_isvariadic());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FnNode::CopyFrom(const FnNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojureRT.protobuf.FnNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FnNode::IsInitialized() const {
  return true;
}

void FnNode::InternalSwap(FnNode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.methods_.InternalSwap(&other->_impl_.methods_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FnNode, _impl_.isvariadic_)
      + sizeof(FnNode::_impl_.isvariadic_)
      - PROTOBUF_FIELD_OFFSET(FnNode, _impl_.local_)>(
          reinterpret_cast<char*>(&_impl_.local_),
          reinterpret_cast<char*>(&other->_impl_.local_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FnNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[10]);
}

// ===================================================================

class FnMethodNode::_Internal {
 public:
  static const ::clojureRT::protobuf::Node& body(const FnMethodNode* msg);
};

const ::clojureRT::protobuf::Node&
FnMethodNode::_Internal::body(const FnMethodNode* msg) {
  return *msg->_impl_.body_;
}
FnMethodNode::FnMethodNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojureRT.protobuf.FnMethodNode)
}
FnMethodNode::FnMethodNode(const FnMethodNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FnMethodNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.params_){from._impl_.params_}
    , decltype(_impl_.loopid_){}
    , decltype(_impl_.body_){nullptr}
    , decltype(_impl_.fixedarity_){}
    , decltype(_impl_.isvariadic_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.loopid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.loopid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_loopid().empty()) {
    _this->_impl_.loopid_.Set(from._internal_loopid(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_body()) {
    _this->_impl_.body_ = new ::clojureRT::protobuf::Node(*from._impl_.body_);
  }
  ::memcpy(&_impl_.fixedarity_, &from._impl_.fixedarity_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.isvariadic_) -
    reinterpret_cast<char*>(&_impl_.fixedarity_)) + sizeof(_impl_.isvariadic_));
  // @@protoc_insertion_point(copy_constructor:clojureRT.protobuf.FnMethodNode)
}

inline void FnMethodNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.params_){arena}
    , decltype(_impl_.loopid_){}
    , decltype(_impl_.body_){nullptr}
    , decltype(_impl_.fixedarity_){0u}
    , decltype(_impl_.isvariadic_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.loopid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.loopid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

FnMethodNode::~FnMethodNode() {
  // @@protoc_insertion_point(destructor:clojureRT.protobuf.FnMethodNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FnMethodNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.params_.~RepeatedPtrField();
  _impl_.loopid_.Destroy();
  if (this != internal_default_instance()) delete _impl_.body_;
}

void FnMethodNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FnMethodNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojureRT.protobuf.FnMethodNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.params_.Clear();
  _impl_.loopid_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.body_ != nullptr) {
    delete _impl_.body_;
  }
  _impl_.body_ = nullptr;
  ::memset(&_impl_.fixedarity_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.isvariadic_) -
      reinterpret_cast<char*>(&_impl_.fixedarity_)) + sizeof(_impl_.isvariadic_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FnMethodNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .clojureRT.protobuf.Node body = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_body(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 fixedArity = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.fixedarity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string loopId = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_loopid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojureRT.protobuf.FnMethodNode.loopId"));
        } else
          goto handle_unusual;
        continue;
      // repeated .clojureRT.protobuf.Node params = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_params(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // bool isVariadic = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.isvariadic_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FnMethodNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojureRT.protobuf.FnMethodNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .clojureRT.protobuf.Node body = 1;
  if (this->_internal_has_body()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::body(this),
        _Internal::body(this).GetCachedSize(), target, stream);
  }

  // uint32 fixedArity = 2;
  if (this->_internal_fixedarity() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_fixedarity(), target);
  }

  // string loopId = 3;
  if (!this->_internal_loopid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_loopid().data(), static_cast<int>(this->_internal_loopid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojureRT.protobuf.FnMethodNode.loopId");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_loopid(), target);
  }

  // repeated .clojureRT.protobuf.Node params = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_params_size()); i < n; i++) {
    const auto& repfield = this->_internal_params(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // bool isVariadic = 5;
  if (this->_internal_isvariadic() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_isvariadic(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojureRT.protobuf.FnMethodNode)
  return target;
}

size_t FnMethodNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojureRT.protobuf.FnMethodNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .clojureRT.protobuf.Node params = 4;
  total_size += 1UL * this->_internal_params_size();
  for (const auto& msg : this->_impl_.params_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string loopId = 3;
  if (!this->_internal_loopid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_loopid());
  }

  // .clojureRT.protobuf.Node body = 1;
  if (this->_internal_has_body()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.body_);
  }

  // uint32 fixedArity = 2;
  if (this->_internal_fixedarity() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_fixedarity());
  }

  // bool isVariadic = 5;
  if (this->_internal_isvariadic() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FnMethodNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FnMethodNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FnMethodNode::GetClassData() const { return &_class_data_; }


void FnMethodNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FnMethodNode*>(&to_msg);
  auto& from = static_cast<const FnMethodNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojureRT.protobuf.FnMethodNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.params_.MergeFrom(from._impl_.params_);
  if (!from._internal_loopid().empty()) {
    _this->_internal_set_loopid(from._internal_loopid());
  }
  if (from._internal_has_body()) {
    _this->_internal_mutable_body()->::clojureRT::protobuf::Node::MergeFrom(
        from._internal_body());
  }
  if (from._internal_fixedarity() != 0) {
    _this->_internal_set_fixedarity(from._internal_fixedarity());
  }
  if (from._internal_isvariadic() != 0) {
    _this->_internal_set_isvariadic(from._internal_isvariadic());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FnMethodNode::CopyFrom(const FnMethodNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojureRT.protobuf.FnMethodNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FnMethodNode::IsInitialized() const {
  return true;
}

void FnMethodNode::InternalSwap(FnMethodNode* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.params_.InternalSwap(&other->_impl_.params_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.loopid_, lhs_arena,
      &other->_impl_.loopid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FnMethodNode, _impl_.isvariadic_)
      + sizeof(FnMethodNode::_impl_.isvariadic_)
      - PROTOBUF_FIELD_OFFSET(FnMethodNode, _impl_.body_)>(
          reinterpret_cast<char*>(&_impl_.body_),
          reinterpret_cast<char*>(&other->_impl_.body_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FnMethodNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[11]);
}

// ===================================================================

class HostInteropNode::_Internal {
 public:
  static const ::clojureRT::protobuf::Node& target(const HostInteropNode* msg);
};

const ::clojureRT::protobuf::Node&
HostInteropNode::_Internal::target(const HostInteropNode* msg) {
  return *msg->_impl_.target_;
}
HostInteropNode::HostInteropNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojureRT.protobuf.HostInteropNode)
}
HostInteropNode::HostInteropNode(const HostInteropNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  HostInteropNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.morf_){}
    , decltype(_impl_.target_){nullptr}
    , decltype(_impl_.isassignable_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.morf_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.morf_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_morf().empty()) {
    _this->_impl_.morf_.Set(from._internal_morf(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_target()) {
    _this->_impl_.target_ = new ::clojureRT::protobuf::Node(*from._impl_.target_);
  }
  _this->_impl_.isassignable_ = from._impl_.isassignable_;
  // @@protoc_insertion_point(copy_constructor:clojureRT.protobuf.HostInteropNode)
}

inline void HostInteropNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.morf_){}
    , decltype(_impl_.target_){nullptr}
    , decltype(_impl_.isassignable_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.morf_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.morf_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

HostInteropNode::~HostInteropNode() {
  // @@protoc_insertion_point(destructor:clojureRT.protobuf.HostInteropNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void HostInteropNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.morf_.Destroy();
  if (this != internal_default_instance()) delete _impl_.target_;
}

void HostInteropNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void HostInteropNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojureRT.protobuf.HostInteropNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.morf_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.target_ != nullptr) {
    delete _impl_.target_;
  }
  _impl_.target_ = nullptr;
  _impl_.isassignable_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* HostInteropNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool isAssignable = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.isassignable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string mOrF = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_morf();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojureRT.protobuf.HostInteropNode.mOrF"));
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.Node target = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_target(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* HostInteropNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojureRT.protobuf.HostInteropNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool isAssignable = 1;
  if (this->_internal_isassignable() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_isassignable(), target);
  }

  // string mOrF = 2;
  if (!this->_internal_morf().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_morf().data(), static_cast<int>(this->_internal_morf().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojureRT.protobuf.HostInteropNode.mOrF");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_morf(), target);
  }

  // .clojureRT.protobuf.Node target = 3;
  if (this->_internal_has_target()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::target(this),
        _Internal::target(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojureRT.protobuf.HostInteropNode)
  return target;
}

size_t HostInteropNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojureRT.protobuf.HostInteropNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string mOrF = 2;
  if (!this->_internal_morf().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_morf());
  }

  // .clojureRT.protobuf.Node target = 3;
  if (this->_internal_has_target()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.target_);
  }

  // bool isAssignable = 1;
  if (this->_internal_isassignable() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData HostInteropNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    HostInteropNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*HostInteropNode::GetClassData() const { return &_class_data_; }


void HostInteropNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<HostInteropNode*>(&to_msg);
  auto& from = static_cast<const HostInteropNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojureRT.protobuf.HostInteropNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_morf().empty()) {
    _this->_internal_set_morf(from._internal_morf());
  }
  if (from._internal_has_target()) {
    _this->_internal_mutable_target()->::clojureRT::protobuf::Node::MergeFrom(
        from._internal_target());
  }
  if (from._internal_isassignable() != 0) {
    _this->_internal_set_isassignable(from._internal_isassignable());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void HostInteropNode::CopyFrom(const HostInteropNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojureRT.protobuf.HostInteropNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HostInteropNode::IsInitialized() const {
  return true;
}

void HostInteropNode::InternalSwap(HostInteropNode* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.morf_, lhs_arena,
      &other->_impl_.morf_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(HostInteropNode, _impl_.isassignable_)
      + sizeof(HostInteropNode::_impl_.isassignable_)
      - PROTOBUF_FIELD_OFFSET(HostInteropNode, _impl_.target_)>(
          reinterpret_cast<char*>(&_impl_.target_),
          reinterpret_cast<char*>(&other->_impl_.target_));
}

::PROTOBUF_NAMESPACE_ID::Metadata HostInteropNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[12]);
}

// ===================================================================

class IfNode::_Internal {
 public:
  static const ::clojureRT::protobuf::Node& else_(const IfNode* msg);
  static const ::clojureRT::protobuf::Node& test(const IfNode* msg);
  static const ::clojureRT::protobuf::Node& then(const IfNode* msg);
};

const ::clojureRT::protobuf::Node&
IfNode::_Internal::else_(const IfNode* msg) {
  return *msg->_impl_.else__;
}
const ::clojureRT::protobuf::Node&
IfNode::_Internal::test(const IfNode* msg) {
  return *msg->_impl_.test_;
}
const ::clojureRT::protobuf::Node&
IfNode::_Internal::then(const IfNode* msg) {
  return *msg->_impl_.then_;
}
IfNode::IfNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojureRT.protobuf.IfNode)
}
IfNode::IfNode(const IfNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  IfNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.else__){nullptr}
    , decltype(_impl_.test_){nullptr}
    , decltype(_impl_.then_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_else_()) {
    _this->_impl_.else__ = new ::clojureRT::protobuf::Node(*from._impl_.else__);
  }
  if (from._internal_has_test()) {
    _this->_impl_.test_ = new ::clojureRT::protobuf::Node(*from._impl_.test_);
  }
  if (from._internal_has_then()) {
    _this->_impl_.then_ = new ::clojureRT::protobuf::Node(*from._impl_.then_);
  }
  // @@protoc_insertion_point(copy_constructor:clojureRT.protobuf.IfNode)
}

inline void IfNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.else__){nullptr}
    , decltype(_impl_.test_){nullptr}
    , decltype(_impl_.then_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

IfNode::~IfNode() {
  // @@protoc_insertion_point(destructor:clojureRT.protobuf.IfNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IfNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.else__;
  if (this != internal_default_instance()) delete _impl_.test_;
  if (this != internal_default_instance()) delete _impl_.then_;
}

void IfNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IfNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojureRT.protobuf.IfNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.else__ != nullptr) {
    delete _impl_.else__;
  }
  _impl_.else__ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.test_ != nullptr) {
    delete _impl_.test_;
  }
  _impl_.test_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.then_ != nullptr) {
    delete _impl_.then_;
  }
  _impl_.then_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IfNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .clojureRT.protobuf.Node else = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_else_(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.Node test = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_test(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.Node then = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_then(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IfNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojureRT.protobuf.IfNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .clojureRT.protobuf.Node else = 1;
  if (this->_internal_has_else_()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::else_(this),
        _Internal::else_(this).GetCachedSize(), target, stream);
  }

  // .clojureRT.protobuf.Node test = 2;
  if (this->_internal_has_test()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::test(this),
        _Internal::test(this).GetCachedSize(), target, stream);
  }

  // .clojureRT.protobuf.Node then = 3;
  if (this->_internal_has_then()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::then(this),
        _Internal::then(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojureRT.protobuf.IfNode)
  return target;
}

size_t IfNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojureRT.protobuf.IfNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .clojureRT.protobuf.Node else = 1;
  if (this->_internal_has_else_()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.else__);
  }

  // .clojureRT.protobuf.Node test = 2;
  if (this->_internal_has_test()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.test_);
  }

  // .clojureRT.protobuf.Node then = 3;
  if (this->_internal_has_then()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.then_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IfNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    IfNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IfNode::GetClassData() const { return &_class_data_; }


void IfNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<IfNode*>(&to_msg);
  auto& from = static_cast<const IfNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojureRT.protobuf.IfNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_else_()) {
    _this->_internal_mutable_else_()->::clojureRT::protobuf::Node::MergeFrom(
        from._internal_else_());
  }
  if (from._internal_has_test()) {
    _this->_internal_mutable_test()->::clojureRT::protobuf::Node::MergeFrom(
        from._internal_test());
  }
  if (from._internal_has_then()) {
    _this->_internal_mutable_then()->::clojureRT::protobuf::Node::MergeFrom(
        from._internal_then());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IfNode::CopyFrom(const IfNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojureRT.protobuf.IfNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IfNode::IsInitialized() const {
  return true;
}

void IfNode::InternalSwap(IfNode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IfNode, _impl_.then_)
      + sizeof(IfNode::_impl_.then_)
      - PROTOBUF_FIELD_OFFSET(IfNode, _impl_.else__)>(
          reinterpret_cast<char*>(&_impl_.else__),
          reinterpret_cast<char*>(&other->_impl_.else__));
}

::PROTOBUF_NAMESPACE_ID::Metadata IfNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[13]);
}

// ===================================================================

class ImportNode::_Internal {
 public:
};

ImportNode::ImportNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojureRT.protobuf.ImportNode)
}
ImportNode::ImportNode(const ImportNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ImportNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.class__){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.class__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.class__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_class_().empty()) {
    _this->_impl_.class__.Set(from._internal_class_(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:clojureRT.protobuf.ImportNode)
}

inline void ImportNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.class__){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.class__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.class__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ImportNode::~ImportNode() {
  // @@protoc_insertion_point(destructor:clojureRT.protobuf.ImportNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ImportNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.class__.Destroy();
}

void ImportNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ImportNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojureRT.protobuf.ImportNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.class__.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ImportNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string class = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_class_();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojureRT.protobuf.ImportNode.class"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ImportNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojureRT.protobuf.ImportNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string class = 1;
  if (!this->_internal_class_().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_class_().data(), static_cast<int>(this->_internal_class_().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojureRT.protobuf.ImportNode.class");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_class_(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojureRT.protobuf.ImportNode)
  return target;
}

size_t ImportNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojureRT.protobuf.ImportNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string class = 1;
  if (!this->_internal_class_().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_class_());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ImportNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ImportNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ImportNode::GetClassData() const { return &_class_data_; }


void ImportNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ImportNode*>(&to_msg);
  auto& from = static_cast<const ImportNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojureRT.protobuf.ImportNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_class_().empty()) {
    _this->_internal_set_class_(from._internal_class_());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ImportNode::CopyFrom(const ImportNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojureRT.protobuf.ImportNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ImportNode::IsInitialized() const {
  return true;
}

void ImportNode::InternalSwap(ImportNode* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.class__, lhs_arena,
      &other->_impl_.class__, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ImportNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[14]);
}

// ===================================================================

class InstanceCallNode::_Internal {
 public:
  using HasBits = decltype(std::declval<InstanceCallNode>()._impl_._has_bits_);
  static void set_has_class_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::clojureRT::protobuf::Node& instance(const InstanceCallNode* msg);
  static void set_has_isvalidated(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::clojureRT::protobuf::Node&
InstanceCallNode::_Internal::instance(const InstanceCallNode* msg) {
  return *msg->_impl_.instance_;
}
InstanceCallNode::InstanceCallNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojureRT.protobuf.InstanceCallNode)
}
InstanceCallNode::InstanceCallNode(const InstanceCallNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  InstanceCallNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.args_){from._impl_.args_}
    , decltype(_impl_.class__){}
    , decltype(_impl_.method_){}
    , decltype(_impl_.instance_){nullptr}
    , decltype(_impl_.isvalidated_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.class__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.class__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_class_()) {
    _this->_impl_.class__.Set(from._internal_class_(), 
      _this->GetArenaForAllocation());
  }
  _impl_.method_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.method_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_method().empty()) {
    _this->_impl_.method_.Set(from._internal_method(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_instance()) {
    _this->_impl_.instance_ = new ::clojureRT::protobuf::Node(*from._impl_.instance_);
  }
  _this->_impl_.isvalidated_ = from._impl_.isvalidated_;
  // @@protoc_insertion_point(copy_constructor:clojureRT.protobuf.InstanceCallNode)
}

inline void InstanceCallNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.args_){arena}
    , decltype(_impl_.class__){}
    , decltype(_impl_.method_){}
    , decltype(_impl_.instance_){nullptr}
    , decltype(_impl_.isvalidated_){false}
  };
  _impl_.class__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.class__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.method_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.method_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

InstanceCallNode::~InstanceCallNode() {
  // @@protoc_insertion_point(destructor:clojureRT.protobuf.InstanceCallNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InstanceCallNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.args_.~RepeatedPtrField();
  _impl_.class__.Destroy();
  _impl_.method_.Destroy();
  if (this != internal_default_instance()) delete _impl_.instance_;
}

void InstanceCallNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void InstanceCallNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojureRT.protobuf.InstanceCallNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.args_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.class__.ClearNonDefaultToEmpty();
  }
  _impl_.method_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.instance_ != nullptr) {
    delete _impl_.instance_;
  }
  _impl_.instance_ = nullptr;
  _impl_.isvalidated_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* InstanceCallNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .clojureRT.protobuf.Node args = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_args(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string class = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_class_();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojureRT.protobuf.InstanceCallNode.class"));
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.Node instance = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_instance(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string method = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_method();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojureRT.protobuf.InstanceCallNode.method"));
        } else
          goto handle_unusual;
        continue;
      // optional bool isValidated = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_isvalidated(&has_bits);
          _impl_.isvalidated_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InstanceCallNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojureRT.protobuf.InstanceCallNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .clojureRT.protobuf.Node args = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_args_size()); i < n; i++) {
    const auto& repfield = this->_internal_args(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional string class = 2;
  if (_internal_has_class_()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_class_().data(), static_cast<int>(this->_internal_class_().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojureRT.protobuf.InstanceCallNode.class");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_class_(), target);
  }

  // .clojureRT.protobuf.Node instance = 3;
  if (this->_internal_has_instance()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::instance(this),
        _Internal::instance(this).GetCachedSize(), target, stream);
  }

  // string method = 4;
  if (!this->_internal_method().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_method().data(), static_cast<int>(this->_internal_method().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojureRT.protobuf.InstanceCallNode.method");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_method(), target);
  }

  // optional bool isValidated = 5;
  if (_internal_has_isvalidated()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_isvalidated(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojureRT.protobuf.InstanceCallNode)
  return target;
}

size_t InstanceCallNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojureRT.protobuf.InstanceCallNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .clojureRT.protobuf.Node args = 1;
  total_size += 1UL * this->_internal_args_size();
  for (const auto& msg : this->_impl_.args_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional string class = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_class_());
  }

  // string method = 4;
  if (!this->_internal_method().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_method());
  }

  // .clojureRT.protobuf.Node instance = 3;
  if (this->_internal_has_instance()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.instance_);
  }

  // optional bool isValidated = 5;
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData InstanceCallNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    InstanceCallNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*InstanceCallNode::GetClassData() const { return &_class_data_; }


void InstanceCallNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<InstanceCallNode*>(&to_msg);
  auto& from = static_cast<const InstanceCallNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojureRT.protobuf.InstanceCallNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.args_.MergeFrom(from._impl_.args_);
  if (from._internal_has_class_()) {
    _this->_internal_set_class_(from._internal_class_());
  }
  if (!from._internal_method().empty()) {
    _this->_internal_set_method(from._internal_method());
  }
  if (from._internal_has_instance()) {
    _this->_internal_mutable_instance()->::clojureRT::protobuf::Node::MergeFrom(
        from._internal_instance());
  }
  if (from._internal_has_isvalidated()) {
    _this->_internal_set_isvalidated(from._internal_isvalidated());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void InstanceCallNode::CopyFrom(const InstanceCallNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojureRT.protobuf.InstanceCallNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InstanceCallNode::IsInitialized() const {
  return true;
}

void InstanceCallNode::InternalSwap(InstanceCallNode* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.args_.InternalSwap(&other->_impl_.args_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.class__, lhs_arena,
      &other->_impl_.class__, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.method_, lhs_arena,
      &other->_impl_.method_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(InstanceCallNode, _impl_.isvalidated_)
      + sizeof(InstanceCallNode::_impl_.isvalidated_)
      - PROTOBUF_FIELD_OFFSET(InstanceCallNode, _impl_.instance_)>(
          reinterpret_cast<char*>(&_impl_.instance_),
          reinterpret_cast<char*>(&other->_impl_.instance_));
}

::PROTOBUF_NAMESPACE_ID::Metadata InstanceCallNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[15]);
}

// ===================================================================

class InstanceFieldNode::_Internal {
 public:
  static const ::clojureRT::protobuf::Node& instance(const InstanceFieldNode* msg);
};

const ::clojureRT::protobuf::Node&
InstanceFieldNode::_Internal::instance(const InstanceFieldNode* msg) {
  return *msg->_impl_.instance_;
}
InstanceFieldNode::InstanceFieldNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojureRT.protobuf.InstanceFieldNode)
}
InstanceFieldNode::InstanceFieldNode(const InstanceFieldNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  InstanceFieldNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.class__){}
    , decltype(_impl_.field_){}
    , decltype(_impl_.instance_){nullptr}
    , decltype(_impl_.isassignable_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.class__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.class__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_class_().empty()) {
    _this->_impl_.class__.Set(from._internal_class_(), 
      _this->GetArenaForAllocation());
  }
  _impl_.field_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.field_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_field().empty()) {
    _this->_impl_.field_.Set(from._internal_field(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_instance()) {
    _this->_impl_.instance_ = new ::clojureRT::protobuf::Node(*from._impl_.instance_);
  }
  _this->_impl_.isassignable_ = from._impl_.isassignable_;
  // @@protoc_insertion_point(copy_constructor:clojureRT.protobuf.InstanceFieldNode)
}

inline void InstanceFieldNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.class__){}
    , decltype(_impl_.field_){}
    , decltype(_impl_.instance_){nullptr}
    , decltype(_impl_.isassignable_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.class__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.class__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.field_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.field_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

InstanceFieldNode::~InstanceFieldNode() {
  // @@protoc_insertion_point(destructor:clojureRT.protobuf.InstanceFieldNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InstanceFieldNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.class__.Destroy();
  _impl_.field_.Destroy();
  if (this != internal_default_instance()) delete _impl_.instance_;
}

void InstanceFieldNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void InstanceFieldNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojureRT.protobuf.InstanceFieldNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.class__.ClearToEmpty();
  _impl_.field_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.instance_ != nullptr) {
    delete _impl_.instance_;
  }
  _impl_.instance_ = nullptr;
  _impl_.isassignable_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* InstanceFieldNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool isAssignable = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.isassignable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string class = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_class_();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojureRT.protobuf.InstanceFieldNode.class"));
        } else
          goto handle_unusual;
        continue;
      // string field = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_field();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojureRT.protobuf.InstanceFieldNode.field"));
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.Node instance = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_instance(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InstanceFieldNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojureRT.protobuf.InstanceFieldNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool isAssignable = 1;
  if (this->_internal_isassignable() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_isassignable(), target);
  }

  // string class = 2;
  if (!this->_internal_class_().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_class_().data(), static_cast<int>(this->_internal_class_().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojureRT.protobuf.InstanceFieldNode.class");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_class_(), target);
  }

  // string field = 3;
  if (!this->_internal_field().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_field().data(), static_cast<int>(this->_internal_field().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojureRT.protobuf.InstanceFieldNode.field");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_field(), target);
  }

  // .clojureRT.protobuf.Node instance = 4;
  if (this->_internal_has_instance()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::instance(this),
        _Internal::instance(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojureRT.protobuf.InstanceFieldNode)
  return target;
}

size_t InstanceFieldNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojureRT.protobuf.InstanceFieldNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string class = 2;
  if (!this->_internal_class_().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_class_());
  }

  // string field = 3;
  if (!this->_internal_field().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_field());
  }

  // .clojureRT.protobuf.Node instance = 4;
  if (this->_internal_has_instance()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.instance_);
  }

  // bool isAssignable = 1;
  if (this->_internal_isassignable() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData InstanceFieldNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    InstanceFieldNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*InstanceFieldNode::GetClassData() const { return &_class_data_; }


void InstanceFieldNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<InstanceFieldNode*>(&to_msg);
  auto& from = static_cast<const InstanceFieldNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojureRT.protobuf.InstanceFieldNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_class_().empty()) {
    _this->_internal_set_class_(from._internal_class_());
  }
  if (!from._internal_field().empty()) {
    _this->_internal_set_field(from._internal_field());
  }
  if (from._internal_has_instance()) {
    _this->_internal_mutable_instance()->::clojureRT::protobuf::Node::MergeFrom(
        from._internal_instance());
  }
  if (from._internal_isassignable() != 0) {
    _this->_internal_set_isassignable(from._internal_isassignable());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void InstanceFieldNode::CopyFrom(const InstanceFieldNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojureRT.protobuf.InstanceFieldNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InstanceFieldNode::IsInitialized() const {
  return true;
}

void InstanceFieldNode::InternalSwap(InstanceFieldNode* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.class__, lhs_arena,
      &other->_impl_.class__, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.field_, lhs_arena,
      &other->_impl_.field_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(InstanceFieldNode, _impl_.isassignable_)
      + sizeof(InstanceFieldNode::_impl_.isassignable_)
      - PROTOBUF_FIELD_OFFSET(InstanceFieldNode, _impl_.instance_)>(
          reinterpret_cast<char*>(&_impl_.instance_),
          reinterpret_cast<char*>(&other->_impl_.instance_));
}

::PROTOBUF_NAMESPACE_ID::Metadata InstanceFieldNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[16]);
}

// ===================================================================

class IsInstanceNode::_Internal {
 public:
  static const ::clojureRT::protobuf::Node& target(const IsInstanceNode* msg);
};

const ::clojureRT::protobuf::Node&
IsInstanceNode::_Internal::target(const IsInstanceNode* msg) {
  return *msg->_impl_.target_;
}
IsInstanceNode::IsInstanceNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojureRT.protobuf.IsInstanceNode)
}
IsInstanceNode::IsInstanceNode(const IsInstanceNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  IsInstanceNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.class__){}
    , decltype(_impl_.target_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.class__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.class__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_class_().empty()) {
    _this->_impl_.class__.Set(from._internal_class_(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_target()) {
    _this->_impl_.target_ = new ::clojureRT::protobuf::Node(*from._impl_.target_);
  }
  // @@protoc_insertion_point(copy_constructor:clojureRT.protobuf.IsInstanceNode)
}

inline void IsInstanceNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.class__){}
    , decltype(_impl_.target_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.class__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.class__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

IsInstanceNode::~IsInstanceNode() {
  // @@protoc_insertion_point(destructor:clojureRT.protobuf.IsInstanceNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IsInstanceNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.class__.Destroy();
  if (this != internal_default_instance()) delete _impl_.target_;
}

void IsInstanceNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IsInstanceNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojureRT.protobuf.IsInstanceNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.class__.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.target_ != nullptr) {
    delete _impl_.target_;
  }
  _impl_.target_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IsInstanceNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string class = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_class_();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojureRT.protobuf.IsInstanceNode.class"));
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.Node target = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_target(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IsInstanceNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojureRT.protobuf.IsInstanceNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string class = 1;
  if (!this->_internal_class_().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_class_().data(), static_cast<int>(this->_internal_class_().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojureRT.protobuf.IsInstanceNode.class");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_class_(), target);
  }

  // .clojureRT.protobuf.Node target = 2;
  if (this->_internal_has_target()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::target(this),
        _Internal::target(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojureRT.protobuf.IsInstanceNode)
  return target;
}

size_t IsInstanceNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojureRT.protobuf.IsInstanceNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string class = 1;
  if (!this->_internal_class_().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_class_());
  }

  // .clojureRT.protobuf.Node target = 2;
  if (this->_internal_has_target()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.target_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IsInstanceNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    IsInstanceNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IsInstanceNode::GetClassData() const { return &_class_data_; }


void IsInstanceNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<IsInstanceNode*>(&to_msg);
  auto& from = static_cast<const IsInstanceNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojureRT.protobuf.IsInstanceNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_class_().empty()) {
    _this->_internal_set_class_(from._internal_class_());
  }
  if (from._internal_has_target()) {
    _this->_internal_mutable_target()->::clojureRT::protobuf::Node::MergeFrom(
        from._internal_target());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IsInstanceNode::CopyFrom(const IsInstanceNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojureRT.protobuf.IsInstanceNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IsInstanceNode::IsInitialized() const {
  return true;
}

void IsInstanceNode::InternalSwap(IsInstanceNode* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.class__, lhs_arena,
      &other->_impl_.class__, rhs_arena
  );
  swap(_impl_.target_, other->_impl_.target_);
}

::PROTOBUF_NAMESPACE_ID::Metadata IsInstanceNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[17]);
}

// ===================================================================

class InvokeNode::_Internal {
 public:
  using HasBits = decltype(std::declval<InvokeNode>()._impl_._has_bits_);
  static const ::clojureRT::protobuf::Node& fn(const InvokeNode* msg);
  static void set_has_meta(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::clojureRT::protobuf::Node&
InvokeNode::_Internal::fn(const InvokeNode* msg) {
  return *msg->_impl_.fn_;
}
InvokeNode::InvokeNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojureRT.protobuf.InvokeNode)
}
InvokeNode::InvokeNode(const InvokeNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  InvokeNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.args_){from._impl_.args_}
    , decltype(_impl_.meta_){}
    , decltype(_impl_.fn_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.meta_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.meta_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_meta()) {
    _this->_impl_.meta_.Set(from._internal_meta(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_fn()) {
    _this->_impl_.fn_ = new ::clojureRT::protobuf::Node(*from._impl_.fn_);
  }
  // @@protoc_insertion_point(copy_constructor:clojureRT.protobuf.InvokeNode)
}

inline void InvokeNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.args_){arena}
    , decltype(_impl_.meta_){}
    , decltype(_impl_.fn_){nullptr}
  };
  _impl_.meta_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.meta_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

InvokeNode::~InvokeNode() {
  // @@protoc_insertion_point(destructor:clojureRT.protobuf.InvokeNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InvokeNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.args_.~RepeatedPtrField();
  _impl_.meta_.Destroy();
  if (this != internal_default_instance()) delete _impl_.fn_;
}

void InvokeNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void InvokeNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojureRT.protobuf.InvokeNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.args_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.meta_.ClearNonDefaultToEmpty();
  }
  if (GetArenaForAllocation() == nullptr && _impl_.fn_ != nullptr) {
    delete _impl_.fn_;
  }
  _impl_.fn_ = nullptr;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* InvokeNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .clojureRT.protobuf.Node args = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_args(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.Node fn = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_fn(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string meta = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_meta();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojureRT.protobuf.InvokeNode.meta"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InvokeNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojureRT.protobuf.InvokeNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .clojureRT.protobuf.Node args = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_args_size()); i < n; i++) {
    const auto& repfield = this->_internal_args(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .clojureRT.protobuf.Node fn = 2;
  if (this->_internal_has_fn()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::fn(this),
        _Internal::fn(this).GetCachedSize(), target, stream);
  }

  // optional string meta = 3;
  if (_internal_has_meta()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_meta().data(), static_cast<int>(this->_internal_meta().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojureRT.protobuf.InvokeNode.meta");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_meta(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojureRT.protobuf.InvokeNode)
  return target;
}

size_t InvokeNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojureRT.protobuf.InvokeNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .clojureRT.protobuf.Node args = 1;
  total_size += 1UL * this->_internal_args_size();
  for (const auto& msg : this->_impl_.args_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional string meta = 3;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_meta());
  }

  // .clojureRT.protobuf.Node fn = 2;
  if (this->_internal_has_fn()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.fn_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData InvokeNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    InvokeNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*InvokeNode::GetClassData() const { return &_class_data_; }


void InvokeNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<InvokeNode*>(&to_msg);
  auto& from = static_cast<const InvokeNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojureRT.protobuf.InvokeNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.args_.MergeFrom(from._impl_.args_);
  if (from._internal_has_meta()) {
    _this->_internal_set_meta(from._internal_meta());
  }
  if (from._internal_has_fn()) {
    _this->_internal_mutable_fn()->::clojureRT::protobuf::Node::MergeFrom(
        from._internal_fn());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void InvokeNode::CopyFrom(const InvokeNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojureRT.protobuf.InvokeNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InvokeNode::IsInitialized() const {
  return true;
}

void InvokeNode::InternalSwap(InvokeNode* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.args_.InternalSwap(&other->_impl_.args_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.meta_, lhs_arena,
      &other->_impl_.meta_, rhs_arena
  );
  swap(_impl_.fn_, other->_impl_.fn_);
}

::PROTOBUF_NAMESPACE_ID::Metadata InvokeNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[18]);
}

// ===================================================================

class KeywordInvokeNode::_Internal {
 public:
  static const ::clojureRT::protobuf::Node& keyword(const KeywordInvokeNode* msg);
  static const ::clojureRT::protobuf::Node& target(const KeywordInvokeNode* msg);
};

const ::clojureRT::protobuf::Node&
KeywordInvokeNode::_Internal::keyword(const KeywordInvokeNode* msg) {
  return *msg->_impl_.keyword_;
}
const ::clojureRT::protobuf::Node&
KeywordInvokeNode::_Internal::target(const KeywordInvokeNode* msg) {
  return *msg->_impl_.target_;
}
KeywordInvokeNode::KeywordInvokeNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojureRT.protobuf.KeywordInvokeNode)
}
KeywordInvokeNode::KeywordInvokeNode(const KeywordInvokeNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  KeywordInvokeNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.keyword_){nullptr}
    , decltype(_impl_.target_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_keyword()) {
    _this->_impl_.keyword_ = new ::clojureRT::protobuf::Node(*from._impl_.keyword_);
  }
  if (from._internal_has_target()) {
    _this->_impl_.target_ = new ::clojureRT::protobuf::Node(*from._impl_.target_);
  }
  // @@protoc_insertion_point(copy_constructor:clojureRT.protobuf.KeywordInvokeNode)
}

inline void KeywordInvokeNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.keyword_){nullptr}
    , decltype(_impl_.target_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

KeywordInvokeNode::~KeywordInvokeNode() {
  // @@protoc_insertion_point(destructor:clojureRT.protobuf.KeywordInvokeNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KeywordInvokeNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.keyword_;
  if (this != internal_default_instance()) delete _impl_.target_;
}

void KeywordInvokeNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KeywordInvokeNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojureRT.protobuf.KeywordInvokeNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.keyword_ != nullptr) {
    delete _impl_.keyword_;
  }
  _impl_.keyword_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.target_ != nullptr) {
    delete _impl_.target_;
  }
  _impl_.target_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KeywordInvokeNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .clojureRT.protobuf.Node keyword = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_keyword(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.Node target = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_target(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KeywordInvokeNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojureRT.protobuf.KeywordInvokeNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .clojureRT.protobuf.Node keyword = 1;
  if (this->_internal_has_keyword()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::keyword(this),
        _Internal::keyword(this).GetCachedSize(), target, stream);
  }

  // .clojureRT.protobuf.Node target = 2;
  if (this->_internal_has_target()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::target(this),
        _Internal::target(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojureRT.protobuf.KeywordInvokeNode)
  return target;
}

size_t KeywordInvokeNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojureRT.protobuf.KeywordInvokeNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .clojureRT.protobuf.Node keyword = 1;
  if (this->_internal_has_keyword()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.keyword_);
  }

  // .clojureRT.protobuf.Node target = 2;
  if (this->_internal_has_target()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.target_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KeywordInvokeNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    KeywordInvokeNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KeywordInvokeNode::GetClassData() const { return &_class_data_; }


void KeywordInvokeNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<KeywordInvokeNode*>(&to_msg);
  auto& from = static_cast<const KeywordInvokeNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojureRT.protobuf.KeywordInvokeNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_keyword()) {
    _this->_internal_mutable_keyword()->::clojureRT::protobuf::Node::MergeFrom(
        from._internal_keyword());
  }
  if (from._internal_has_target()) {
    _this->_internal_mutable_target()->::clojureRT::protobuf::Node::MergeFrom(
        from._internal_target());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KeywordInvokeNode::CopyFrom(const KeywordInvokeNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojureRT.protobuf.KeywordInvokeNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KeywordInvokeNode::IsInitialized() const {
  return true;
}

void KeywordInvokeNode::InternalSwap(KeywordInvokeNode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KeywordInvokeNode, _impl_.target_)
      + sizeof(KeywordInvokeNode::_impl_.target_)
      - PROTOBUF_FIELD_OFFSET(KeywordInvokeNode, _impl_.keyword_)>(
          reinterpret_cast<char*>(&_impl_.keyword_),
          reinterpret_cast<char*>(&other->_impl_.keyword_));
}

::PROTOBUF_NAMESPACE_ID::Metadata KeywordInvokeNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[19]);
}

// ===================================================================

class LetNode::_Internal {
 public:
  static const ::clojureRT::protobuf::Node& body(const LetNode* msg);
};

const ::clojureRT::protobuf::Node&
LetNode::_Internal::body(const LetNode* msg) {
  return *msg->_impl_.body_;
}
LetNode::LetNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojureRT.protobuf.LetNode)
}
LetNode::LetNode(const LetNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LetNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.bindings_){from._impl_.bindings_}
    , decltype(_impl_.body_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_body()) {
    _this->_impl_.body_ = new ::clojureRT::protobuf::Node(*from._impl_.body_);
  }
  // @@protoc_insertion_point(copy_constructor:clojureRT.protobuf.LetNode)
}

inline void LetNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.bindings_){arena}
    , decltype(_impl_.body_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

LetNode::~LetNode() {
  // @@protoc_insertion_point(destructor:clojureRT.protobuf.LetNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LetNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.bindings_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.body_;
}

void LetNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LetNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojureRT.protobuf.LetNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.bindings_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.body_ != nullptr) {
    delete _impl_.body_;
  }
  _impl_.body_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LetNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .clojureRT.protobuf.Node bindings = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_bindings(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.Node body = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_body(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LetNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojureRT.protobuf.LetNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .clojureRT.protobuf.Node bindings = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_bindings_size()); i < n; i++) {
    const auto& repfield = this->_internal_bindings(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .clojureRT.protobuf.Node body = 2;
  if (this->_internal_has_body()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::body(this),
        _Internal::body(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojureRT.protobuf.LetNode)
  return target;
}

size_t LetNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojureRT.protobuf.LetNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .clojureRT.protobuf.Node bindings = 1;
  total_size += 1UL * this->_internal_bindings_size();
  for (const auto& msg : this->_impl_.bindings_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .clojureRT.protobuf.Node body = 2;
  if (this->_internal_has_body()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.body_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LetNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LetNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LetNode::GetClassData() const { return &_class_data_; }


void LetNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LetNode*>(&to_msg);
  auto& from = static_cast<const LetNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojureRT.protobuf.LetNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.bindings_.MergeFrom(from._impl_.bindings_);
  if (from._internal_has_body()) {
    _this->_internal_mutable_body()->::clojureRT::protobuf::Node::MergeFrom(
        from._internal_body());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LetNode::CopyFrom(const LetNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojureRT.protobuf.LetNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LetNode::IsInitialized() const {
  return true;
}

void LetNode::InternalSwap(LetNode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.bindings_.InternalSwap(&other->_impl_.bindings_);
  swap(_impl_.body_, other->_impl_.body_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LetNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[20]);
}

// ===================================================================

class LetfnNode::_Internal {
 public:
  static const ::clojureRT::protobuf::Node& body(const LetfnNode* msg);
};

const ::clojureRT::protobuf::Node&
LetfnNode::_Internal::body(const LetfnNode* msg) {
  return *msg->_impl_.body_;
}
LetfnNode::LetfnNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojureRT.protobuf.LetfnNode)
}
LetfnNode::LetfnNode(const LetfnNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LetfnNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.bindings_){from._impl_.bindings_}
    , decltype(_impl_.body_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_body()) {
    _this->_impl_.body_ = new ::clojureRT::protobuf::Node(*from._impl_.body_);
  }
  // @@protoc_insertion_point(copy_constructor:clojureRT.protobuf.LetfnNode)
}

inline void LetfnNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.bindings_){arena}
    , decltype(_impl_.body_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

LetfnNode::~LetfnNode() {
  // @@protoc_insertion_point(destructor:clojureRT.protobuf.LetfnNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LetfnNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.bindings_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.body_;
}

void LetfnNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LetfnNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojureRT.protobuf.LetfnNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.bindings_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.body_ != nullptr) {
    delete _impl_.body_;
  }
  _impl_.body_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LetfnNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .clojureRT.protobuf.Node bindings = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_bindings(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.Node body = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_body(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LetfnNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojureRT.protobuf.LetfnNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .clojureRT.protobuf.Node bindings = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_bindings_size()); i < n; i++) {
    const auto& repfield = this->_internal_bindings(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .clojureRT.protobuf.Node body = 2;
  if (this->_internal_has_body()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::body(this),
        _Internal::body(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojureRT.protobuf.LetfnNode)
  return target;
}

size_t LetfnNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojureRT.protobuf.LetfnNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .clojureRT.protobuf.Node bindings = 1;
  total_size += 1UL * this->_internal_bindings_size();
  for (const auto& msg : this->_impl_.bindings_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .clojureRT.protobuf.Node body = 2;
  if (this->_internal_has_body()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.body_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LetfnNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LetfnNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LetfnNode::GetClassData() const { return &_class_data_; }


void LetfnNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LetfnNode*>(&to_msg);
  auto& from = static_cast<const LetfnNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojureRT.protobuf.LetfnNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.bindings_.MergeFrom(from._impl_.bindings_);
  if (from._internal_has_body()) {
    _this->_internal_mutable_body()->::clojureRT::protobuf::Node::MergeFrom(
        from._internal_body());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LetfnNode::CopyFrom(const LetfnNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojureRT.protobuf.LetfnNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LetfnNode::IsInitialized() const {
  return true;
}

void LetfnNode::InternalSwap(LetfnNode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.bindings_.InternalSwap(&other->_impl_.bindings_);
  swap(_impl_.body_, other->_impl_.body_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LetfnNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[21]);
}

// ===================================================================

class LocalNode::_Internal {
 public:
  using HasBits = decltype(std::declval<LocalNode>()._impl_._has_bits_);
  static void set_has_argid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_isvariadic(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

LocalNode::LocalNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojureRT.protobuf.LocalNode)
}
LocalNode::LocalNode(const LocalNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LocalNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.argid_){}
    , decltype(_impl_.local_){}
    , decltype(_impl_.isassignable_){}
    , decltype(_impl_.isvariadic_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.argid_, &from._impl_.argid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.isvariadic_) -
    reinterpret_cast<char*>(&_impl_.argid_)) + sizeof(_impl_.isvariadic_));
  // @@protoc_insertion_point(copy_constructor:clojureRT.protobuf.LocalNode)
}

inline void LocalNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.argid_){0u}
    , decltype(_impl_.local_){0}
    , decltype(_impl_.isassignable_){false}
    , decltype(_impl_.isvariadic_){false}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LocalNode::~LocalNode() {
  // @@protoc_insertion_point(destructor:clojureRT.protobuf.LocalNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LocalNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void LocalNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LocalNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojureRT.protobuf.LocalNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _impl_.argid_ = 0u;
  ::memset(&_impl_.local_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.isassignable_) -
      reinterpret_cast<char*>(&_impl_.local_)) + sizeof(_impl_.isassignable_));
  _impl_.isvariadic_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LocalNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 argId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_argid(&has_bits);
          _impl_.argid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool isAssignable = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.isassignable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.LocalType local = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_local(static_cast<::clojureRT::protobuf::LocalType>(val));
        } else
          goto handle_unusual;
        continue;
      // string name = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojureRT.protobuf.LocalNode.name"));
        } else
          goto handle_unusual;
        continue;
      // optional bool isVariadic = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_isvariadic(&has_bits);
          _impl_.isvariadic_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LocalNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojureRT.protobuf.LocalNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional uint32 argId = 1;
  if (_internal_has_argid()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_argid(), target);
  }

  // bool isAssignable = 2;
  if (this->_internal_isassignable() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_isassignable(), target);
  }

  // .clojureRT.protobuf.LocalType local = 3;
  if (this->_internal_local() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_local(), target);
  }

  // string name = 4;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojureRT.protobuf.LocalNode.name");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_name(), target);
  }

  // optional bool isVariadic = 5;
  if (_internal_has_isvariadic()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_isvariadic(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojureRT.protobuf.LocalNode)
  return target;
}

size_t LocalNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojureRT.protobuf.LocalNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 4;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // optional uint32 argId = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_argid());
  }

  // .clojureRT.protobuf.LocalType local = 3;
  if (this->_internal_local() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_local());
  }

  // bool isAssignable = 2;
  if (this->_internal_isassignable() != 0) {
    total_size += 1 + 1;
  }

  // optional bool isVariadic = 5;
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LocalNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LocalNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LocalNode::GetClassData() const { return &_class_data_; }


void LocalNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LocalNode*>(&to_msg);
  auto& from = static_cast<const LocalNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojureRT.protobuf.LocalNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_has_argid()) {
    _this->_internal_set_argid(from._internal_argid());
  }
  if (from._internal_local() != 0) {
    _this->_internal_set_local(from._internal_local());
  }
  if (from._internal_isassignable() != 0) {
    _this->_internal_set_isassignable(from._internal_isassignable());
  }
  if (from._internal_has_isvariadic()) {
    _this->_internal_set_isvariadic(from._internal_isvariadic());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LocalNode::CopyFrom(const LocalNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojureRT.protobuf.LocalNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LocalNode::IsInitialized() const {
  return true;
}

void LocalNode::InternalSwap(LocalNode* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LocalNode, _impl_.isvariadic_)
      + sizeof(LocalNode::_impl_.isvariadic_)
      - PROTOBUF_FIELD_OFFSET(LocalNode, _impl_.argid_)>(
          reinterpret_cast<char*>(&_impl_.argid_),
          reinterpret_cast<char*>(&other->_impl_.argid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LocalNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[22]);
}

// ===================================================================

class LoopNode::_Internal {
 public:
  static const ::clojureRT::protobuf::Node& body(const LoopNode* msg);
};

const ::clojureRT::protobuf::Node&
LoopNode::_Internal::body(const LoopNode* msg) {
  return *msg->_impl_.body_;
}
LoopNode::LoopNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojureRT.protobuf.LoopNode)
}
LoopNode::LoopNode(const LoopNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LoopNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.bindings_){from._impl_.bindings_}
    , decltype(_impl_.loopid_){}
    , decltype(_impl_.body_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.loopid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.loopid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_loopid().empty()) {
    _this->_impl_.loopid_.Set(from._internal_loopid(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_body()) {
    _this->_impl_.body_ = new ::clojureRT::protobuf::Node(*from._impl_.body_);
  }
  // @@protoc_insertion_point(copy_constructor:clojureRT.protobuf.LoopNode)
}

inline void LoopNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.bindings_){arena}
    , decltype(_impl_.loopid_){}
    , decltype(_impl_.body_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.loopid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.loopid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LoopNode::~LoopNode() {
  // @@protoc_insertion_point(destructor:clojureRT.protobuf.LoopNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LoopNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.bindings_.~RepeatedPtrField();
  _impl_.loopid_.Destroy();
  if (this != internal_default_instance()) delete _impl_.body_;
}

void LoopNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LoopNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojureRT.protobuf.LoopNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.bindings_.Clear();
  _impl_.loopid_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.body_ != nullptr) {
    delete _impl_.body_;
  }
  _impl_.body_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LoopNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .clojureRT.protobuf.Node bindings = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_bindings(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.Node body = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_body(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string loopId = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_loopid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojureRT.protobuf.LoopNode.loopId"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LoopNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojureRT.protobuf.LoopNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .clojureRT.protobuf.Node bindings = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_bindings_size()); i < n; i++) {
    const auto& repfield = this->_internal_bindings(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .clojureRT.protobuf.Node body = 2;
  if (this->_internal_has_body()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::body(this),
        _Internal::body(this).GetCachedSize(), target, stream);
  }

  // string loopId = 3;
  if (!this->_internal_loopid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_loopid().data(), static_cast<int>(this->_internal_loopid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojureRT.protobuf.LoopNode.loopId");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_loopid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojureRT.protobuf.LoopNode)
  return target;
}

size_t LoopNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojureRT.protobuf.LoopNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .clojureRT.protobuf.Node bindings = 1;
  total_size += 1UL * this->_internal_bindings_size();
  for (const auto& msg : this->_impl_.bindings_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string loopId = 3;
  if (!this->_internal_loopid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_loopid());
  }

  // .clojureRT.protobuf.Node body = 2;
  if (this->_internal_has_body()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.body_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LoopNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LoopNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LoopNode::GetClassData() const { return &_class_data_; }


void LoopNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LoopNode*>(&to_msg);
  auto& from = static_cast<const LoopNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojureRT.protobuf.LoopNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.bindings_.MergeFrom(from._impl_.bindings_);
  if (!from._internal_loopid().empty()) {
    _this->_internal_set_loopid(from._internal_loopid());
  }
  if (from._internal_has_body()) {
    _this->_internal_mutable_body()->::clojureRT::protobuf::Node::MergeFrom(
        from._internal_body());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LoopNode::CopyFrom(const LoopNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojureRT.protobuf.LoopNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoopNode::IsInitialized() const {
  return true;
}

void LoopNode::InternalSwap(LoopNode* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.bindings_.InternalSwap(&other->_impl_.bindings_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.loopid_, lhs_arena,
      &other->_impl_.loopid_, rhs_arena
  );
  swap(_impl_.body_, other->_impl_.body_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LoopNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[23]);
}

// ===================================================================

class MapNode::_Internal {
 public:
};

MapNode::MapNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojureRT.protobuf.MapNode)
}
MapNode::MapNode(const MapNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MapNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.keys_){from._impl_.keys_}
    , decltype(_impl_.vals_){from._impl_.vals_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:clojureRT.protobuf.MapNode)
}

inline void MapNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.keys_){arena}
    , decltype(_impl_.vals_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

MapNode::~MapNode() {
  // @@protoc_insertion_point(destructor:clojureRT.protobuf.MapNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MapNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.keys_.~RepeatedPtrField();
  _impl_.vals_.~RepeatedPtrField();
}

void MapNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MapNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojureRT.protobuf.MapNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.keys_.Clear();
  _impl_.vals_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MapNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .clojureRT.protobuf.Node keys = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_keys(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .clojureRT.protobuf.Node vals = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_vals(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MapNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojureRT.protobuf.MapNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .clojureRT.protobuf.Node keys = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_keys_size()); i < n; i++) {
    const auto& repfield = this->_internal_keys(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .clojureRT.protobuf.Node vals = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_vals_size()); i < n; i++) {
    const auto& repfield = this->_internal_vals(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojureRT.protobuf.MapNode)
  return target;
}

size_t MapNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojureRT.protobuf.MapNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .clojureRT.protobuf.Node keys = 1;
  total_size += 1UL * this->_internal_keys_size();
  for (const auto& msg : this->_impl_.keys_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .clojureRT.protobuf.Node vals = 2;
  total_size += 1UL * this->_internal_vals_size();
  for (const auto& msg : this->_impl_.vals_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MapNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MapNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MapNode::GetClassData() const { return &_class_data_; }


void MapNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MapNode*>(&to_msg);
  auto& from = static_cast<const MapNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojureRT.protobuf.MapNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.keys_.MergeFrom(from._impl_.keys_);
  _this->_impl_.vals_.MergeFrom(from._impl_.vals_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MapNode::CopyFrom(const MapNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojureRT.protobuf.MapNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MapNode::IsInitialized() const {
  return true;
}

void MapNode::InternalSwap(MapNode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.keys_.InternalSwap(&other->_impl_.keys_);
  _impl_.vals_.InternalSwap(&other->_impl_.vals_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MapNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[24]);
}

// ===================================================================

class MethodNode::_Internal {
 public:
  static const ::clojureRT::protobuf::Node& body(const MethodNode* msg);
  static const ::clojureRT::protobuf::Node& this_(const MethodNode* msg);
};

const ::clojureRT::protobuf::Node&
MethodNode::_Internal::body(const MethodNode* msg) {
  return *msg->_impl_.body_;
}
const ::clojureRT::protobuf::Node&
MethodNode::_Internal::this_(const MethodNode* msg) {
  return *msg->_impl_.this__;
}
MethodNode::MethodNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojureRT.protobuf.MethodNode)
}
MethodNode::MethodNode(const MethodNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MethodNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.bridges_){from._impl_.bridges_}
    , decltype(_impl_.params_){from._impl_.params_}
    , decltype(_impl_.interface_){}
    , decltype(_impl_.loopid_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.body_){nullptr}
    , decltype(_impl_.this__){nullptr}
    , decltype(_impl_.fixedarity_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.interface_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.interface_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_interface().empty()) {
    _this->_impl_.interface_.Set(from._internal_interface(), 
      _this->GetArenaForAllocation());
  }
  _impl_.loopid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.loopid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_loopid().empty()) {
    _this->_impl_.loopid_.Set(from._internal_loopid(), 
      _this->GetArenaForAllocation());
  }
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_body()) {
    _this->_impl_.body_ = new ::clojureRT::protobuf::Node(*from._impl_.body_);
  }
  if (from._internal_has_this_()) {
    _this->_impl_.this__ = new ::clojureRT::protobuf::Node(*from._impl_.this__);
  }
  _this->_impl_.fixedarity_ = from._impl_.fixedarity_;
  // @@protoc_insertion_point(copy_constructor:clojureRT.protobuf.MethodNode)
}

inline void MethodNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.bridges_){arena}
    , decltype(_impl_.params_){arena}
    , decltype(_impl_.interface_){}
    , decltype(_impl_.loopid_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.body_){nullptr}
    , decltype(_impl_.this__){nullptr}
    , decltype(_impl_.fixedarity_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.interface_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.interface_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.loopid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.loopid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MethodNode::~MethodNode() {
  // @@protoc_insertion_point(destructor:clojureRT.protobuf.MethodNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MethodNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.bridges_.~RepeatedPtrField();
  _impl_.params_.~RepeatedPtrField();
  _impl_.interface_.Destroy();
  _impl_.loopid_.Destroy();
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.body_;
  if (this != internal_default_instance()) delete _impl_.this__;
}

void MethodNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MethodNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojureRT.protobuf.MethodNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.bridges_.Clear();
  _impl_.params_.Clear();
  _impl_.interface_.ClearToEmpty();
  _impl_.loopid_.ClearToEmpty();
  _impl_.name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.body_ != nullptr) {
    delete _impl_.body_;
  }
  _impl_.body_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.this__ != nullptr) {
    delete _impl_.this__;
  }
  _impl_.this__ = nullptr;
  _impl_.fixedarity_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MethodNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .clojureRT.protobuf.Node body = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_body(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string bridges = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_bridges();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "clojureRT.protobuf.MethodNode.bridges"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // uint32 fixedArity = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.fixedarity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string interface = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_interface();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojureRT.protobuf.MethodNode.interface"));
        } else
          goto handle_unusual;
        continue;
      // string loopId = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_loopid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojureRT.protobuf.MethodNode.loopId"));
        } else
          goto handle_unusual;
        continue;
      // string name = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojureRT.protobuf.MethodNode.name"));
        } else
          goto handle_unusual;
        continue;
      // repeated .clojureRT.protobuf.Node params = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_params(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.Node this = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_this_(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MethodNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojureRT.protobuf.MethodNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .clojureRT.protobuf.Node body = 1;
  if (this->_internal_has_body()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::body(this),
        _Internal::body(this).GetCachedSize(), target, stream);
  }

  // repeated string bridges = 2;
  for (int i = 0, n = this->_internal_bridges_size(); i < n; i++) {
    const auto& s = this->_internal_bridges(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojureRT.protobuf.MethodNode.bridges");
    target = stream->WriteString(2, s, target);
  }

  // uint32 fixedArity = 3;
  if (this->_internal_fixedarity() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_fixedarity(), target);
  }

  // string interface = 4;
  if (!this->_internal_interface().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_interface().data(), static_cast<int>(this->_internal_interface().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojureRT.protobuf.MethodNode.interface");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_interface(), target);
  }

  // string loopId = 5;
  if (!this->_internal_loopid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_loopid().data(), static_cast<int>(this->_internal_loopid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojureRT.protobuf.MethodNode.loopId");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_loopid(), target);
  }

  // string name = 6;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojureRT.protobuf.MethodNode.name");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_name(), target);
  }

  // repeated .clojureRT.protobuf.Node params = 7;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_params_size()); i < n; i++) {
    const auto& repfield = this->_internal_params(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .clojureRT.protobuf.Node this = 8;
  if (this->_internal_has_this_()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::this_(this),
        _Internal::this_(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojureRT.protobuf.MethodNode)
  return target;
}

size_t MethodNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojureRT.protobuf.MethodNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string bridges = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.bridges_.size());
  for (int i = 0, n = _impl_.bridges_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.bridges_.Get(i));
  }

  // repeated .clojureRT.protobuf.Node params = 7;
  total_size += 1UL * this->_internal_params_size();
  for (const auto& msg : this->_impl_.params_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string interface = 4;
  if (!this->_internal_interface().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_interface());
  }

  // string loopId = 5;
  if (!this->_internal_loopid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_loopid());
  }

  // string name = 6;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .clojureRT.protobuf.Node body = 1;
  if (this->_internal_has_body()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.body_);
  }

  // .clojureRT.protobuf.Node this = 8;
  if (this->_internal_has_this_()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.this__);
  }

  // uint32 fixedArity = 3;
  if (this->_internal_fixedarity() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_fixedarity());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MethodNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MethodNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MethodNode::GetClassData() const { return &_class_data_; }


void MethodNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MethodNode*>(&to_msg);
  auto& from = static_cast<const MethodNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojureRT.protobuf.MethodNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.bridges_.MergeFrom(from._impl_.bridges_);
  _this->_impl_.params_.MergeFrom(from._impl_.params_);
  if (!from._internal_interface().empty()) {
    _this->_internal_set_interface(from._internal_interface());
  }
  if (!from._internal_loopid().empty()) {
    _this->_internal_set_loopid(from._internal_loopid());
  }
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_has_body()) {
    _this->_internal_mutable_body()->::clojureRT::protobuf::Node::MergeFrom(
        from._internal_body());
  }
  if (from._internal_has_this_()) {
    _this->_internal_mutable_this_()->::clojureRT::protobuf::Node::MergeFrom(
        from._internal_this_());
  }
  if (from._internal_fixedarity() != 0) {
    _this->_internal_set_fixedarity(from._internal_fixedarity());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MethodNode::CopyFrom(const MethodNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojureRT.protobuf.MethodNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MethodNode::IsInitialized() const {
  return true;
}

void MethodNode::InternalSwap(MethodNode* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.bridges_.InternalSwap(&other->_impl_.bridges_);
  _impl_.params_.InternalSwap(&other->_impl_.params_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.interface_, lhs_arena,
      &other->_impl_.interface_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.loopid_, lhs_arena,
      &other->_impl_.loopid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MethodNode, _impl_.fixedarity_)
      + sizeof(MethodNode::_impl_.fixedarity_)
      - PROTOBUF_FIELD_OFFSET(MethodNode, _impl_.body_)>(
          reinterpret_cast<char*>(&_impl_.body_),
          reinterpret_cast<char*>(&other->_impl_.body_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MethodNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[25]);
}

// ===================================================================

class MonitorEnterNode::_Internal {
 public:
  static const ::clojureRT::protobuf::Node& target(const MonitorEnterNode* msg);
};

const ::clojureRT::protobuf::Node&
MonitorEnterNode::_Internal::target(const MonitorEnterNode* msg) {
  return *msg->_impl_.target_;
}
MonitorEnterNode::MonitorEnterNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojureRT.protobuf.MonitorEnterNode)
}
MonitorEnterNode::MonitorEnterNode(const MonitorEnterNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MonitorEnterNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.target_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_target()) {
    _this->_impl_.target_ = new ::clojureRT::protobuf::Node(*from._impl_.target_);
  }
  // @@protoc_insertion_point(copy_constructor:clojureRT.protobuf.MonitorEnterNode)
}

inline void MonitorEnterNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.target_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

MonitorEnterNode::~MonitorEnterNode() {
  // @@protoc_insertion_point(destructor:clojureRT.protobuf.MonitorEnterNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MonitorEnterNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.target_;
}

void MonitorEnterNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MonitorEnterNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojureRT.protobuf.MonitorEnterNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.target_ != nullptr) {
    delete _impl_.target_;
  }
  _impl_.target_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MonitorEnterNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .clojureRT.protobuf.Node target = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_target(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MonitorEnterNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojureRT.protobuf.MonitorEnterNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .clojureRT.protobuf.Node target = 1;
  if (this->_internal_has_target()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::target(this),
        _Internal::target(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojureRT.protobuf.MonitorEnterNode)
  return target;
}

size_t MonitorEnterNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojureRT.protobuf.MonitorEnterNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .clojureRT.protobuf.Node target = 1;
  if (this->_internal_has_target()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.target_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MonitorEnterNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MonitorEnterNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MonitorEnterNode::GetClassData() const { return &_class_data_; }


void MonitorEnterNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MonitorEnterNode*>(&to_msg);
  auto& from = static_cast<const MonitorEnterNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojureRT.protobuf.MonitorEnterNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_target()) {
    _this->_internal_mutable_target()->::clojureRT::protobuf::Node::MergeFrom(
        from._internal_target());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MonitorEnterNode::CopyFrom(const MonitorEnterNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojureRT.protobuf.MonitorEnterNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MonitorEnterNode::IsInitialized() const {
  return true;
}

void MonitorEnterNode::InternalSwap(MonitorEnterNode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.target_, other->_impl_.target_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MonitorEnterNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[26]);
}

// ===================================================================

class MonitorExitNode::_Internal {
 public:
  static const ::clojureRT::protobuf::Node& target(const MonitorExitNode* msg);
};

const ::clojureRT::protobuf::Node&
MonitorExitNode::_Internal::target(const MonitorExitNode* msg) {
  return *msg->_impl_.target_;
}
MonitorExitNode::MonitorExitNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojureRT.protobuf.MonitorExitNode)
}
MonitorExitNode::MonitorExitNode(const MonitorExitNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MonitorExitNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.target_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_target()) {
    _this->_impl_.target_ = new ::clojureRT::protobuf::Node(*from._impl_.target_);
  }
  // @@protoc_insertion_point(copy_constructor:clojureRT.protobuf.MonitorExitNode)
}

inline void MonitorExitNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.target_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

MonitorExitNode::~MonitorExitNode() {
  // @@protoc_insertion_point(destructor:clojureRT.protobuf.MonitorExitNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MonitorExitNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.target_;
}

void MonitorExitNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MonitorExitNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojureRT.protobuf.MonitorExitNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.target_ != nullptr) {
    delete _impl_.target_;
  }
  _impl_.target_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MonitorExitNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .clojureRT.protobuf.Node target = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_target(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MonitorExitNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojureRT.protobuf.MonitorExitNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .clojureRT.protobuf.Node target = 1;
  if (this->_internal_has_target()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::target(this),
        _Internal::target(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojureRT.protobuf.MonitorExitNode)
  return target;
}

size_t MonitorExitNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojureRT.protobuf.MonitorExitNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .clojureRT.protobuf.Node target = 1;
  if (this->_internal_has_target()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.target_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MonitorExitNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MonitorExitNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MonitorExitNode::GetClassData() const { return &_class_data_; }


void MonitorExitNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MonitorExitNode*>(&to_msg);
  auto& from = static_cast<const MonitorExitNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojureRT.protobuf.MonitorExitNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_target()) {
    _this->_internal_mutable_target()->::clojureRT::protobuf::Node::MergeFrom(
        from._internal_target());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MonitorExitNode::CopyFrom(const MonitorExitNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojureRT.protobuf.MonitorExitNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MonitorExitNode::IsInitialized() const {
  return true;
}

void MonitorExitNode::InternalSwap(MonitorExitNode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.target_, other->_impl_.target_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MonitorExitNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[27]);
}

// ===================================================================

class NewNode::_Internal {
 public:
  using HasBits = decltype(std::declval<NewNode>()._impl_._has_bits_);
  static const ::clojureRT::protobuf::Node& class_(const NewNode* msg);
  static void set_has_isvalidated(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::clojureRT::protobuf::Node&
NewNode::_Internal::class_(const NewNode* msg) {
  return *msg->_impl_.class__;
}
NewNode::NewNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojureRT.protobuf.NewNode)
}
NewNode::NewNode(const NewNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NewNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.args_){from._impl_.args_}
    , decltype(_impl_.class__){nullptr}
    , decltype(_impl_.isvalidated_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_class_()) {
    _this->_impl_.class__ = new ::clojureRT::protobuf::Node(*from._impl_.class__);
  }
  _this->_impl_.isvalidated_ = from._impl_.isvalidated_;
  // @@protoc_insertion_point(copy_constructor:clojureRT.protobuf.NewNode)
}

inline void NewNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.args_){arena}
    , decltype(_impl_.class__){nullptr}
    , decltype(_impl_.isvalidated_){false}
  };
}

NewNode::~NewNode() {
  // @@protoc_insertion_point(destructor:clojureRT.protobuf.NewNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NewNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.args_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.class__;
}

void NewNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NewNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojureRT.protobuf.NewNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.args_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.class__ != nullptr) {
    delete _impl_.class__;
  }
  _impl_.class__ = nullptr;
  _impl_.isvalidated_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NewNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .clojureRT.protobuf.Node args = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_args(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.Node class = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_class_(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool isValidated = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_isvalidated(&has_bits);
          _impl_.isvalidated_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NewNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojureRT.protobuf.NewNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .clojureRT.protobuf.Node args = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_args_size()); i < n; i++) {
    const auto& repfield = this->_internal_args(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .clojureRT.protobuf.Node class = 2;
  if (this->_internal_has_class_()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::class_(this),
        _Internal::class_(this).GetCachedSize(), target, stream);
  }

  // optional bool isValidated = 3;
  if (_internal_has_isvalidated()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_isvalidated(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojureRT.protobuf.NewNode)
  return target;
}

size_t NewNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojureRT.protobuf.NewNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .clojureRT.protobuf.Node args = 1;
  total_size += 1UL * this->_internal_args_size();
  for (const auto& msg : this->_impl_.args_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .clojureRT.protobuf.Node class = 2;
  if (this->_internal_has_class_()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.class__);
  }

  // optional bool isValidated = 3;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NewNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NewNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NewNode::GetClassData() const { return &_class_data_; }


void NewNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NewNode*>(&to_msg);
  auto& from = static_cast<const NewNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojureRT.protobuf.NewNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.args_.MergeFrom(from._impl_.args_);
  if (from._internal_has_class_()) {
    _this->_internal_mutable_class_()->::clojureRT::protobuf::Node::MergeFrom(
        from._internal_class_());
  }
  if (from._internal_has_isvalidated()) {
    _this->_internal_set_isvalidated(from._internal_isvalidated());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NewNode::CopyFrom(const NewNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojureRT.protobuf.NewNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NewNode::IsInitialized() const {
  return true;
}

void NewNode::InternalSwap(NewNode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.args_.InternalSwap(&other->_impl_.args_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NewNode, _impl_.isvalidated_)
      + sizeof(NewNode::_impl_.isvalidated_)
      - PROTOBUF_FIELD_OFFSET(NewNode, _impl_.class__)>(
          reinterpret_cast<char*>(&_impl_.class__),
          reinterpret_cast<char*>(&other->_impl_.class__));
}

::PROTOBUF_NAMESPACE_ID::Metadata NewNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[28]);
}

// ===================================================================

class PrimInvokeNode::_Internal {
 public:
  using HasBits = decltype(std::declval<PrimInvokeNode>()._impl_._has_bits_);
  static const ::clojureRT::protobuf::Node& fn(const PrimInvokeNode* msg);
  static void set_has_meta(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::clojureRT::protobuf::Node&
PrimInvokeNode::_Internal::fn(const PrimInvokeNode* msg) {
  return *msg->_impl_.fn_;
}
PrimInvokeNode::PrimInvokeNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojureRT.protobuf.PrimInvokeNode)
}
PrimInvokeNode::PrimInvokeNode(const PrimInvokeNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PrimInvokeNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.args_){from._impl_.args_}
    , decltype(_impl_.meta_){}
    , decltype(_impl_.priminterface_){}
    , decltype(_impl_.fn_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.meta_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.meta_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_meta()) {
    _this->_impl_.meta_.Set(from._internal_meta(), 
      _this->GetArenaForAllocation());
  }
  _impl_.priminterface_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.priminterface_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_priminterface().empty()) {
    _this->_impl_.priminterface_.Set(from._internal_priminterface(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_fn()) {
    _this->_impl_.fn_ = new ::clojureRT::protobuf::Node(*from._impl_.fn_);
  }
  // @@protoc_insertion_point(copy_constructor:clojureRT.protobuf.PrimInvokeNode)
}

inline void PrimInvokeNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.args_){arena}
    , decltype(_impl_.meta_){}
    , decltype(_impl_.priminterface_){}
    , decltype(_impl_.fn_){nullptr}
  };
  _impl_.meta_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.meta_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.priminterface_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.priminterface_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PrimInvokeNode::~PrimInvokeNode() {
  // @@protoc_insertion_point(destructor:clojureRT.protobuf.PrimInvokeNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PrimInvokeNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.args_.~RepeatedPtrField();
  _impl_.meta_.Destroy();
  _impl_.priminterface_.Destroy();
  if (this != internal_default_instance()) delete _impl_.fn_;
}

void PrimInvokeNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PrimInvokeNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojureRT.protobuf.PrimInvokeNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.args_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.meta_.ClearNonDefaultToEmpty();
  }
  _impl_.priminterface_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.fn_ != nullptr) {
    delete _impl_.fn_;
  }
  _impl_.fn_ = nullptr;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PrimInvokeNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .clojureRT.protobuf.Node args = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_args(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.Node fn = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_fn(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string meta = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_meta();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojureRT.protobuf.PrimInvokeNode.meta"));
        } else
          goto handle_unusual;
        continue;
      // string primInterface = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_priminterface();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojureRT.protobuf.PrimInvokeNode.primInterface"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PrimInvokeNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojureRT.protobuf.PrimInvokeNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .clojureRT.protobuf.Node args = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_args_size()); i < n; i++) {
    const auto& repfield = this->_internal_args(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .clojureRT.protobuf.Node fn = 2;
  if (this->_internal_has_fn()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::fn(this),
        _Internal::fn(this).GetCachedSize(), target, stream);
  }

  // optional string meta = 3;
  if (_internal_has_meta()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_meta().data(), static_cast<int>(this->_internal_meta().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojureRT.protobuf.PrimInvokeNode.meta");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_meta(), target);
  }

  // string primInterface = 4;
  if (!this->_internal_priminterface().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_priminterface().data(), static_cast<int>(this->_internal_priminterface().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojureRT.protobuf.PrimInvokeNode.primInterface");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_priminterface(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojureRT.protobuf.PrimInvokeNode)
  return target;
}

size_t PrimInvokeNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojureRT.protobuf.PrimInvokeNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .clojureRT.protobuf.Node args = 1;
  total_size += 1UL * this->_internal_args_size();
  for (const auto& msg : this->_impl_.args_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional string meta = 3;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_meta());
  }

  // string primInterface = 4;
  if (!this->_internal_priminterface().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_priminterface());
  }

  // .clojureRT.protobuf.Node fn = 2;
  if (this->_internal_has_fn()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.fn_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PrimInvokeNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PrimInvokeNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PrimInvokeNode::GetClassData() const { return &_class_data_; }


void PrimInvokeNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PrimInvokeNode*>(&to_msg);
  auto& from = static_cast<const PrimInvokeNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojureRT.protobuf.PrimInvokeNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.args_.MergeFrom(from._impl_.args_);
  if (from._internal_has_meta()) {
    _this->_internal_set_meta(from._internal_meta());
  }
  if (!from._internal_priminterface().empty()) {
    _this->_internal_set_priminterface(from._internal_priminterface());
  }
  if (from._internal_has_fn()) {
    _this->_internal_mutable_fn()->::clojureRT::protobuf::Node::MergeFrom(
        from._internal_fn());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PrimInvokeNode::CopyFrom(const PrimInvokeNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojureRT.protobuf.PrimInvokeNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PrimInvokeNode::IsInitialized() const {
  return true;
}

void PrimInvokeNode::InternalSwap(PrimInvokeNode* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.args_.InternalSwap(&other->_impl_.args_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.meta_, lhs_arena,
      &other->_impl_.meta_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.priminterface_, lhs_arena,
      &other->_impl_.priminterface_, rhs_arena
  );
  swap(_impl_.fn_, other->_impl_.fn_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PrimInvokeNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[29]);
}

// ===================================================================

class ProtocolInvokeNode::_Internal {
 public:
  static const ::clojureRT::protobuf::Node& protocolfn(const ProtocolInvokeNode* msg);
  static const ::clojureRT::protobuf::Node& target(const ProtocolInvokeNode* msg);
};

const ::clojureRT::protobuf::Node&
ProtocolInvokeNode::_Internal::protocolfn(const ProtocolInvokeNode* msg) {
  return *msg->_impl_.protocolfn_;
}
const ::clojureRT::protobuf::Node&
ProtocolInvokeNode::_Internal::target(const ProtocolInvokeNode* msg) {
  return *msg->_impl_.target_;
}
ProtocolInvokeNode::ProtocolInvokeNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojureRT.protobuf.ProtocolInvokeNode)
}
ProtocolInvokeNode::ProtocolInvokeNode(const ProtocolInvokeNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ProtocolInvokeNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.args_){from._impl_.args_}
    , decltype(_impl_.protocolfn_){nullptr}
    , decltype(_impl_.target_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_protocolfn()) {
    _this->_impl_.protocolfn_ = new ::clojureRT::protobuf::Node(*from._impl_.protocolfn_);
  }
  if (from._internal_has_target()) {
    _this->_impl_.target_ = new ::clojureRT::protobuf::Node(*from._impl_.target_);
  }
  // @@protoc_insertion_point(copy_constructor:clojureRT.protobuf.ProtocolInvokeNode)
}

inline void ProtocolInvokeNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.args_){arena}
    , decltype(_impl_.protocolfn_){nullptr}
    , decltype(_impl_.target_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ProtocolInvokeNode::~ProtocolInvokeNode() {
  // @@protoc_insertion_point(destructor:clojureRT.protobuf.ProtocolInvokeNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ProtocolInvokeNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.args_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.protocolfn_;
  if (this != internal_default_instance()) delete _impl_.target_;
}

void ProtocolInvokeNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ProtocolInvokeNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojureRT.protobuf.ProtocolInvokeNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.args_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.protocolfn_ != nullptr) {
    delete _impl_.protocolfn_;
  }
  _impl_.protocolfn_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.target_ != nullptr) {
    delete _impl_.target_;
  }
  _impl_.target_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ProtocolInvokeNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .clojureRT.protobuf.Node args = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_args(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.Node protocolFn = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_protocolfn(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.Node target = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_target(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ProtocolInvokeNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojureRT.protobuf.ProtocolInvokeNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .clojureRT.protobuf.Node args = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_args_size()); i < n; i++) {
    const auto& repfield = this->_internal_args(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .clojureRT.protobuf.Node protocolFn = 2;
  if (this->_internal_has_protocolfn()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::protocolfn(this),
        _Internal::protocolfn(this).GetCachedSize(), target, stream);
  }

  // .clojureRT.protobuf.Node target = 3;
  if (this->_internal_has_target()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::target(this),
        _Internal::target(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojureRT.protobuf.ProtocolInvokeNode)
  return target;
}

size_t ProtocolInvokeNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojureRT.protobuf.ProtocolInvokeNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .clojureRT.protobuf.Node args = 1;
  total_size += 1UL * this->_internal_args_size();
  for (const auto& msg : this->_impl_.args_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .clojureRT.protobuf.Node protocolFn = 2;
  if (this->_internal_has_protocolfn()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.protocolfn_);
  }

  // .clojureRT.protobuf.Node target = 3;
  if (this->_internal_has_target()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.target_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ProtocolInvokeNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ProtocolInvokeNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ProtocolInvokeNode::GetClassData() const { return &_class_data_; }


void ProtocolInvokeNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ProtocolInvokeNode*>(&to_msg);
  auto& from = static_cast<const ProtocolInvokeNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojureRT.protobuf.ProtocolInvokeNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.args_.MergeFrom(from._impl_.args_);
  if (from._internal_has_protocolfn()) {
    _this->_internal_mutable_protocolfn()->::clojureRT::protobuf::Node::MergeFrom(
        from._internal_protocolfn());
  }
  if (from._internal_has_target()) {
    _this->_internal_mutable_target()->::clojureRT::protobuf::Node::MergeFrom(
        from._internal_target());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ProtocolInvokeNode::CopyFrom(const ProtocolInvokeNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojureRT.protobuf.ProtocolInvokeNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProtocolInvokeNode::IsInitialized() const {
  return true;
}

void ProtocolInvokeNode::InternalSwap(ProtocolInvokeNode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.args_.InternalSwap(&other->_impl_.args_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ProtocolInvokeNode, _impl_.target_)
      + sizeof(ProtocolInvokeNode::_impl_.target_)
      - PROTOBUF_FIELD_OFFSET(ProtocolInvokeNode, _impl_.protocolfn_)>(
          reinterpret_cast<char*>(&_impl_.protocolfn_),
          reinterpret_cast<char*>(&other->_impl_.protocolfn_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ProtocolInvokeNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[30]);
}

// ===================================================================

class QuoteNode::_Internal {
 public:
  static const ::clojureRT::protobuf::Node& expr(const QuoteNode* msg);
};

const ::clojureRT::protobuf::Node&
QuoteNode::_Internal::expr(const QuoteNode* msg) {
  return *msg->_impl_.expr_;
}
QuoteNode::QuoteNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojureRT.protobuf.QuoteNode)
}
QuoteNode::QuoteNode(const QuoteNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  QuoteNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.expr_){nullptr}
    , decltype(_impl_.isliteral_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_expr()) {
    _this->_impl_.expr_ = new ::clojureRT::protobuf::Node(*from._impl_.expr_);
  }
  _this->_impl_.isliteral_ = from._impl_.isliteral_;
  // @@protoc_insertion_point(copy_constructor:clojureRT.protobuf.QuoteNode)
}

inline void QuoteNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.expr_){nullptr}
    , decltype(_impl_.isliteral_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

QuoteNode::~QuoteNode() {
  // @@protoc_insertion_point(destructor:clojureRT.protobuf.QuoteNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void QuoteNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.expr_;
}

void QuoteNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void QuoteNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojureRT.protobuf.QuoteNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.expr_ != nullptr) {
    delete _impl_.expr_;
  }
  _impl_.expr_ = nullptr;
  _impl_.isliteral_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* QuoteNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .clojureRT.protobuf.Node expr = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_expr(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool isLiteral = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.isliteral_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* QuoteNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojureRT.protobuf.QuoteNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .clojureRT.protobuf.Node expr = 1;
  if (this->_internal_has_expr()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::expr(this),
        _Internal::expr(this).GetCachedSize(), target, stream);
  }

  // bool isLiteral = 2;
  if (this->_internal_isliteral() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_isliteral(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojureRT.protobuf.QuoteNode)
  return target;
}

size_t QuoteNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojureRT.protobuf.QuoteNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .clojureRT.protobuf.Node expr = 1;
  if (this->_internal_has_expr()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.expr_);
  }

  // bool isLiteral = 2;
  if (this->_internal_isliteral() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData QuoteNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    QuoteNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*QuoteNode::GetClassData() const { return &_class_data_; }


void QuoteNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<QuoteNode*>(&to_msg);
  auto& from = static_cast<const QuoteNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojureRT.protobuf.QuoteNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_expr()) {
    _this->_internal_mutable_expr()->::clojureRT::protobuf::Node::MergeFrom(
        from._internal_expr());
  }
  if (from._internal_isliteral() != 0) {
    _this->_internal_set_isliteral(from._internal_isliteral());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void QuoteNode::CopyFrom(const QuoteNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojureRT.protobuf.QuoteNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool QuoteNode::IsInitialized() const {
  return true;
}

void QuoteNode::InternalSwap(QuoteNode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(QuoteNode, _impl_.isliteral_)
      + sizeof(QuoteNode::_impl_.isliteral_)
      - PROTOBUF_FIELD_OFFSET(QuoteNode, _impl_.expr_)>(
          reinterpret_cast<char*>(&_impl_.expr_),
          reinterpret_cast<char*>(&other->_impl_.expr_));
}

::PROTOBUF_NAMESPACE_ID::Metadata QuoteNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[31]);
}

// ===================================================================

class RecurNode::_Internal {
 public:
};

RecurNode::RecurNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojureRT.protobuf.RecurNode)
}
RecurNode::RecurNode(const RecurNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RecurNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.exprs_){from._impl_.exprs_}
    , decltype(_impl_.loopid_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.loopid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.loopid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_loopid().empty()) {
    _this->_impl_.loopid_.Set(from._internal_loopid(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:clojureRT.protobuf.RecurNode)
}

inline void RecurNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.exprs_){arena}
    , decltype(_impl_.loopid_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.loopid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.loopid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RecurNode::~RecurNode() {
  // @@protoc_insertion_point(destructor:clojureRT.protobuf.RecurNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RecurNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.exprs_.~RepeatedPtrField();
  _impl_.loopid_.Destroy();
}

void RecurNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RecurNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojureRT.protobuf.RecurNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.exprs_.Clear();
  _impl_.loopid_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RecurNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .clojureRT.protobuf.Node exprs = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_exprs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string loopId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_loopid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojureRT.protobuf.RecurNode.loopId"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RecurNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojureRT.protobuf.RecurNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .clojureRT.protobuf.Node exprs = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_exprs_size()); i < n; i++) {
    const auto& repfield = this->_internal_exprs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // string loopId = 2;
  if (!this->_internal_loopid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_loopid().data(), static_cast<int>(this->_internal_loopid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojureRT.protobuf.RecurNode.loopId");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_loopid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojureRT.protobuf.RecurNode)
  return target;
}

size_t RecurNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojureRT.protobuf.RecurNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .clojureRT.protobuf.Node exprs = 1;
  total_size += 1UL * this->_internal_exprs_size();
  for (const auto& msg : this->_impl_.exprs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string loopId = 2;
  if (!this->_internal_loopid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_loopid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RecurNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RecurNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RecurNode::GetClassData() const { return &_class_data_; }


void RecurNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RecurNode*>(&to_msg);
  auto& from = static_cast<const RecurNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojureRT.protobuf.RecurNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.exprs_.MergeFrom(from._impl_.exprs_);
  if (!from._internal_loopid().empty()) {
    _this->_internal_set_loopid(from._internal_loopid());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RecurNode::CopyFrom(const RecurNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojureRT.protobuf.RecurNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RecurNode::IsInitialized() const {
  return true;
}

void RecurNode::InternalSwap(RecurNode* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.exprs_.InternalSwap(&other->_impl_.exprs_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.loopid_, lhs_arena,
      &other->_impl_.loopid_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata RecurNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[32]);
}

// ===================================================================

class ReifyNode::_Internal {
 public:
};

ReifyNode::ReifyNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojureRT.protobuf.ReifyNode)
}
ReifyNode::ReifyNode(const ReifyNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReifyNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.interfaces_){from._impl_.interfaces_}
    , decltype(_impl_.methods_){from._impl_.methods_}
    , decltype(_impl_.classname_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.classname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.classname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_classname().empty()) {
    _this->_impl_.classname_.Set(from._internal_classname(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:clojureRT.protobuf.ReifyNode)
}

inline void ReifyNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.interfaces_){arena}
    , decltype(_impl_.methods_){arena}
    , decltype(_impl_.classname_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.classname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.classname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ReifyNode::~ReifyNode() {
  // @@protoc_insertion_point(destructor:clojureRT.protobuf.ReifyNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReifyNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.interfaces_.~RepeatedPtrField();
  _impl_.methods_.~RepeatedPtrField();
  _impl_.classname_.Destroy();
}

void ReifyNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReifyNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojureRT.protobuf.ReifyNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.interfaces_.Clear();
  _impl_.methods_.Clear();
  _impl_.classname_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReifyNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string className = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_classname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojureRT.protobuf.ReifyNode.className"));
        } else
          goto handle_unusual;
        continue;
      // repeated string interfaces = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_interfaces();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "clojureRT.protobuf.ReifyNode.interfaces"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .clojureRT.protobuf.Node methods = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_methods(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReifyNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojureRT.protobuf.ReifyNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string className = 1;
  if (!this->_internal_classname().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_classname().data(), static_cast<int>(this->_internal_classname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojureRT.protobuf.ReifyNode.className");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_classname(), target);
  }

  // repeated string interfaces = 2;
  for (int i = 0, n = this->_internal_interfaces_size(); i < n; i++) {
    const auto& s = this->_internal_interfaces(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojureRT.protobuf.ReifyNode.interfaces");
    target = stream->WriteString(2, s, target);
  }

  // repeated .clojureRT.protobuf.Node methods = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_methods_size()); i < n; i++) {
    const auto& repfield = this->_internal_methods(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojureRT.protobuf.ReifyNode)
  return target;
}

size_t ReifyNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojureRT.protobuf.ReifyNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string interfaces = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.interfaces_.size());
  for (int i = 0, n = _impl_.interfaces_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.interfaces_.Get(i));
  }

  // repeated .clojureRT.protobuf.Node methods = 3;
  total_size += 1UL * this->_internal_methods_size();
  for (const auto& msg : this->_impl_.methods_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string className = 1;
  if (!this->_internal_classname().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_classname());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReifyNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReifyNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReifyNode::GetClassData() const { return &_class_data_; }


void ReifyNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReifyNode*>(&to_msg);
  auto& from = static_cast<const ReifyNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojureRT.protobuf.ReifyNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.interfaces_.MergeFrom(from._impl_.interfaces_);
  _this->_impl_.methods_.MergeFrom(from._impl_.methods_);
  if (!from._internal_classname().empty()) {
    _this->_internal_set_classname(from._internal_classname());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReifyNode::CopyFrom(const ReifyNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojureRT.protobuf.ReifyNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReifyNode::IsInitialized() const {
  return true;
}

void ReifyNode::InternalSwap(ReifyNode* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.interfaces_.InternalSwap(&other->_impl_.interfaces_);
  _impl_.methods_.InternalSwap(&other->_impl_.methods_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.classname_, lhs_arena,
      &other->_impl_.classname_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ReifyNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[33]);
}

// ===================================================================

class SetNode::_Internal {
 public:
};

SetNode::SetNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojureRT.protobuf.SetNode)
}
SetNode::SetNode(const SetNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SetNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.items_){from._impl_.items_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:clojureRT.protobuf.SetNode)
}

inline void SetNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.items_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SetNode::~SetNode() {
  // @@protoc_insertion_point(destructor:clojureRT.protobuf.SetNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SetNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.items_.~RepeatedPtrField();
}

void SetNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SetNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojureRT.protobuf.SetNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.items_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SetNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .clojureRT.protobuf.Node items = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_items(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SetNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojureRT.protobuf.SetNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .clojureRT.protobuf.Node items = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_items_size()); i < n; i++) {
    const auto& repfield = this->_internal_items(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojureRT.protobuf.SetNode)
  return target;
}

size_t SetNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojureRT.protobuf.SetNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .clojureRT.protobuf.Node items = 1;
  total_size += 1UL * this->_internal_items_size();
  for (const auto& msg : this->_impl_.items_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SetNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SetNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SetNode::GetClassData() const { return &_class_data_; }


void SetNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SetNode*>(&to_msg);
  auto& from = static_cast<const SetNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojureRT.protobuf.SetNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.items_.MergeFrom(from._impl_.items_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SetNode::CopyFrom(const SetNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojureRT.protobuf.SetNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetNode::IsInitialized() const {
  return true;
}

void SetNode::InternalSwap(SetNode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.items_.InternalSwap(&other->_impl_.items_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SetNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[34]);
}

// ===================================================================

class MutateSetNode::_Internal {
 public:
  static const ::clojureRT::protobuf::Node& target(const MutateSetNode* msg);
  static const ::clojureRT::protobuf::Node& val(const MutateSetNode* msg);
};

const ::clojureRT::protobuf::Node&
MutateSetNode::_Internal::target(const MutateSetNode* msg) {
  return *msg->_impl_.target_;
}
const ::clojureRT::protobuf::Node&
MutateSetNode::_Internal::val(const MutateSetNode* msg) {
  return *msg->_impl_.val_;
}
MutateSetNode::MutateSetNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojureRT.protobuf.MutateSetNode)
}
MutateSetNode::MutateSetNode(const MutateSetNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MutateSetNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.target_){nullptr}
    , decltype(_impl_.val_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_target()) {
    _this->_impl_.target_ = new ::clojureRT::protobuf::Node(*from._impl_.target_);
  }
  if (from._internal_has_val()) {
    _this->_impl_.val_ = new ::clojureRT::protobuf::Node(*from._impl_.val_);
  }
  // @@protoc_insertion_point(copy_constructor:clojureRT.protobuf.MutateSetNode)
}

inline void MutateSetNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.target_){nullptr}
    , decltype(_impl_.val_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

MutateSetNode::~MutateSetNode() {
  // @@protoc_insertion_point(destructor:clojureRT.protobuf.MutateSetNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MutateSetNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.target_;
  if (this != internal_default_instance()) delete _impl_.val_;
}

void MutateSetNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MutateSetNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojureRT.protobuf.MutateSetNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.target_ != nullptr) {
    delete _impl_.target_;
  }
  _impl_.target_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.val_ != nullptr) {
    delete _impl_.val_;
  }
  _impl_.val_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MutateSetNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .clojureRT.protobuf.Node target = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_target(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.Node val = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_val(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MutateSetNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojureRT.protobuf.MutateSetNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .clojureRT.protobuf.Node target = 1;
  if (this->_internal_has_target()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::target(this),
        _Internal::target(this).GetCachedSize(), target, stream);
  }

  // .clojureRT.protobuf.Node val = 2;
  if (this->_internal_has_val()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::val(this),
        _Internal::val(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojureRT.protobuf.MutateSetNode)
  return target;
}

size_t MutateSetNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojureRT.protobuf.MutateSetNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .clojureRT.protobuf.Node target = 1;
  if (this->_internal_has_target()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.target_);
  }

  // .clojureRT.protobuf.Node val = 2;
  if (this->_internal_has_val()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.val_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MutateSetNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MutateSetNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MutateSetNode::GetClassData() const { return &_class_data_; }


void MutateSetNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MutateSetNode*>(&to_msg);
  auto& from = static_cast<const MutateSetNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojureRT.protobuf.MutateSetNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_target()) {
    _this->_internal_mutable_target()->::clojureRT::protobuf::Node::MergeFrom(
        from._internal_target());
  }
  if (from._internal_has_val()) {
    _this->_internal_mutable_val()->::clojureRT::protobuf::Node::MergeFrom(
        from._internal_val());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MutateSetNode::CopyFrom(const MutateSetNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojureRT.protobuf.MutateSetNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MutateSetNode::IsInitialized() const {
  return true;
}

void MutateSetNode::InternalSwap(MutateSetNode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MutateSetNode, _impl_.val_)
      + sizeof(MutateSetNode::_impl_.val_)
      - PROTOBUF_FIELD_OFFSET(MutateSetNode, _impl_.target_)>(
          reinterpret_cast<char*>(&_impl_.target_),
          reinterpret_cast<char*>(&other->_impl_.target_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MutateSetNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[35]);
}

// ===================================================================

class StaticCallNode::_Internal {
 public:
  using HasBits = decltype(std::declval<StaticCallNode>()._impl_._has_bits_);
  static void set_has_isvalidated(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

StaticCallNode::StaticCallNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojureRT.protobuf.StaticCallNode)
}
StaticCallNode::StaticCallNode(const StaticCallNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StaticCallNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.args_){from._impl_.args_}
    , decltype(_impl_.class__){}
    , decltype(_impl_.method_){}
    , decltype(_impl_.isvalidated_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.class__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.class__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_class_().empty()) {
    _this->_impl_.class__.Set(from._internal_class_(), 
      _this->GetArenaForAllocation());
  }
  _impl_.method_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.method_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_method().empty()) {
    _this->_impl_.method_.Set(from._internal_method(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.isvalidated_ = from._impl_.isvalidated_;
  // @@protoc_insertion_point(copy_constructor:clojureRT.protobuf.StaticCallNode)
}

inline void StaticCallNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.args_){arena}
    , decltype(_impl_.class__){}
    , decltype(_impl_.method_){}
    , decltype(_impl_.isvalidated_){false}
  };
  _impl_.class__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.class__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.method_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.method_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

StaticCallNode::~StaticCallNode() {
  // @@protoc_insertion_point(destructor:clojureRT.protobuf.StaticCallNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StaticCallNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.args_.~RepeatedPtrField();
  _impl_.class__.Destroy();
  _impl_.method_.Destroy();
}

void StaticCallNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StaticCallNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojureRT.protobuf.StaticCallNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.args_.Clear();
  _impl_.class__.ClearToEmpty();
  _impl_.method_.ClearToEmpty();
  _impl_.isvalidated_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StaticCallNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .clojureRT.protobuf.Node args = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_args(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string class = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_class_();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojureRT.protobuf.StaticCallNode.class"));
        } else
          goto handle_unusual;
        continue;
      // string method = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_method();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojureRT.protobuf.StaticCallNode.method"));
        } else
          goto handle_unusual;
        continue;
      // optional bool isValidated = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_isvalidated(&has_bits);
          _impl_.isvalidated_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StaticCallNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojureRT.protobuf.StaticCallNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .clojureRT.protobuf.Node args = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_args_size()); i < n; i++) {
    const auto& repfield = this->_internal_args(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // string class = 2;
  if (!this->_internal_class_().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_class_().data(), static_cast<int>(this->_internal_class_().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojureRT.protobuf.StaticCallNode.class");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_class_(), target);
  }

  // string method = 3;
  if (!this->_internal_method().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_method().data(), static_cast<int>(this->_internal_method().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojureRT.protobuf.StaticCallNode.method");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_method(), target);
  }

  // optional bool isValidated = 4;
  if (_internal_has_isvalidated()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_isvalidated(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojureRT.protobuf.StaticCallNode)
  return target;
}

size_t StaticCallNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojureRT.protobuf.StaticCallNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .clojureRT.protobuf.Node args = 1;
  total_size += 1UL * this->_internal_args_size();
  for (const auto& msg : this->_impl_.args_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string class = 2;
  if (!this->_internal_class_().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_class_());
  }

  // string method = 3;
  if (!this->_internal_method().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_method());
  }

  // optional bool isValidated = 4;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StaticCallNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StaticCallNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StaticCallNode::GetClassData() const { return &_class_data_; }


void StaticCallNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StaticCallNode*>(&to_msg);
  auto& from = static_cast<const StaticCallNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojureRT.protobuf.StaticCallNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.args_.MergeFrom(from._impl_.args_);
  if (!from._internal_class_().empty()) {
    _this->_internal_set_class_(from._internal_class_());
  }
  if (!from._internal_method().empty()) {
    _this->_internal_set_method(from._internal_method());
  }
  if (from._internal_has_isvalidated()) {
    _this->_internal_set_isvalidated(from._internal_isvalidated());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StaticCallNode::CopyFrom(const StaticCallNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojureRT.protobuf.StaticCallNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StaticCallNode::IsInitialized() const {
  return true;
}

void StaticCallNode::InternalSwap(StaticCallNode* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.args_.InternalSwap(&other->_impl_.args_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.class__, lhs_arena,
      &other->_impl_.class__, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.method_, lhs_arena,
      &other->_impl_.method_, rhs_arena
  );
  swap(_impl_.isvalidated_, other->_impl_.isvalidated_);
}

::PROTOBUF_NAMESPACE_ID::Metadata StaticCallNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[36]);
}

// ===================================================================

class StaticFieldNode::_Internal {
 public:
  using HasBits = decltype(std::declval<StaticFieldNode>()._impl_._has_bits_);
  static void set_has_isassignable(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

StaticFieldNode::StaticFieldNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojureRT.protobuf.StaticFieldNode)
}
StaticFieldNode::StaticFieldNode(const StaticFieldNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StaticFieldNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.class__){}
    , decltype(_impl_.field_){}
    , decltype(_impl_.isassignable_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.class__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.class__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_class_().empty()) {
    _this->_impl_.class__.Set(from._internal_class_(), 
      _this->GetArenaForAllocation());
  }
  _impl_.field_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.field_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_field().empty()) {
    _this->_impl_.field_.Set(from._internal_field(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.isassignable_ = from._impl_.isassignable_;
  // @@protoc_insertion_point(copy_constructor:clojureRT.protobuf.StaticFieldNode)
}

inline void StaticFieldNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.class__){}
    , decltype(_impl_.field_){}
    , decltype(_impl_.isassignable_){false}
  };
  _impl_.class__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.class__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.field_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.field_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

StaticFieldNode::~StaticFieldNode() {
  // @@protoc_insertion_point(destructor:clojureRT.protobuf.StaticFieldNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StaticFieldNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.class__.Destroy();
  _impl_.field_.Destroy();
}

void StaticFieldNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StaticFieldNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojureRT.protobuf.StaticFieldNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.class__.ClearToEmpty();
  _impl_.field_.ClearToEmpty();
  _impl_.isassignable_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StaticFieldNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool isAssignable = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_isassignable(&has_bits);
          _impl_.isassignable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string class = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_class_();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojureRT.protobuf.StaticFieldNode.class"));
        } else
          goto handle_unusual;
        continue;
      // string field = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_field();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojureRT.protobuf.StaticFieldNode.field"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StaticFieldNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojureRT.protobuf.StaticFieldNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional bool isAssignable = 1;
  if (_internal_has_isassignable()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_isassignable(), target);
  }

  // string class = 2;
  if (!this->_internal_class_().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_class_().data(), static_cast<int>(this->_internal_class_().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojureRT.protobuf.StaticFieldNode.class");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_class_(), target);
  }

  // string field = 3;
  if (!this->_internal_field().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_field().data(), static_cast<int>(this->_internal_field().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojureRT.protobuf.StaticFieldNode.field");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_field(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojureRT.protobuf.StaticFieldNode)
  return target;
}

size_t StaticFieldNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojureRT.protobuf.StaticFieldNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string class = 2;
  if (!this->_internal_class_().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_class_());
  }

  // string field = 3;
  if (!this->_internal_field().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_field());
  }

  // optional bool isAssignable = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StaticFieldNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StaticFieldNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StaticFieldNode::GetClassData() const { return &_class_data_; }


void StaticFieldNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StaticFieldNode*>(&to_msg);
  auto& from = static_cast<const StaticFieldNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojureRT.protobuf.StaticFieldNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_class_().empty()) {
    _this->_internal_set_class_(from._internal_class_());
  }
  if (!from._internal_field().empty()) {
    _this->_internal_set_field(from._internal_field());
  }
  if (from._internal_has_isassignable()) {
    _this->_internal_set_isassignable(from._internal_isassignable());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StaticFieldNode::CopyFrom(const StaticFieldNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojureRT.protobuf.StaticFieldNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StaticFieldNode::IsInitialized() const {
  return true;
}

void StaticFieldNode::InternalSwap(StaticFieldNode* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.class__, lhs_arena,
      &other->_impl_.class__, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.field_, lhs_arena,
      &other->_impl_.field_, rhs_arena
  );
  swap(_impl_.isassignable_, other->_impl_.isassignable_);
}

::PROTOBUF_NAMESPACE_ID::Metadata StaticFieldNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[37]);
}

// ===================================================================

class TheVarNode::_Internal {
 public:
};

TheVarNode::TheVarNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojureRT.protobuf.TheVarNode)
}
TheVarNode::TheVarNode(const TheVarNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TheVarNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.var_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.var_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.var_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_var().empty()) {
    _this->_impl_.var_.Set(from._internal_var(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:clojureRT.protobuf.TheVarNode)
}

inline void TheVarNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.var_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.var_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.var_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TheVarNode::~TheVarNode() {
  // @@protoc_insertion_point(destructor:clojureRT.protobuf.TheVarNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TheVarNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.var_.Destroy();
}

void TheVarNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TheVarNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojureRT.protobuf.TheVarNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.var_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TheVarNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string var = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_var();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojureRT.protobuf.TheVarNode.var"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TheVarNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojureRT.protobuf.TheVarNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string var = 1;
  if (!this->_internal_var().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_var().data(), static_cast<int>(this->_internal_var().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojureRT.protobuf.TheVarNode.var");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_var(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojureRT.protobuf.TheVarNode)
  return target;
}

size_t TheVarNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojureRT.protobuf.TheVarNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string var = 1;
  if (!this->_internal_var().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_var());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TheVarNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TheVarNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TheVarNode::GetClassData() const { return &_class_data_; }


void TheVarNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TheVarNode*>(&to_msg);
  auto& from = static_cast<const TheVarNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojureRT.protobuf.TheVarNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_var().empty()) {
    _this->_internal_set_var(from._internal_var());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TheVarNode::CopyFrom(const TheVarNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojureRT.protobuf.TheVarNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TheVarNode::IsInitialized() const {
  return true;
}

void TheVarNode::InternalSwap(TheVarNode* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.var_, lhs_arena,
      &other->_impl_.var_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata TheVarNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[38]);
}

// ===================================================================

class ThrowNode::_Internal {
 public:
  static const ::clojureRT::protobuf::Node& exception(const ThrowNode* msg);
};

const ::clojureRT::protobuf::Node&
ThrowNode::_Internal::exception(const ThrowNode* msg) {
  return *msg->_impl_.exception_;
}
ThrowNode::ThrowNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojureRT.protobuf.ThrowNode)
}
ThrowNode::ThrowNode(const ThrowNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ThrowNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.exception_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_exception()) {
    _this->_impl_.exception_ = new ::clojureRT::protobuf::Node(*from._impl_.exception_);
  }
  // @@protoc_insertion_point(copy_constructor:clojureRT.protobuf.ThrowNode)
}

inline void ThrowNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.exception_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ThrowNode::~ThrowNode() {
  // @@protoc_insertion_point(destructor:clojureRT.protobuf.ThrowNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ThrowNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.exception_;
}

void ThrowNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ThrowNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojureRT.protobuf.ThrowNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.exception_ != nullptr) {
    delete _impl_.exception_;
  }
  _impl_.exception_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ThrowNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .clojureRT.protobuf.Node exception = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_exception(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ThrowNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojureRT.protobuf.ThrowNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .clojureRT.protobuf.Node exception = 1;
  if (this->_internal_has_exception()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::exception(this),
        _Internal::exception(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojureRT.protobuf.ThrowNode)
  return target;
}

size_t ThrowNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojureRT.protobuf.ThrowNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .clojureRT.protobuf.Node exception = 1;
  if (this->_internal_has_exception()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.exception_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ThrowNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ThrowNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ThrowNode::GetClassData() const { return &_class_data_; }


void ThrowNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ThrowNode*>(&to_msg);
  auto& from = static_cast<const ThrowNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojureRT.protobuf.ThrowNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_exception()) {
    _this->_internal_mutable_exception()->::clojureRT::protobuf::Node::MergeFrom(
        from._internal_exception());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ThrowNode::CopyFrom(const ThrowNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojureRT.protobuf.ThrowNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ThrowNode::IsInitialized() const {
  return true;
}

void ThrowNode::InternalSwap(ThrowNode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.exception_, other->_impl_.exception_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ThrowNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[39]);
}

// ===================================================================

class TryNode::_Internal {
 public:
  using HasBits = decltype(std::declval<TryNode>()._impl_._has_bits_);
  static const ::clojureRT::protobuf::Node& body(const TryNode* msg);
  static const ::clojureRT::protobuf::Node& finally(const TryNode* msg);
  static void set_has_finally(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::clojureRT::protobuf::Node&
TryNode::_Internal::body(const TryNode* msg) {
  return *msg->_impl_.body_;
}
const ::clojureRT::protobuf::Node&
TryNode::_Internal::finally(const TryNode* msg) {
  return *msg->_impl_.finally_;
}
TryNode::TryNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojureRT.protobuf.TryNode)
}
TryNode::TryNode(const TryNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TryNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.catches_){from._impl_.catches_}
    , decltype(_impl_.body_){nullptr}
    , decltype(_impl_.finally_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_body()) {
    _this->_impl_.body_ = new ::clojureRT::protobuf::Node(*from._impl_.body_);
  }
  if (from._internal_has_finally()) {
    _this->_impl_.finally_ = new ::clojureRT::protobuf::Node(*from._impl_.finally_);
  }
  // @@protoc_insertion_point(copy_constructor:clojureRT.protobuf.TryNode)
}

inline void TryNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.catches_){arena}
    , decltype(_impl_.body_){nullptr}
    , decltype(_impl_.finally_){nullptr}
  };
}

TryNode::~TryNode() {
  // @@protoc_insertion_point(destructor:clojureRT.protobuf.TryNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TryNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.catches_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.body_;
  if (this != internal_default_instance()) delete _impl_.finally_;
}

void TryNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TryNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojureRT.protobuf.TryNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.catches_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.body_ != nullptr) {
    delete _impl_.body_;
  }
  _impl_.body_ = nullptr;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.finally_ != nullptr);
    _impl_.finally_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TryNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .clojureRT.protobuf.Node body = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_body(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .clojureRT.protobuf.Node catches = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_catches(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .clojureRT.protobuf.Node finally = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_finally(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TryNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojureRT.protobuf.TryNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .clojureRT.protobuf.Node body = 1;
  if (this->_internal_has_body()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::body(this),
        _Internal::body(this).GetCachedSize(), target, stream);
  }

  // repeated .clojureRT.protobuf.Node catches = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_catches_size()); i < n; i++) {
    const auto& repfield = this->_internal_catches(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .clojureRT.protobuf.Node finally = 3;
  if (_internal_has_finally()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::finally(this),
        _Internal::finally(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojureRT.protobuf.TryNode)
  return target;
}

size_t TryNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojureRT.protobuf.TryNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .clojureRT.protobuf.Node catches = 2;
  total_size += 1UL * this->_internal_catches_size();
  for (const auto& msg : this->_impl_.catches_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .clojureRT.protobuf.Node body = 1;
  if (this->_internal_has_body()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.body_);
  }

  // optional .clojureRT.protobuf.Node finally = 3;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.finally_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TryNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TryNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TryNode::GetClassData() const { return &_class_data_; }


void TryNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TryNode*>(&to_msg);
  auto& from = static_cast<const TryNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojureRT.protobuf.TryNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.catches_.MergeFrom(from._impl_.catches_);
  if (from._internal_has_body()) {
    _this->_internal_mutable_body()->::clojureRT::protobuf::Node::MergeFrom(
        from._internal_body());
  }
  if (from._internal_has_finally()) {
    _this->_internal_mutable_finally()->::clojureRT::protobuf::Node::MergeFrom(
        from._internal_finally());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TryNode::CopyFrom(const TryNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojureRT.protobuf.TryNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TryNode::IsInitialized() const {
  return true;
}

void TryNode::InternalSwap(TryNode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.catches_.InternalSwap(&other->_impl_.catches_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TryNode, _impl_.finally_)
      + sizeof(TryNode::_impl_.finally_)
      - PROTOBUF_FIELD_OFFSET(TryNode, _impl_.body_)>(
          reinterpret_cast<char*>(&_impl_.body_),
          reinterpret_cast<char*>(&other->_impl_.body_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TryNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[40]);
}

// ===================================================================

class VarNode::_Internal {
 public:
  using HasBits = decltype(std::declval<VarNode>()._impl_._has_bits_);
  static void set_has_isassignable(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

VarNode::VarNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojureRT.protobuf.VarNode)
}
VarNode::VarNode(const VarNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VarNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.var_){}
    , decltype(_impl_.isassignable_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.var_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.var_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_var().empty()) {
    _this->_impl_.var_.Set(from._internal_var(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.isassignable_ = from._impl_.isassignable_;
  // @@protoc_insertion_point(copy_constructor:clojureRT.protobuf.VarNode)
}

inline void VarNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.var_){}
    , decltype(_impl_.isassignable_){false}
  };
  _impl_.var_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.var_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

VarNode::~VarNode() {
  // @@protoc_insertion_point(destructor:clojureRT.protobuf.VarNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VarNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.var_.Destroy();
}

void VarNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VarNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojureRT.protobuf.VarNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.var_.ClearToEmpty();
  _impl_.isassignable_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VarNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool isAssignable = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_isassignable(&has_bits);
          _impl_.isassignable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string var = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_var();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojureRT.protobuf.VarNode.var"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VarNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojureRT.protobuf.VarNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional bool isAssignable = 1;
  if (_internal_has_isassignable()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_isassignable(), target);
  }

  // string var = 2;
  if (!this->_internal_var().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_var().data(), static_cast<int>(this->_internal_var().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojureRT.protobuf.VarNode.var");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_var(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojureRT.protobuf.VarNode)
  return target;
}

size_t VarNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojureRT.protobuf.VarNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string var = 2;
  if (!this->_internal_var().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_var());
  }

  // optional bool isAssignable = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VarNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VarNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VarNode::GetClassData() const { return &_class_data_; }


void VarNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VarNode*>(&to_msg);
  auto& from = static_cast<const VarNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojureRT.protobuf.VarNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_var().empty()) {
    _this->_internal_set_var(from._internal_var());
  }
  if (from._internal_has_isassignable()) {
    _this->_internal_set_isassignable(from._internal_isassignable());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VarNode::CopyFrom(const VarNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojureRT.protobuf.VarNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VarNode::IsInitialized() const {
  return true;
}

void VarNode::InternalSwap(VarNode* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.var_, lhs_arena,
      &other->_impl_.var_, rhs_arena
  );
  swap(_impl_.isassignable_, other->_impl_.isassignable_);
}

::PROTOBUF_NAMESPACE_ID::Metadata VarNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[41]);
}

// ===================================================================

class VectorNode::_Internal {
 public:
};

VectorNode::VectorNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojureRT.protobuf.VectorNode)
}
VectorNode::VectorNode(const VectorNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VectorNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.items_){from._impl_.items_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:clojureRT.protobuf.VectorNode)
}

inline void VectorNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.items_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

VectorNode::~VectorNode() {
  // @@protoc_insertion_point(destructor:clojureRT.protobuf.VectorNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VectorNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.items_.~RepeatedPtrField();
}

void VectorNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VectorNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojureRT.protobuf.VectorNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.items_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VectorNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .clojureRT.protobuf.Node items = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_items(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VectorNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojureRT.protobuf.VectorNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .clojureRT.protobuf.Node items = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_items_size()); i < n; i++) {
    const auto& repfield = this->_internal_items(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojureRT.protobuf.VectorNode)
  return target;
}

size_t VectorNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojureRT.protobuf.VectorNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .clojureRT.protobuf.Node items = 1;
  total_size += 1UL * this->_internal_items_size();
  for (const auto& msg : this->_impl_.items_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VectorNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VectorNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VectorNode::GetClassData() const { return &_class_data_; }


void VectorNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VectorNode*>(&to_msg);
  auto& from = static_cast<const VectorNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojureRT.protobuf.VectorNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.items_.MergeFrom(from._impl_.items_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VectorNode::CopyFrom(const VectorNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojureRT.protobuf.VectorNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VectorNode::IsInitialized() const {
  return true;
}

void VectorNode::InternalSwap(VectorNode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.items_.InternalSwap(&other->_impl_.items_);
}

::PROTOBUF_NAMESPACE_ID::Metadata VectorNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[42]);
}

// ===================================================================

class WithMetaNode::_Internal {
 public:
  static const ::clojureRT::protobuf::Node& expr(const WithMetaNode* msg);
  static const ::clojureRT::protobuf::Node& meta(const WithMetaNode* msg);
};

const ::clojureRT::protobuf::Node&
WithMetaNode::_Internal::expr(const WithMetaNode* msg) {
  return *msg->_impl_.expr_;
}
const ::clojureRT::protobuf::Node&
WithMetaNode::_Internal::meta(const WithMetaNode* msg) {
  return *msg->_impl_.meta_;
}
WithMetaNode::WithMetaNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojureRT.protobuf.WithMetaNode)
}
WithMetaNode::WithMetaNode(const WithMetaNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  WithMetaNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.expr_){nullptr}
    , decltype(_impl_.meta_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_expr()) {
    _this->_impl_.expr_ = new ::clojureRT::protobuf::Node(*from._impl_.expr_);
  }
  if (from._internal_has_meta()) {
    _this->_impl_.meta_ = new ::clojureRT::protobuf::Node(*from._impl_.meta_);
  }
  // @@protoc_insertion_point(copy_constructor:clojureRT.protobuf.WithMetaNode)
}

inline void WithMetaNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.expr_){nullptr}
    , decltype(_impl_.meta_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

WithMetaNode::~WithMetaNode() {
  // @@protoc_insertion_point(destructor:clojureRT.protobuf.WithMetaNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void WithMetaNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.expr_;
  if (this != internal_default_instance()) delete _impl_.meta_;
}

void WithMetaNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void WithMetaNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojureRT.protobuf.WithMetaNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.expr_ != nullptr) {
    delete _impl_.expr_;
  }
  _impl_.expr_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.meta_ != nullptr) {
    delete _impl_.meta_;
  }
  _impl_.meta_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* WithMetaNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .clojureRT.protobuf.Node expr = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_expr(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.Node meta = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_meta(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* WithMetaNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojureRT.protobuf.WithMetaNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .clojureRT.protobuf.Node expr = 1;
  if (this->_internal_has_expr()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::expr(this),
        _Internal::expr(this).GetCachedSize(), target, stream);
  }

  // .clojureRT.protobuf.Node meta = 2;
  if (this->_internal_has_meta()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::meta(this),
        _Internal::meta(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojureRT.protobuf.WithMetaNode)
  return target;
}

size_t WithMetaNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojureRT.protobuf.WithMetaNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .clojureRT.protobuf.Node expr = 1;
  if (this->_internal_has_expr()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.expr_);
  }

  // .clojureRT.protobuf.Node meta = 2;
  if (this->_internal_has_meta()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.meta_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData WithMetaNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    WithMetaNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*WithMetaNode::GetClassData() const { return &_class_data_; }


void WithMetaNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<WithMetaNode*>(&to_msg);
  auto& from = static_cast<const WithMetaNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojureRT.protobuf.WithMetaNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_expr()) {
    _this->_internal_mutable_expr()->::clojureRT::protobuf::Node::MergeFrom(
        from._internal_expr());
  }
  if (from._internal_has_meta()) {
    _this->_internal_mutable_meta()->::clojureRT::protobuf::Node::MergeFrom(
        from._internal_meta());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void WithMetaNode::CopyFrom(const WithMetaNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojureRT.protobuf.WithMetaNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WithMetaNode::IsInitialized() const {
  return true;
}

void WithMetaNode::InternalSwap(WithMetaNode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(WithMetaNode, _impl_.meta_)
      + sizeof(WithMetaNode::_impl_.meta_)
      - PROTOBUF_FIELD_OFFSET(WithMetaNode, _impl_.expr_)>(
          reinterpret_cast<char*>(&_impl_.expr_),
          reinterpret_cast<char*>(&other->_impl_.expr_));
}

::PROTOBUF_NAMESPACE_ID::Metadata WithMetaNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[43]);
}

// ===================================================================

class Node::_Internal {
 public:
  using HasBits = decltype(std::declval<Node>()._impl_._has_bits_);
  static void set_has_ignoretag(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::clojureRT::protobuf::Subnode& subnode(const Node* msg);
  static void set_has_toplevel(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::clojureRT::protobuf::Subnode&
Node::_Internal::subnode(const Node* msg) {
  return *msg->_impl_.subnode_;
}
Node::Node(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojureRT.protobuf.Node)
}
Node::Node(const Node& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Node* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.loops_){from._impl_.loops_}
    , decltype(_impl_.rawforms_){from._impl_.rawforms_}
    , decltype(_impl_.env_){}
    , decltype(_impl_.form_){}
    , decltype(_impl_.otag_){}
    , decltype(_impl_.tag_){}
    , decltype(_impl_.subnode_){nullptr}
    , decltype(_impl_.op_){}
    , decltype(_impl_.ignoretag_){}
    , decltype(_impl_.toplevel_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.env_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.env_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_env().empty()) {
    _this->_impl_.env_.Set(from._internal_env(), 
      _this->GetArenaForAllocation());
  }
  _impl_.form_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.form_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_form().empty()) {
    _this->_impl_.form_.Set(from._internal_form(), 
      _this->GetArenaForAllocation());
  }
  _impl_.otag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.otag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_otag().empty()) {
    _this->_impl_.otag_.Set(from._internal_otag(), 
      _this->GetArenaForAllocation());
  }
  _impl_.tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_tag().empty()) {
    _this->_impl_.tag_.Set(from._internal_tag(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_subnode()) {
    _this->_impl_.subnode_ = new ::clojureRT::protobuf::Subnode(*from._impl_.subnode_);
  }
  ::memcpy(&_impl_.op_, &from._impl_.op_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.toplevel_) -
    reinterpret_cast<char*>(&_impl_.op_)) + sizeof(_impl_.toplevel_));
  // @@protoc_insertion_point(copy_constructor:clojureRT.protobuf.Node)
}

inline void Node::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.loops_){arena}
    , decltype(_impl_.rawforms_){arena}
    , decltype(_impl_.env_){}
    , decltype(_impl_.form_){}
    , decltype(_impl_.otag_){}
    , decltype(_impl_.tag_){}
    , decltype(_impl_.subnode_){nullptr}
    , decltype(_impl_.op_){0}
    , decltype(_impl_.ignoretag_){false}
    , decltype(_impl_.toplevel_){false}
  };
  _impl_.env_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.env_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.form_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.form_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.otag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.otag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Node::~Node() {
  // @@protoc_insertion_point(destructor:clojureRT.protobuf.Node)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Node::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.loops_.~RepeatedPtrField();
  _impl_.rawforms_.~RepeatedPtrField();
  _impl_.env_.Destroy();
  _impl_.form_.Destroy();
  _impl_.otag_.Destroy();
  _impl_.tag_.Destroy();
  if (this != internal_default_instance()) delete _impl_.subnode_;
}

void Node::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Node::Clear() {
// @@protoc_insertion_point(message_clear_start:clojureRT.protobuf.Node)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.loops_.Clear();
  _impl_.rawforms_.Clear();
  _impl_.env_.ClearToEmpty();
  _impl_.form_.ClearToEmpty();
  _impl_.otag_.ClearToEmpty();
  _impl_.tag_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.subnode_ != nullptr) {
    delete _impl_.subnode_;
  }
  _impl_.subnode_ = nullptr;
  _impl_.op_ = 0;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.ignoretag_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.toplevel_) -
        reinterpret_cast<char*>(&_impl_.ignoretag_)) + sizeof(_impl_.toplevel_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Node::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string env = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_env();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojureRT.protobuf.Node.env"));
        } else
          goto handle_unusual;
        continue;
      // string form = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_form();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojureRT.protobuf.Node.form"));
        } else
          goto handle_unusual;
        continue;
      // optional bool ignoreTag = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_ignoretag(&has_bits);
          _impl_.ignoretag_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string loops = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_loops();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "clojureRT.protobuf.Node.loops"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string oTag = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_otag();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojureRT.protobuf.Node.oTag"));
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.Op op = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_op(static_cast<::clojureRT::protobuf::Op>(val));
        } else
          goto handle_unusual;
        continue;
      // repeated string rawForms = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_rawforms();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "clojureRT.protobuf.Node.rawForms"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .clojureRT.protobuf.Subnode subnode = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_subnode(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string tag = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_tag();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojureRT.protobuf.Node.tag"));
        } else
          goto handle_unusual;
        continue;
      // optional bool topLevel = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_toplevel(&has_bits);
          _impl_.toplevel_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Node::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojureRT.protobuf.Node)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string env = 1;
  if (!this->_internal_env().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_env().data(), static_cast<int>(this->_internal_env().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojureRT.protobuf.Node.env");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_env(), target);
  }

  // string form = 2;
  if (!this->_internal_form().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_form().data(), static_cast<int>(this->_internal_form().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojureRT.protobuf.Node.form");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_form(), target);
  }

  // optional bool ignoreTag = 3;
  if (_internal_has_ignoretag()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_ignoretag(), target);
  }

  // repeated string loops = 4;
  for (int i = 0, n = this->_internal_loops_size(); i < n; i++) {
    const auto& s = this->_internal_loops(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojureRT.protobuf.Node.loops");
    target = stream->WriteString(4, s, target);
  }

  // string oTag = 5;
  if (!this->_internal_otag().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_otag().data(), static_cast<int>(this->_internal_otag().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojureRT.protobuf.Node.oTag");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_otag(), target);
  }

  // .clojureRT.protobuf.Op op = 6;
  if (this->_internal_op() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      6, this->_internal_op(), target);
  }

  // repeated string rawForms = 7;
  for (int i = 0, n = this->_internal_rawforms_size(); i < n; i++) {
    const auto& s = this->_internal_rawforms(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojureRT.protobuf.Node.rawForms");
    target = stream->WriteString(7, s, target);
  }

  // .clojureRT.protobuf.Subnode subnode = 8;
  if (this->_internal_has_subnode()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::subnode(this),
        _Internal::subnode(this).GetCachedSize(), target, stream);
  }

  // string tag = 9;
  if (!this->_internal_tag().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_tag().data(), static_cast<int>(this->_internal_tag().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojureRT.protobuf.Node.tag");
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_tag(), target);
  }

  // optional bool topLevel = 10;
  if (_internal_has_toplevel()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_toplevel(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojureRT.protobuf.Node)
  return target;
}

size_t Node::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojureRT.protobuf.Node)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string loops = 4;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.loops_.size());
  for (int i = 0, n = _impl_.loops_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.loops_.Get(i));
  }

  // repeated string rawForms = 7;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.rawforms_.size());
  for (int i = 0, n = _impl_.rawforms_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.rawforms_.Get(i));
  }

  // string env = 1;
  if (!this->_internal_env().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_env());
  }

  // string form = 2;
  if (!this->_internal_form().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_form());
  }

  // string oTag = 5;
  if (!this->_internal_otag().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_otag());
  }

  // string tag = 9;
  if (!this->_internal_tag().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_tag());
  }

  // .clojureRT.protobuf.Subnode subnode = 8;
  if (this->_internal_has_subnode()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.subnode_);
  }

  // .clojureRT.protobuf.Op op = 6;
  if (this->_internal_op() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_op());
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bool ignoreTag = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional bool topLevel = 10;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Node::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Node::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Node::GetClassData() const { return &_class_data_; }


void Node::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Node*>(&to_msg);
  auto& from = static_cast<const Node&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojureRT.protobuf.Node)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.loops_.MergeFrom(from._impl_.loops_);
  _this->_impl_.rawforms_.MergeFrom(from._impl_.rawforms_);
  if (!from._internal_env().empty()) {
    _this->_internal_set_env(from._internal_env());
  }
  if (!from._internal_form().empty()) {
    _this->_internal_set_form(from._internal_form());
  }
  if (!from._internal_otag().empty()) {
    _this->_internal_set_otag(from._internal_otag());
  }
  if (!from._internal_tag().empty()) {
    _this->_internal_set_tag(from._internal_tag());
  }
  if (from._internal_has_subnode()) {
    _this->_internal_mutable_subnode()->::clojureRT::protobuf::Subnode::MergeFrom(
        from._internal_subnode());
  }
  if (from._internal_op() != 0) {
    _this->_internal_set_op(from._internal_op());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.ignoretag_ = from._impl_.ignoretag_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.toplevel_ = from._impl_.toplevel_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Node::CopyFrom(const Node& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojureRT.protobuf.Node)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Node::IsInitialized() const {
  return true;
}

void Node::InternalSwap(Node* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.loops_.InternalSwap(&other->_impl_.loops_);
  _impl_.rawforms_.InternalSwap(&other->_impl_.rawforms_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.env_, lhs_arena,
      &other->_impl_.env_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.form_, lhs_arena,
      &other->_impl_.form_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.otag_, lhs_arena,
      &other->_impl_.otag_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.tag_, lhs_arena,
      &other->_impl_.tag_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Node, _impl_.toplevel_)
      + sizeof(Node::_impl_.toplevel_)
      - PROTOBUF_FIELD_OFFSET(Node, _impl_.subnode_)>(
          reinterpret_cast<char*>(&_impl_.subnode_),
          reinterpret_cast<char*>(&other->_impl_.subnode_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Node::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[44]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace protobuf
}  // namespace clojureRT
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::clojureRT::protobuf::Subnode*
Arena::CreateMaybeMessage< ::clojureRT::protobuf::Subnode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojureRT::protobuf::Subnode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojureRT::protobuf::BindingNode*
Arena::CreateMaybeMessage< ::clojureRT::protobuf::BindingNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojureRT::protobuf::BindingNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojureRT::protobuf::CaseNode*
Arena::CreateMaybeMessage< ::clojureRT::protobuf::CaseNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojureRT::protobuf::CaseNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojureRT::protobuf::CaseTestNode*
Arena::CreateMaybeMessage< ::clojureRT::protobuf::CaseTestNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojureRT::protobuf::CaseTestNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojureRT::protobuf::CaseThenNode*
Arena::CreateMaybeMessage< ::clojureRT::protobuf::CaseThenNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojureRT::protobuf::CaseThenNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojureRT::protobuf::CatchNode*
Arena::CreateMaybeMessage< ::clojureRT::protobuf::CatchNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojureRT::protobuf::CatchNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojureRT::protobuf::ConstNode*
Arena::CreateMaybeMessage< ::clojureRT::protobuf::ConstNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojureRT::protobuf::ConstNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojureRT::protobuf::DefNode*
Arena::CreateMaybeMessage< ::clojureRT::protobuf::DefNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojureRT::protobuf::DefNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojureRT::protobuf::DeftypeNode*
Arena::CreateMaybeMessage< ::clojureRT::protobuf::DeftypeNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojureRT::protobuf::DeftypeNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojureRT::protobuf::DoNode*
Arena::CreateMaybeMessage< ::clojureRT::protobuf::DoNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojureRT::protobuf::DoNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojureRT::protobuf::FnNode*
Arena::CreateMaybeMessage< ::clojureRT::protobuf::FnNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojureRT::protobuf::FnNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojureRT::protobuf::FnMethodNode*
Arena::CreateMaybeMessage< ::clojureRT::protobuf::FnMethodNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojureRT::protobuf::FnMethodNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojureRT::protobuf::HostInteropNode*
Arena::CreateMaybeMessage< ::clojureRT::protobuf::HostInteropNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojureRT::protobuf::HostInteropNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojureRT::protobuf::IfNode*
Arena::CreateMaybeMessage< ::clojureRT::protobuf::IfNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojureRT::protobuf::IfNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojureRT::protobuf::ImportNode*
Arena::CreateMaybeMessage< ::clojureRT::protobuf::ImportNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojureRT::protobuf::ImportNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojureRT::protobuf::InstanceCallNode*
Arena::CreateMaybeMessage< ::clojureRT::protobuf::InstanceCallNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojureRT::protobuf::InstanceCallNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojureRT::protobuf::InstanceFieldNode*
Arena::CreateMaybeMessage< ::clojureRT::protobuf::InstanceFieldNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojureRT::protobuf::InstanceFieldNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojureRT::protobuf::IsInstanceNode*
Arena::CreateMaybeMessage< ::clojureRT::protobuf::IsInstanceNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojureRT::protobuf::IsInstanceNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojureRT::protobuf::InvokeNode*
Arena::CreateMaybeMessage< ::clojureRT::protobuf::InvokeNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojureRT::protobuf::InvokeNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojureRT::protobuf::KeywordInvokeNode*
Arena::CreateMaybeMessage< ::clojureRT::protobuf::KeywordInvokeNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojureRT::protobuf::KeywordInvokeNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojureRT::protobuf::LetNode*
Arena::CreateMaybeMessage< ::clojureRT::protobuf::LetNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojureRT::protobuf::LetNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojureRT::protobuf::LetfnNode*
Arena::CreateMaybeMessage< ::clojureRT::protobuf::LetfnNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojureRT::protobuf::LetfnNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojureRT::protobuf::LocalNode*
Arena::CreateMaybeMessage< ::clojureRT::protobuf::LocalNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojureRT::protobuf::LocalNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojureRT::protobuf::LoopNode*
Arena::CreateMaybeMessage< ::clojureRT::protobuf::LoopNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojureRT::protobuf::LoopNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojureRT::protobuf::MapNode*
Arena::CreateMaybeMessage< ::clojureRT::protobuf::MapNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojureRT::protobuf::MapNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojureRT::protobuf::MethodNode*
Arena::CreateMaybeMessage< ::clojureRT::protobuf::MethodNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojureRT::protobuf::MethodNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojureRT::protobuf::MonitorEnterNode*
Arena::CreateMaybeMessage< ::clojureRT::protobuf::MonitorEnterNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojureRT::protobuf::MonitorEnterNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojureRT::protobuf::MonitorExitNode*
Arena::CreateMaybeMessage< ::clojureRT::protobuf::MonitorExitNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojureRT::protobuf::MonitorExitNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojureRT::protobuf::NewNode*
Arena::CreateMaybeMessage< ::clojureRT::protobuf::NewNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojureRT::protobuf::NewNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojureRT::protobuf::PrimInvokeNode*
Arena::CreateMaybeMessage< ::clojureRT::protobuf::PrimInvokeNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojureRT::protobuf::PrimInvokeNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojureRT::protobuf::ProtocolInvokeNode*
Arena::CreateMaybeMessage< ::clojureRT::protobuf::ProtocolInvokeNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojureRT::protobuf::ProtocolInvokeNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojureRT::protobuf::QuoteNode*
Arena::CreateMaybeMessage< ::clojureRT::protobuf::QuoteNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojureRT::protobuf::QuoteNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojureRT::protobuf::RecurNode*
Arena::CreateMaybeMessage< ::clojureRT::protobuf::RecurNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojureRT::protobuf::RecurNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojureRT::protobuf::ReifyNode*
Arena::CreateMaybeMessage< ::clojureRT::protobuf::ReifyNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojureRT::protobuf::ReifyNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojureRT::protobuf::SetNode*
Arena::CreateMaybeMessage< ::clojureRT::protobuf::SetNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojureRT::protobuf::SetNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojureRT::protobuf::MutateSetNode*
Arena::CreateMaybeMessage< ::clojureRT::protobuf::MutateSetNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojureRT::protobuf::MutateSetNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojureRT::protobuf::StaticCallNode*
Arena::CreateMaybeMessage< ::clojureRT::protobuf::StaticCallNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojureRT::protobuf::StaticCallNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojureRT::protobuf::StaticFieldNode*
Arena::CreateMaybeMessage< ::clojureRT::protobuf::StaticFieldNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojureRT::protobuf::StaticFieldNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojureRT::protobuf::TheVarNode*
Arena::CreateMaybeMessage< ::clojureRT::protobuf::TheVarNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojureRT::protobuf::TheVarNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojureRT::protobuf::ThrowNode*
Arena::CreateMaybeMessage< ::clojureRT::protobuf::ThrowNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojureRT::protobuf::ThrowNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojureRT::protobuf::TryNode*
Arena::CreateMaybeMessage< ::clojureRT::protobuf::TryNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojureRT::protobuf::TryNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojureRT::protobuf::VarNode*
Arena::CreateMaybeMessage< ::clojureRT::protobuf::VarNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojureRT::protobuf::VarNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojureRT::protobuf::VectorNode*
Arena::CreateMaybeMessage< ::clojureRT::protobuf::VectorNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojureRT::protobuf::VectorNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojureRT::protobuf::WithMetaNode*
Arena::CreateMaybeMessage< ::clojureRT::protobuf::WithMetaNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojureRT::protobuf::WithMetaNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojureRT::protobuf::Node*
Arena::CreateMaybeMessage< ::clojureRT::protobuf::Node >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojureRT::protobuf::Node >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
