// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bytecode.proto

#include "bytecode.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace clojure {
namespace rt {
namespace protobuf {
namespace bytecode {
PROTOBUF_CONSTEXPR Environment::Environment(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.locals_)*/{}
  , /*decltype(_impl_.context_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.ns_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.file_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.column_)*/0u
  , /*decltype(_impl_.line_)*/0u
  , /*decltype(_impl_.endcolumn_)*/0u
  , /*decltype(_impl_.endline_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct EnvironmentDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EnvironmentDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EnvironmentDefaultTypeInternal() {}
  union {
    Environment _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EnvironmentDefaultTypeInternal _Environment_default_instance_;
PROTOBUF_CONSTEXPR Subnode::Subnode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.types_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct SubnodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SubnodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SubnodeDefaultTypeInternal() {}
  union {
    Subnode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SubnodeDefaultTypeInternal _Subnode_default_instance_;
PROTOBUF_CONSTEXPR BindingNode::BindingNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.init_)*/nullptr
  , /*decltype(_impl_.argid_)*/0u
  , /*decltype(_impl_.local_)*/0
  , /*decltype(_impl_.isvariadic_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct BindingNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BindingNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BindingNodeDefaultTypeInternal() {}
  union {
    BindingNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BindingNodeDefaultTypeInternal _BindingNode_default_instance_;
PROTOBUF_CONSTEXPR CaseNode::CaseNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.tests_)*/{}
  , /*decltype(_impl_.thens_)*/{}
  , /*decltype(_impl_.high_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.low_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.isskipcheck_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.default__)*/nullptr
  , /*decltype(_impl_.test_)*/nullptr
  , /*decltype(_impl_.mask_)*/0u
  , /*decltype(_impl_.shift_)*/0u
  , /*decltype(_impl_.switchtype_)*/0
  , /*decltype(_impl_.testtype_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CaseNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CaseNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CaseNodeDefaultTypeInternal() {}
  union {
    CaseNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CaseNodeDefaultTypeInternal _CaseNode_default_instance_;
PROTOBUF_CONSTEXPR CaseTestNode::CaseTestNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.test_)*/nullptr
  , /*decltype(_impl_.hash_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CaseTestNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CaseTestNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CaseTestNodeDefaultTypeInternal() {}
  union {
    CaseTestNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CaseTestNodeDefaultTypeInternal _CaseTestNode_default_instance_;
PROTOBUF_CONSTEXPR CaseThenNode::CaseThenNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.then_)*/nullptr
  , /*decltype(_impl_.hash_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CaseThenNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CaseThenNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CaseThenNodeDefaultTypeInternal() {}
  union {
    CaseThenNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CaseThenNodeDefaultTypeInternal _CaseThenNode_default_instance_;
PROTOBUF_CONSTEXPR CatchNode::CatchNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.body_)*/nullptr
  , /*decltype(_impl_.class__)*/nullptr
  , /*decltype(_impl_.local_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CatchNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CatchNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CatchNodeDefaultTypeInternal() {}
  union {
    CatchNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CatchNodeDefaultTypeInternal _CatchNode_default_instance_;
PROTOBUF_CONSTEXPR ConstNode::ConstNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.val_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.meta_)*/nullptr
  , /*decltype(_impl_.isliteral_)*/false
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ConstNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConstNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConstNodeDefaultTypeInternal() {}
  union {
    ConstNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConstNodeDefaultTypeInternal _ConstNode_default_instance_;
PROTOBUF_CONSTEXPR DefNode::DefNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.doc_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.var_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.init_)*/nullptr
  , /*decltype(_impl_.meta_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DefNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DefNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DefNodeDefaultTypeInternal() {}
  union {
    DefNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DefNodeDefaultTypeInternal _DefNode_default_instance_;
PROTOBUF_CONSTEXPR DeftypeNode::DeftypeNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.fields_)*/{}
  , /*decltype(_impl_.interfaces_)*/{}
  , /*decltype(_impl_.methods_)*/{}
  , /*decltype(_impl_.classname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DeftypeNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeftypeNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeftypeNodeDefaultTypeInternal() {}
  union {
    DeftypeNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeftypeNodeDefaultTypeInternal _DeftypeNode_default_instance_;
PROTOBUF_CONSTEXPR DoNode::DoNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.statements_)*/{}
  , /*decltype(_impl_.ret_)*/nullptr
  , /*decltype(_impl_.isbody_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DoNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DoNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DoNodeDefaultTypeInternal() {}
  union {
    DoNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DoNodeDefaultTypeInternal _DoNode_default_instance_;
PROTOBUF_CONSTEXPR FnNode::FnNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.methods_)*/{}
  , /*decltype(_impl_.local_)*/nullptr
  , /*decltype(_impl_.maxfixedarity_)*/0u
  , /*decltype(_impl_.once_)*/false
  , /*decltype(_impl_.isvariadic_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct FnNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FnNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FnNodeDefaultTypeInternal() {}
  union {
    FnNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FnNodeDefaultTypeInternal _FnNode_default_instance_;
PROTOBUF_CONSTEXPR FnMethodNode::FnMethodNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.params_)*/{}
  , /*decltype(_impl_.loopid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.body_)*/nullptr
  , /*decltype(_impl_.fixedarity_)*/0u
  , /*decltype(_impl_.isvariadic_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct FnMethodNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FnMethodNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FnMethodNodeDefaultTypeInternal() {}
  union {
    FnMethodNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FnMethodNodeDefaultTypeInternal _FnMethodNode_default_instance_;
PROTOBUF_CONSTEXPR HostInteropNode::HostInteropNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.morf_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.target_)*/nullptr
  , /*decltype(_impl_.isassignable_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct HostInteropNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HostInteropNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~HostInteropNodeDefaultTypeInternal() {}
  union {
    HostInteropNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HostInteropNodeDefaultTypeInternal _HostInteropNode_default_instance_;
PROTOBUF_CONSTEXPR IfNode::IfNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.else__)*/nullptr
  , /*decltype(_impl_.test_)*/nullptr
  , /*decltype(_impl_.then_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct IfNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IfNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IfNodeDefaultTypeInternal() {}
  union {
    IfNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IfNodeDefaultTypeInternal _IfNode_default_instance_;
PROTOBUF_CONSTEXPR ImportNode::ImportNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.class__)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ImportNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ImportNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ImportNodeDefaultTypeInternal() {}
  union {
    ImportNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ImportNodeDefaultTypeInternal _ImportNode_default_instance_;
PROTOBUF_CONSTEXPR InstanceCallNode::InstanceCallNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.args_)*/{}
  , /*decltype(_impl_.class__)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.method_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.instance_)*/nullptr
  , /*decltype(_impl_.isvalidated_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct InstanceCallNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InstanceCallNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~InstanceCallNodeDefaultTypeInternal() {}
  union {
    InstanceCallNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InstanceCallNodeDefaultTypeInternal _InstanceCallNode_default_instance_;
PROTOBUF_CONSTEXPR InstanceFieldNode::InstanceFieldNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.class__)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.field_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.instance_)*/nullptr
  , /*decltype(_impl_.isassignable_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct InstanceFieldNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InstanceFieldNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~InstanceFieldNodeDefaultTypeInternal() {}
  union {
    InstanceFieldNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InstanceFieldNodeDefaultTypeInternal _InstanceFieldNode_default_instance_;
PROTOBUF_CONSTEXPR IsInstanceNode::IsInstanceNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.class__)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.target_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct IsInstanceNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IsInstanceNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IsInstanceNodeDefaultTypeInternal() {}
  union {
    IsInstanceNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IsInstanceNodeDefaultTypeInternal _IsInstanceNode_default_instance_;
PROTOBUF_CONSTEXPR InvokeNode::InvokeNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.args_)*/{}
  , /*decltype(_impl_.meta_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.fn_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct InvokeNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InvokeNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~InvokeNodeDefaultTypeInternal() {}
  union {
    InvokeNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InvokeNodeDefaultTypeInternal _InvokeNode_default_instance_;
PROTOBUF_CONSTEXPR KeywordInvokeNode::KeywordInvokeNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.keyword_)*/nullptr
  , /*decltype(_impl_.target_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct KeywordInvokeNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KeywordInvokeNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KeywordInvokeNodeDefaultTypeInternal() {}
  union {
    KeywordInvokeNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KeywordInvokeNodeDefaultTypeInternal _KeywordInvokeNode_default_instance_;
PROTOBUF_CONSTEXPR LetNode::LetNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.bindings_)*/{}
  , /*decltype(_impl_.body_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LetNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LetNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LetNodeDefaultTypeInternal() {}
  union {
    LetNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LetNodeDefaultTypeInternal _LetNode_default_instance_;
PROTOBUF_CONSTEXPR LetfnNode::LetfnNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.bindings_)*/{}
  , /*decltype(_impl_.body_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LetfnNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LetfnNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LetfnNodeDefaultTypeInternal() {}
  union {
    LetfnNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LetfnNodeDefaultTypeInternal _LetfnNode_default_instance_;
PROTOBUF_CONSTEXPR LocalNode::LocalNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.argid_)*/0u
  , /*decltype(_impl_.local_)*/0
  , /*decltype(_impl_.isassignable_)*/false
  , /*decltype(_impl_.isvariadic_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LocalNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LocalNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LocalNodeDefaultTypeInternal() {}
  union {
    LocalNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LocalNodeDefaultTypeInternal _LocalNode_default_instance_;
PROTOBUF_CONSTEXPR LoopNode::LoopNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.bindings_)*/{}
  , /*decltype(_impl_.loopid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.body_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LoopNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LoopNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LoopNodeDefaultTypeInternal() {}
  union {
    LoopNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LoopNodeDefaultTypeInternal _LoopNode_default_instance_;
PROTOBUF_CONSTEXPR MapNode::MapNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.keys_)*/{}
  , /*decltype(_impl_.vals_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MapNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MapNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MapNodeDefaultTypeInternal() {}
  union {
    MapNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MapNodeDefaultTypeInternal _MapNode_default_instance_;
PROTOBUF_CONSTEXPR MethodNode::MethodNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.bridges_)*/{}
  , /*decltype(_impl_.params_)*/{}
  , /*decltype(_impl_.interface_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.loopid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.body_)*/nullptr
  , /*decltype(_impl_.this__)*/nullptr
  , /*decltype(_impl_.fixedarity_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MethodNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MethodNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MethodNodeDefaultTypeInternal() {}
  union {
    MethodNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MethodNodeDefaultTypeInternal _MethodNode_default_instance_;
PROTOBUF_CONSTEXPR MonitorEnterNode::MonitorEnterNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.target_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MonitorEnterNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MonitorEnterNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MonitorEnterNodeDefaultTypeInternal() {}
  union {
    MonitorEnterNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MonitorEnterNodeDefaultTypeInternal _MonitorEnterNode_default_instance_;
PROTOBUF_CONSTEXPR MonitorExitNode::MonitorExitNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.target_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MonitorExitNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MonitorExitNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MonitorExitNodeDefaultTypeInternal() {}
  union {
    MonitorExitNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MonitorExitNodeDefaultTypeInternal _MonitorExitNode_default_instance_;
PROTOBUF_CONSTEXPR NewNode::NewNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.args_)*/{}
  , /*decltype(_impl_.class__)*/nullptr
  , /*decltype(_impl_.isvalidated_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NewNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NewNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NewNodeDefaultTypeInternal() {}
  union {
    NewNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NewNodeDefaultTypeInternal _NewNode_default_instance_;
PROTOBUF_CONSTEXPR PrimInvokeNode::PrimInvokeNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.args_)*/{}
  , /*decltype(_impl_.meta_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.priminterface_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.fn_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PrimInvokeNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PrimInvokeNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PrimInvokeNodeDefaultTypeInternal() {}
  union {
    PrimInvokeNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PrimInvokeNodeDefaultTypeInternal _PrimInvokeNode_default_instance_;
PROTOBUF_CONSTEXPR ProtocolInvokeNode::ProtocolInvokeNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.args_)*/{}
  , /*decltype(_impl_.protocolfn_)*/nullptr
  , /*decltype(_impl_.target_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ProtocolInvokeNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ProtocolInvokeNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ProtocolInvokeNodeDefaultTypeInternal() {}
  union {
    ProtocolInvokeNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ProtocolInvokeNodeDefaultTypeInternal _ProtocolInvokeNode_default_instance_;
PROTOBUF_CONSTEXPR QuoteNode::QuoteNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.expr_)*/nullptr
  , /*decltype(_impl_.isliteral_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct QuoteNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR QuoteNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~QuoteNodeDefaultTypeInternal() {}
  union {
    QuoteNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 QuoteNodeDefaultTypeInternal _QuoteNode_default_instance_;
PROTOBUF_CONSTEXPR RecurNode::RecurNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.exprs_)*/{}
  , /*decltype(_impl_.loopid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RecurNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RecurNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RecurNodeDefaultTypeInternal() {}
  union {
    RecurNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RecurNodeDefaultTypeInternal _RecurNode_default_instance_;
PROTOBUF_CONSTEXPR ReifyNode::ReifyNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.interfaces_)*/{}
  , /*decltype(_impl_.methods_)*/{}
  , /*decltype(_impl_.classname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ReifyNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReifyNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReifyNodeDefaultTypeInternal() {}
  union {
    ReifyNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReifyNodeDefaultTypeInternal _ReifyNode_default_instance_;
PROTOBUF_CONSTEXPR SetNode::SetNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.items_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SetNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SetNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SetNodeDefaultTypeInternal() {}
  union {
    SetNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SetNodeDefaultTypeInternal _SetNode_default_instance_;
PROTOBUF_CONSTEXPR MutateSetNode::MutateSetNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.target_)*/nullptr
  , /*decltype(_impl_.val_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MutateSetNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MutateSetNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MutateSetNodeDefaultTypeInternal() {}
  union {
    MutateSetNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MutateSetNodeDefaultTypeInternal _MutateSetNode_default_instance_;
PROTOBUF_CONSTEXPR StaticCallNode::StaticCallNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.args_)*/{}
  , /*decltype(_impl_.class__)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.method_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.isvalidated_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StaticCallNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StaticCallNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StaticCallNodeDefaultTypeInternal() {}
  union {
    StaticCallNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StaticCallNodeDefaultTypeInternal _StaticCallNode_default_instance_;
PROTOBUF_CONSTEXPR StaticFieldNode::StaticFieldNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.class__)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.field_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.isassignable_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StaticFieldNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StaticFieldNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StaticFieldNodeDefaultTypeInternal() {}
  union {
    StaticFieldNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StaticFieldNodeDefaultTypeInternal _StaticFieldNode_default_instance_;
PROTOBUF_CONSTEXPR TheVarNode::TheVarNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.var_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TheVarNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TheVarNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TheVarNodeDefaultTypeInternal() {}
  union {
    TheVarNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TheVarNodeDefaultTypeInternal _TheVarNode_default_instance_;
PROTOBUF_CONSTEXPR ThrowNode::ThrowNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.exception_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ThrowNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ThrowNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ThrowNodeDefaultTypeInternal() {}
  union {
    ThrowNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ThrowNodeDefaultTypeInternal _ThrowNode_default_instance_;
PROTOBUF_CONSTEXPR TryNode::TryNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.catches_)*/{}
  , /*decltype(_impl_.body_)*/nullptr
  , /*decltype(_impl_.finally_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TryNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TryNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TryNodeDefaultTypeInternal() {}
  union {
    TryNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TryNodeDefaultTypeInternal _TryNode_default_instance_;
PROTOBUF_CONSTEXPR VarNode::VarNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.var_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.isassignable_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct VarNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VarNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VarNodeDefaultTypeInternal() {}
  union {
    VarNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VarNodeDefaultTypeInternal _VarNode_default_instance_;
PROTOBUF_CONSTEXPR VectorNode::VectorNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.items_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct VectorNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VectorNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VectorNodeDefaultTypeInternal() {}
  union {
    VectorNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VectorNodeDefaultTypeInternal _VectorNode_default_instance_;
PROTOBUF_CONSTEXPR WithMetaNode::WithMetaNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.expr_)*/nullptr
  , /*decltype(_impl_.meta_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct WithMetaNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WithMetaNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~WithMetaNodeDefaultTypeInternal() {}
  union {
    WithMetaNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WithMetaNodeDefaultTypeInternal _WithMetaNode_default_instance_;
PROTOBUF_CONSTEXPR Node::Node(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.loops_)*/{}
  , /*decltype(_impl_.rawforms_)*/{}
  , /*decltype(_impl_.form_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.otag_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.tag_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.env_)*/nullptr
  , /*decltype(_impl_.subnode_)*/nullptr
  , /*decltype(_impl_.op_)*/0
  , /*decltype(_impl_.ignoretag_)*/false
  , /*decltype(_impl_.toplevel_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NodeDefaultTypeInternal() {}
  union {
    Node _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NodeDefaultTypeInternal _Node_default_instance_;
PROTOBUF_CONSTEXPR Programme::Programme(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.nodes_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ProgrammeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ProgrammeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ProgrammeDefaultTypeInternal() {}
  union {
    Programme _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ProgrammeDefaultTypeInternal _Programme_default_instance_;
}  // namespace bytecode
}  // namespace protobuf
}  // namespace rt
}  // namespace clojure
static ::_pb::Metadata file_level_metadata_bytecode_2eproto[47];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_bytecode_2eproto[5];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_bytecode_2eproto = nullptr;

const uint32_t TableStruct_bytecode_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::Environment, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::Environment, _impl_.context_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::Environment, _impl_.locals_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::Environment, _impl_.ns_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::Environment, _impl_.column_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::Environment, _impl_.line_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::Environment, _impl_.endcolumn_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::Environment, _impl_.endline_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::Environment, _impl_.file_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::Subnode, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::Subnode, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::Subnode, _impl_.types_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::BindingNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::BindingNode, _impl_.argid_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::BindingNode, _impl_.init_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::BindingNode, _impl_.local_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::BindingNode, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::BindingNode, _impl_.isvariadic_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::CaseNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::CaseNode, _impl_.default__),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::CaseNode, _impl_.high_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::CaseNode, _impl_.low_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::CaseNode, _impl_.mask_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::CaseNode, _impl_.shift_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::CaseNode, _impl_.isskipcheck_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::CaseNode, _impl_.switchtype_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::CaseNode, _impl_.test_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::CaseNode, _impl_.testtype_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::CaseNode, _impl_.tests_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::CaseNode, _impl_.thens_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::CaseTestNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::CaseTestNode, _impl_.hash_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::CaseTestNode, _impl_.test_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::CaseThenNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::CaseThenNode, _impl_.hash_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::CaseThenNode, _impl_.then_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::CatchNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::CatchNode, _impl_.body_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::CatchNode, _impl_.class__),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::CatchNode, _impl_.local_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::ConstNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::ConstNode, _impl_.isliteral_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::ConstNode, _impl_.meta_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::ConstNode, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::ConstNode, _impl_.val_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::DefNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::DefNode, _impl_.doc_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::DefNode, _impl_.init_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::DefNode, _impl_.meta_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::DefNode, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::DefNode, _impl_.var_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::DeftypeNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::DeftypeNode, _impl_.classname_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::DeftypeNode, _impl_.fields_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::DeftypeNode, _impl_.interfaces_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::DeftypeNode, _impl_.methods_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::DeftypeNode, _impl_.name_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::DoNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::DoNode, _impl_.isbody_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::DoNode, _impl_.ret_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::DoNode, _impl_.statements_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::FnNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::FnNode, _impl_.local_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::FnNode, _impl_.maxfixedarity_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::FnNode, _impl_.methods_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::FnNode, _impl_.once_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::FnNode, _impl_.isvariadic_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::FnMethodNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::FnMethodNode, _impl_.body_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::FnMethodNode, _impl_.fixedarity_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::FnMethodNode, _impl_.loopid_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::FnMethodNode, _impl_.params_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::FnMethodNode, _impl_.isvariadic_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::HostInteropNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::HostInteropNode, _impl_.isassignable_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::HostInteropNode, _impl_.morf_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::HostInteropNode, _impl_.target_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::IfNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::IfNode, _impl_.else__),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::IfNode, _impl_.test_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::IfNode, _impl_.then_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::ImportNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::ImportNode, _impl_.class__),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::InstanceCallNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::InstanceCallNode, _impl_.args_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::InstanceCallNode, _impl_.class__),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::InstanceCallNode, _impl_.instance_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::InstanceCallNode, _impl_.method_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::InstanceCallNode, _impl_.isvalidated_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::InstanceFieldNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::InstanceFieldNode, _impl_.isassignable_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::InstanceFieldNode, _impl_.class__),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::InstanceFieldNode, _impl_.field_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::InstanceFieldNode, _impl_.instance_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::IsInstanceNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::IsInstanceNode, _impl_.class__),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::IsInstanceNode, _impl_.target_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::InvokeNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::InvokeNode, _impl_.args_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::InvokeNode, _impl_.fn_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::InvokeNode, _impl_.meta_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::KeywordInvokeNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::KeywordInvokeNode, _impl_.keyword_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::KeywordInvokeNode, _impl_.target_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::LetNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::LetNode, _impl_.bindings_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::LetNode, _impl_.body_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::LetfnNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::LetfnNode, _impl_.bindings_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::LetfnNode, _impl_.body_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::LocalNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::LocalNode, _impl_.argid_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::LocalNode, _impl_.isassignable_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::LocalNode, _impl_.local_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::LocalNode, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::LocalNode, _impl_.isvariadic_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::LoopNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::LoopNode, _impl_.bindings_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::LoopNode, _impl_.body_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::LoopNode, _impl_.loopid_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::MapNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::MapNode, _impl_.keys_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::MapNode, _impl_.vals_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::MethodNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::MethodNode, _impl_.body_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::MethodNode, _impl_.bridges_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::MethodNode, _impl_.fixedarity_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::MethodNode, _impl_.interface_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::MethodNode, _impl_.loopid_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::MethodNode, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::MethodNode, _impl_.params_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::MethodNode, _impl_.this__),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::MonitorEnterNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::MonitorEnterNode, _impl_.target_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::MonitorExitNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::MonitorExitNode, _impl_.target_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::NewNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::NewNode, _impl_.args_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::NewNode, _impl_.class__),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::NewNode, _impl_.isvalidated_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::PrimInvokeNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::PrimInvokeNode, _impl_.args_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::PrimInvokeNode, _impl_.fn_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::PrimInvokeNode, _impl_.meta_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::PrimInvokeNode, _impl_.priminterface_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::ProtocolInvokeNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::ProtocolInvokeNode, _impl_.args_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::ProtocolInvokeNode, _impl_.protocolfn_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::ProtocolInvokeNode, _impl_.target_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::QuoteNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::QuoteNode, _impl_.expr_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::QuoteNode, _impl_.isliteral_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::RecurNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::RecurNode, _impl_.exprs_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::RecurNode, _impl_.loopid_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::ReifyNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::ReifyNode, _impl_.classname_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::ReifyNode, _impl_.interfaces_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::ReifyNode, _impl_.methods_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::SetNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::SetNode, _impl_.items_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::MutateSetNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::MutateSetNode, _impl_.target_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::MutateSetNode, _impl_.val_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::StaticCallNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::StaticCallNode, _impl_.args_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::StaticCallNode, _impl_.class__),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::StaticCallNode, _impl_.method_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::StaticCallNode, _impl_.isvalidated_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::StaticFieldNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::StaticFieldNode, _impl_.isassignable_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::StaticFieldNode, _impl_.class__),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::StaticFieldNode, _impl_.field_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::TheVarNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::TheVarNode, _impl_.var_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::ThrowNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::ThrowNode, _impl_.exception_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::TryNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::TryNode, _impl_.body_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::TryNode, _impl_.catches_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::TryNode, _impl_.finally_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::VarNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::VarNode, _impl_.isassignable_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::VarNode, _impl_.var_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::VectorNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::VectorNode, _impl_.items_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::WithMetaNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::WithMetaNode, _impl_.expr_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::WithMetaNode, _impl_.meta_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::Node, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::Node, _impl_.env_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::Node, _impl_.form_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::Node, _impl_.ignoretag_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::Node, _impl_.loops_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::Node, _impl_.otag_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::Node, _impl_.op_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::Node, _impl_.rawforms_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::Node, _impl_.subnode_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::Node, _impl_.tag_),
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::Node, _impl_.toplevel_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::Programme, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::clojure::rt::protobuf::bytecode::Programme, _impl_.nodes_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::clojure::rt::protobuf::bytecode::Environment)},
  { 14, -1, -1, sizeof(::clojure::rt::protobuf::bytecode::Subnode)},
  { 64, -1, -1, sizeof(::clojure::rt::protobuf::bytecode::BindingNode)},
  { 75, -1, -1, sizeof(::clojure::rt::protobuf::bytecode::CaseNode)},
  { 92, -1, -1, sizeof(::clojure::rt::protobuf::bytecode::CaseTestNode)},
  { 100, -1, -1, sizeof(::clojure::rt::protobuf::bytecode::CaseThenNode)},
  { 108, -1, -1, sizeof(::clojure::rt::protobuf::bytecode::CatchNode)},
  { 117, -1, -1, sizeof(::clojure::rt::protobuf::bytecode::ConstNode)},
  { 127, -1, -1, sizeof(::clojure::rt::protobuf::bytecode::DefNode)},
  { 138, -1, -1, sizeof(::clojure::rt::protobuf::bytecode::DeftypeNode)},
  { 149, -1, -1, sizeof(::clojure::rt::protobuf::bytecode::DoNode)},
  { 158, -1, -1, sizeof(::clojure::rt::protobuf::bytecode::FnNode)},
  { 169, -1, -1, sizeof(::clojure::rt::protobuf::bytecode::FnMethodNode)},
  { 180, -1, -1, sizeof(::clojure::rt::protobuf::bytecode::HostInteropNode)},
  { 189, -1, -1, sizeof(::clojure::rt::protobuf::bytecode::IfNode)},
  { 198, -1, -1, sizeof(::clojure::rt::protobuf::bytecode::ImportNode)},
  { 205, -1, -1, sizeof(::clojure::rt::protobuf::bytecode::InstanceCallNode)},
  { 216, -1, -1, sizeof(::clojure::rt::protobuf::bytecode::InstanceFieldNode)},
  { 226, -1, -1, sizeof(::clojure::rt::protobuf::bytecode::IsInstanceNode)},
  { 234, -1, -1, sizeof(::clojure::rt::protobuf::bytecode::InvokeNode)},
  { 243, -1, -1, sizeof(::clojure::rt::protobuf::bytecode::KeywordInvokeNode)},
  { 251, -1, -1, sizeof(::clojure::rt::protobuf::bytecode::LetNode)},
  { 259, -1, -1, sizeof(::clojure::rt::protobuf::bytecode::LetfnNode)},
  { 267, -1, -1, sizeof(::clojure::rt::protobuf::bytecode::LocalNode)},
  { 278, -1, -1, sizeof(::clojure::rt::protobuf::bytecode::LoopNode)},
  { 287, -1, -1, sizeof(::clojure::rt::protobuf::bytecode::MapNode)},
  { 295, -1, -1, sizeof(::clojure::rt::protobuf::bytecode::MethodNode)},
  { 309, -1, -1, sizeof(::clojure::rt::protobuf::bytecode::MonitorEnterNode)},
  { 316, -1, -1, sizeof(::clojure::rt::protobuf::bytecode::MonitorExitNode)},
  { 323, -1, -1, sizeof(::clojure::rt::protobuf::bytecode::NewNode)},
  { 332, -1, -1, sizeof(::clojure::rt::protobuf::bytecode::PrimInvokeNode)},
  { 342, -1, -1, sizeof(::clojure::rt::protobuf::bytecode::ProtocolInvokeNode)},
  { 351, -1, -1, sizeof(::clojure::rt::protobuf::bytecode::QuoteNode)},
  { 359, -1, -1, sizeof(::clojure::rt::protobuf::bytecode::RecurNode)},
  { 367, -1, -1, sizeof(::clojure::rt::protobuf::bytecode::ReifyNode)},
  { 376, -1, -1, sizeof(::clojure::rt::protobuf::bytecode::SetNode)},
  { 383, -1, -1, sizeof(::clojure::rt::protobuf::bytecode::MutateSetNode)},
  { 391, -1, -1, sizeof(::clojure::rt::protobuf::bytecode::StaticCallNode)},
  { 401, -1, -1, sizeof(::clojure::rt::protobuf::bytecode::StaticFieldNode)},
  { 410, -1, -1, sizeof(::clojure::rt::protobuf::bytecode::TheVarNode)},
  { 417, -1, -1, sizeof(::clojure::rt::protobuf::bytecode::ThrowNode)},
  { 424, -1, -1, sizeof(::clojure::rt::protobuf::bytecode::TryNode)},
  { 433, -1, -1, sizeof(::clojure::rt::protobuf::bytecode::VarNode)},
  { 441, -1, -1, sizeof(::clojure::rt::protobuf::bytecode::VectorNode)},
  { 448, -1, -1, sizeof(::clojure::rt::protobuf::bytecode::WithMetaNode)},
  { 456, -1, -1, sizeof(::clojure::rt::protobuf::bytecode::Node)},
  { 472, -1, -1, sizeof(::clojure::rt::protobuf::bytecode::Programme)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::clojure::rt::protobuf::bytecode::_Environment_default_instance_._instance,
  &::clojure::rt::protobuf::bytecode::_Subnode_default_instance_._instance,
  &::clojure::rt::protobuf::bytecode::_BindingNode_default_instance_._instance,
  &::clojure::rt::protobuf::bytecode::_CaseNode_default_instance_._instance,
  &::clojure::rt::protobuf::bytecode::_CaseTestNode_default_instance_._instance,
  &::clojure::rt::protobuf::bytecode::_CaseThenNode_default_instance_._instance,
  &::clojure::rt::protobuf::bytecode::_CatchNode_default_instance_._instance,
  &::clojure::rt::protobuf::bytecode::_ConstNode_default_instance_._instance,
  &::clojure::rt::protobuf::bytecode::_DefNode_default_instance_._instance,
  &::clojure::rt::protobuf::bytecode::_DeftypeNode_default_instance_._instance,
  &::clojure::rt::protobuf::bytecode::_DoNode_default_instance_._instance,
  &::clojure::rt::protobuf::bytecode::_FnNode_default_instance_._instance,
  &::clojure::rt::protobuf::bytecode::_FnMethodNode_default_instance_._instance,
  &::clojure::rt::protobuf::bytecode::_HostInteropNode_default_instance_._instance,
  &::clojure::rt::protobuf::bytecode::_IfNode_default_instance_._instance,
  &::clojure::rt::protobuf::bytecode::_ImportNode_default_instance_._instance,
  &::clojure::rt::protobuf::bytecode::_InstanceCallNode_default_instance_._instance,
  &::clojure::rt::protobuf::bytecode::_InstanceFieldNode_default_instance_._instance,
  &::clojure::rt::protobuf::bytecode::_IsInstanceNode_default_instance_._instance,
  &::clojure::rt::protobuf::bytecode::_InvokeNode_default_instance_._instance,
  &::clojure::rt::protobuf::bytecode::_KeywordInvokeNode_default_instance_._instance,
  &::clojure::rt::protobuf::bytecode::_LetNode_default_instance_._instance,
  &::clojure::rt::protobuf::bytecode::_LetfnNode_default_instance_._instance,
  &::clojure::rt::protobuf::bytecode::_LocalNode_default_instance_._instance,
  &::clojure::rt::protobuf::bytecode::_LoopNode_default_instance_._instance,
  &::clojure::rt::protobuf::bytecode::_MapNode_default_instance_._instance,
  &::clojure::rt::protobuf::bytecode::_MethodNode_default_instance_._instance,
  &::clojure::rt::protobuf::bytecode::_MonitorEnterNode_default_instance_._instance,
  &::clojure::rt::protobuf::bytecode::_MonitorExitNode_default_instance_._instance,
  &::clojure::rt::protobuf::bytecode::_NewNode_default_instance_._instance,
  &::clojure::rt::protobuf::bytecode::_PrimInvokeNode_default_instance_._instance,
  &::clojure::rt::protobuf::bytecode::_ProtocolInvokeNode_default_instance_._instance,
  &::clojure::rt::protobuf::bytecode::_QuoteNode_default_instance_._instance,
  &::clojure::rt::protobuf::bytecode::_RecurNode_default_instance_._instance,
  &::clojure::rt::protobuf::bytecode::_ReifyNode_default_instance_._instance,
  &::clojure::rt::protobuf::bytecode::_SetNode_default_instance_._instance,
  &::clojure::rt::protobuf::bytecode::_MutateSetNode_default_instance_._instance,
  &::clojure::rt::protobuf::bytecode::_StaticCallNode_default_instance_._instance,
  &::clojure::rt::protobuf::bytecode::_StaticFieldNode_default_instance_._instance,
  &::clojure::rt::protobuf::bytecode::_TheVarNode_default_instance_._instance,
  &::clojure::rt::protobuf::bytecode::_ThrowNode_default_instance_._instance,
  &::clojure::rt::protobuf::bytecode::_TryNode_default_instance_._instance,
  &::clojure::rt::protobuf::bytecode::_VarNode_default_instance_._instance,
  &::clojure::rt::protobuf::bytecode::_VectorNode_default_instance_._instance,
  &::clojure::rt::protobuf::bytecode::_WithMetaNode_default_instance_._instance,
  &::clojure::rt::protobuf::bytecode::_Node_default_instance_._instance,
  &::clojure::rt::protobuf::bytecode::_Programme_default_instance_._instance,
};

const char descriptor_table_protodef_bytecode_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\016bytecode.proto\022\034clojure.rt.protobuf.by"
  "tecode\"\212\001\n\013Environment\022\017\n\007context\030\001 \001(\t\022"
  "\016\n\006locals\030\002 \003(\t\022\n\n\002ns\030\003 \001(\t\022\016\n\006column\030\004 "
  "\001(\r\022\014\n\004line\030\005 \001(\r\022\021\n\tendColumn\030\006 \001(\r\022\017\n\007"
  "endLine\030\007 \001(\r\022\014\n\004file\030\010 \001(\t\"\340\024\n\007Subnode\022"
  "<\n\007binding\030\001 \001(\0132).clojure.rt.protobuf.b"
  "ytecode.BindingNodeH\000\0226\n\004case\030\002 \001(\0132&.cl"
  "ojure.rt.protobuf.bytecode.CaseNodeH\000\022>\n"
  "\010caseTest\030\003 \001(\0132*.clojure.rt.protobuf.by"
  "tecode.CaseTestNodeH\000\022>\n\010caseThen\030\004 \001(\0132"
  "*.clojure.rt.protobuf.bytecode.CaseThenN"
  "odeH\000\0228\n\005catch\030\005 \001(\0132\'.clojure.rt.protob"
  "uf.bytecode.CatchNodeH\000\0228\n\005const\030\006 \001(\0132\'"
  ".clojure.rt.protobuf.bytecode.ConstNodeH"
  "\000\0224\n\003def\030\007 \001(\0132%.clojure.rt.protobuf.byt"
  "ecode.DefNodeH\000\022<\n\007deftype\030\010 \001(\0132).cloju"
  "re.rt.protobuf.bytecode.DeftypeNodeH\000\0222\n"
  "\002do\030\t \001(\0132$.clojure.rt.protobuf.bytecode"
  ".DoNodeH\000\0222\n\002fn\030\n \001(\0132$.clojure.rt.proto"
  "buf.bytecode.FnNodeH\000\022>\n\010fnMethod\030\013 \001(\0132"
  "*.clojure.rt.protobuf.bytecode.FnMethodN"
  "odeH\000\022D\n\013hostInterop\030\014 \001(\0132-.clojure.rt."
  "protobuf.bytecode.HostInteropNodeH\000\0222\n\002i"
  "f\030\r \001(\0132$.clojure.rt.protobuf.bytecode.I"
  "fNodeH\000\022:\n\006import\030\016 \001(\0132(.clojure.rt.pro"
  "tobuf.bytecode.ImportNodeH\000\022F\n\014instanceC"
  "all\030\017 \001(\0132..clojure.rt.protobuf.bytecode"
  ".InstanceCallNodeH\000\022H\n\rinstanceField\030\020 \001"
  "(\0132/.clojure.rt.protobuf.bytecode.Instan"
  "ceFieldNodeH\000\022B\n\nisInstance\030\021 \001(\0132,.cloj"
  "ure.rt.protobuf.bytecode.IsInstanceNodeH"
  "\000\022:\n\006invoke\030\022 \001(\0132(.clojure.rt.protobuf."
  "bytecode.InvokeNodeH\000\022H\n\rkeywordInvoke\030\023"
  " \001(\0132/.clojure.rt.protobuf.bytecode.Keyw"
  "ordInvokeNodeH\000\0224\n\003let\030\024 \001(\0132%.clojure.r"
  "t.protobuf.bytecode.LetNodeH\000\0228\n\005letfn\030\025"
  " \001(\0132\'.clojure.rt.protobuf.bytecode.Letf"
  "nNodeH\000\0228\n\005local\030\026 \001(\0132\'.clojure.rt.prot"
  "obuf.bytecode.LocalNodeH\000\0226\n\004loop\030\027 \001(\0132"
  "&.clojure.rt.protobuf.bytecode.LoopNodeH"
  "\000\0224\n\003map\030\030 \001(\0132%.clojure.rt.protobuf.byt"
  "ecode.MapNodeH\000\022:\n\006method\030\031 \001(\0132(.clojur"
  "e.rt.protobuf.bytecode.MethodNodeH\000\022F\n\014m"
  "onitorEnter\030\032 \001(\0132..clojure.rt.protobuf."
  "bytecode.MonitorEnterNodeH\000\022D\n\013monitorEx"
  "it\030\033 \001(\0132-.clojure.rt.protobuf.bytecode."
  "MonitorExitNodeH\000\0224\n\003new\030\034 \001(\0132%.clojure"
  ".rt.protobuf.bytecode.NewNodeH\000\022B\n\nprimI"
  "nvoke\030\035 \001(\0132,.clojure.rt.protobuf.byteco"
  "de.PrimInvokeNodeH\000\022J\n\016protocolInvoke\030\036 "
  "\001(\01320.clojure.rt.protobuf.bytecode.Proto"
  "colInvokeNodeH\000\0228\n\005quote\030\037 \001(\0132\'.clojure"
  ".rt.protobuf.bytecode.QuoteNodeH\000\0228\n\005rec"
  "ur\030  \001(\0132\'.clojure.rt.protobuf.bytecode."
  "RecurNodeH\000\0228\n\005reify\030! \001(\0132\'.clojure.rt."
  "protobuf.bytecode.ReifyNodeH\000\0224\n\003set\030\" \001"
  "(\0132%.clojure.rt.protobuf.bytecode.SetNod"
  "eH\000\022@\n\tmutateSet\030# \001(\0132+.clojure.rt.prot"
  "obuf.bytecode.MutateSetNodeH\000\022B\n\nstaticC"
  "all\030$ \001(\0132,.clojure.rt.protobuf.bytecode"
  ".StaticCallNodeH\000\022D\n\013staticField\030% \001(\0132-"
  ".clojure.rt.protobuf.bytecode.StaticFiel"
  "dNodeH\000\022:\n\006theVar\030& \001(\0132(.clojure.rt.pro"
  "tobuf.bytecode.TheVarNodeH\000\0228\n\005throw\030\' \001"
  "(\0132\'.clojure.rt.protobuf.bytecode.ThrowN"
  "odeH\000\0224\n\003try\030( \001(\0132%.clojure.rt.protobuf"
  ".bytecode.TryNodeH\000\0224\n\003var\030) \001(\0132%.cloju"
  "re.rt.protobuf.bytecode.VarNodeH\000\022:\n\006vec"
  "tor\030* \001(\0132(.clojure.rt.protobuf.bytecode"
  ".VectorNodeH\000\022>\n\010withMeta\030+ \001(\0132*.clojur"
  "e.rt.protobuf.bytecode.WithMetaNodeH\000B\007\n"
  "\005types\"\250\001\n\013BindingNode\022\r\n\005argId\030\001 \001(\r\0220\n"
  "\004init\030\002 \001(\0132\".clojure.rt.protobuf.byteco"
  "de.Node\0226\n\005local\030\003 \001(\0162\'.clojure.rt.prot"
  "obuf.bytecode.LocalType\022\014\n\004name\030\004 \001(\t\022\022\n"
  "\nisVariadic\030\005 \001(\010\"\267\004\n\010CaseNode\0223\n\007defaul"
  "t\030\001 \001(\0132\".clojure.rt.protobuf.bytecode.N"
  "ode\022\014\n\004high\030\002 \001(\t\022\013\n\003low\030\003 \001(\t\022\014\n\004mask\030\004"
  " \001(\r\022\r\n\005shift\030\005 \001(\r\022\023\n\013isSkipCheck\030\006 \001(\t"
  "\022E\n\nswitchType\030\007 \001(\01621.clojure.rt.protob"
  "uf.bytecode.CaseNode.SwitchType\0220\n\004test\030"
  "\010 \001(\0132\".clojure.rt.protobuf.bytecode.Nod"
  "e\022A\n\010testType\030\t \001(\0162/.clojure.rt.protobu"
  "f.bytecode.CaseNode.TestType\0221\n\005tests\030\n "
  "\003(\0132\".clojure.rt.protobuf.bytecode.Node\022"
  "1\n\005thens\030\013 \003(\0132\".clojure.rt.protobuf.byt"
  "ecode.Node\"9\n\nSwitchType\022\024\n\020switchTypeSp"
  "arse\020\000\022\025\n\021switchTypeCompact\020\001\"L\n\010TestTyp"
  "e\022\017\n\013testTypeInt\020\000\022\025\n\021testTypeHashEquiv\020"
  "\001\022\030\n\024testTypeHashIdentity\020\002\"N\n\014CaseTestN"
  "ode\022\014\n\004hash\030\001 \001(\r\0220\n\004test\030\002 \001(\0132\".clojur"
  "e.rt.protobuf.bytecode.Node\"N\n\014CaseThenN"
  "ode\022\014\n\004hash\030\001 \001(\r\0220\n\004then\030\002 \001(\0132\".clojur"
  "e.rt.protobuf.bytecode.Node\"\243\001\n\tCatchNod"
  "e\0220\n\004body\030\001 \001(\0132\".clojure.rt.protobuf.by"
  "tecode.Node\0221\n\005class\030\002 \001(\0132\".clojure.rt."
  "protobuf.bytecode.Node\0221\n\005local\030\003 \001(\0132\"."
  "clojure.rt.protobuf.bytecode.Node\"\374\003\n\tCo"
  "nstNode\022\021\n\tisLiteral\030\001 \001(\010\0220\n\004meta\030\002 \001(\013"
  "2\".clojure.rt.protobuf.bytecode.Node\022\?\n\004"
  "type\030\003 \001(\01621.clojure.rt.protobuf.bytecod"
  "e.ConstNode.ConstType\022\013\n\003val\030\004 \001(\t\"\333\002\n\tC"
  "onstType\022\020\n\014constTypeNil\020\000\022\021\n\rconstTypeB"
  "ool\020\001\022\024\n\020constTypeKeyword\020\002\022\023\n\017constType"
  "Symbol\020\003\022\023\n\017constTypeString\020\004\022\023\n\017constTy"
  "peNumber\020\005\022\021\n\rconstTypeType\020\006\022\023\n\017constTy"
  "peRecord\020\007\022\020\n\014constTypeMap\020\010\022\023\n\017constTyp"
  "eVector\020\t\022\020\n\014constTypeSet\020\n\022\020\n\014constType"
  "Seq\020\013\022\021\n\rconstTypeChar\020\014\022\022\n\016constTypeReg"
  "ex\020\r\022\022\n\016constTypeClass\020\016\022\020\n\014constTypeVar"
  "\020\017\022\024\n\020constTypeUnknown\020\020\"\225\001\n\007DefNode\022\013\n\003"
  "doc\030\001 \001(\t\0220\n\004init\030\002 \001(\0132\".clojure.rt.pro"
  "tobuf.bytecode.Node\0220\n\004meta\030\003 \001(\0132\".cloj"
  "ure.rt.protobuf.bytecode.Node\022\014\n\004name\030\004 "
  "\001(\t\022\013\n\003var\030\005 \001(\t\"\253\001\n\013DeftypeNode\022\021\n\tclas"
  "sName\030\001 \001(\t\0222\n\006fields\030\002 \003(\0132\".clojure.rt"
  ".protobuf.bytecode.Node\022\022\n\ninterfaces\030\003 "
  "\003(\t\0223\n\007methods\030\004 \003(\0132\".clojure.rt.protob"
  "uf.bytecode.Node\022\014\n\004name\030\005 \001(\t\"\201\001\n\006DoNod"
  "e\022\016\n\006isBody\030\001 \001(\010\022/\n\003ret\030\002 \001(\0132\".clojure"
  ".rt.protobuf.bytecode.Node\0226\n\nstatements"
  "\030\003 \003(\0132\".clojure.rt.protobuf.bytecode.No"
  "de\"\251\001\n\006FnNode\0221\n\005local\030\001 \001(\0132\".clojure.r"
  "t.protobuf.bytecode.Node\022\025\n\rmaxFixedArit"
  "y\030\002 \001(\r\0223\n\007methods\030\003 \003(\0132\".clojure.rt.pr"
  "otobuf.bytecode.Node\022\014\n\004once\030\004 \001(\010\022\022\n\nis"
  "Variadic\030\005 \001(\010\"\254\001\n\014FnMethodNode\0220\n\004body\030"
  "\001 \001(\0132\".clojure.rt.protobuf.bytecode.Nod"
  "e\022\022\n\nfixedArity\030\002 \001(\r\022\016\n\006loopId\030\003 \001(\t\0222\n"
  "\006params\030\004 \003(\0132\".clojure.rt.protobuf.byte"
  "code.Node\022\022\n\nisVariadic\030\005 \001(\010\"i\n\017HostInt"
  "eropNode\022\024\n\014isAssignable\030\001 \001(\010\022\014\n\004mOrF\030\002"
  " \001(\t\0222\n\006target\030\003 \001(\0132\".clojure.rt.protob"
  "uf.bytecode.Node\"\236\001\n\006IfNode\0220\n\004else\030\001 \001("
  "\0132\".clojure.rt.protobuf.bytecode.Node\0220\n"
  "\004test\030\002 \001(\0132\".clojure.rt.protobuf.byteco"
  "de.Node\0220\n\004then\030\003 \001(\0132\".clojure.rt.proto"
  "buf.bytecode.Node\"\033\n\nImportNode\022\r\n\005class"
  "\030\001 \001(\t\"\256\001\n\020InstanceCallNode\0220\n\004args\030\001 \003("
  "\0132\".clojure.rt.protobuf.bytecode.Node\022\r\n"
  "\005class\030\002 \001(\t\0224\n\010instance\030\003 \001(\0132\".clojure"
  ".rt.protobuf.bytecode.Node\022\016\n\006method\030\004 \001"
  "(\t\022\023\n\013isValidated\030\005 \001(\010\"}\n\021InstanceField"
  "Node\022\024\n\014isAssignable\030\001 \001(\010\022\r\n\005class\030\002 \001("
  "\t\022\r\n\005field\030\003 \001(\t\0224\n\010instance\030\004 \001(\0132\".clo"
  "jure.rt.protobuf.bytecode.Node\"S\n\016IsInst"
  "anceNode\022\r\n\005class\030\001 \001(\t\0222\n\006target\030\002 \001(\0132"
  "\".clojure.rt.protobuf.bytecode.Node\"|\n\nI"
  "nvokeNode\0220\n\004args\030\001 \003(\0132\".clojure.rt.pro"
  "tobuf.bytecode.Node\022.\n\002fn\030\002 \001(\0132\".clojur"
  "e.rt.protobuf.bytecode.Node\022\014\n\004meta\030\003 \001("
  "\t\"|\n\021KeywordInvokeNode\0223\n\007keyword\030\001 \001(\0132"
  "\".clojure.rt.protobuf.bytecode.Node\0222\n\006t"
  "arget\030\002 \001(\0132\".clojure.rt.protobuf.byteco"
  "de.Node\"q\n\007LetNode\0224\n\010bindings\030\001 \003(\0132\".c"
  "lojure.rt.protobuf.bytecode.Node\0220\n\004body"
  "\030\002 \001(\0132\".clojure.rt.protobuf.bytecode.No"
  "de\"s\n\tLetfnNode\0224\n\010bindings\030\001 \003(\0132\".cloj"
  "ure.rt.protobuf.bytecode.Node\0220\n\004body\030\002 "
  "\001(\0132\".clojure.rt.protobuf.bytecode.Node\""
  "\212\001\n\tLocalNode\022\r\n\005argId\030\001 \001(\r\022\024\n\014isAssign"
  "able\030\002 \001(\010\0226\n\005local\030\003 \001(\0162\'.clojure.rt.p"
  "rotobuf.bytecode.LocalType\022\014\n\004name\030\004 \001(\t"
  "\022\022\n\nisVariadic\030\005 \001(\010\"\202\001\n\010LoopNode\0224\n\010bin"
  "dings\030\001 \003(\0132\".clojure.rt.protobuf.byteco"
  "de.Node\0220\n\004body\030\002 \001(\0132\".clojure.rt.proto"
  "buf.bytecode.Node\022\016\n\006loopId\030\003 \001(\t\"m\n\007Map"
  "Node\0220\n\004keys\030\001 \003(\0132\".clojure.rt.protobuf"
  ".bytecode.Node\0220\n\004vals\030\002 \003(\0132\".clojure.r"
  "t.protobuf.bytecode.Node\"\372\001\n\nMethodNode\022"
  "0\n\004body\030\001 \001(\0132\".clojure.rt.protobuf.byte"
  "code.Node\022\017\n\007bridges\030\002 \003(\t\022\022\n\nfixedArity"
  "\030\003 \001(\r\022\021\n\tinterface\030\004 \001(\t\022\016\n\006loopId\030\005 \001("
  "\t\022\014\n\004name\030\006 \001(\t\0222\n\006params\030\007 \003(\0132\".clojur"
  "e.rt.protobuf.bytecode.Node\0220\n\004this\030\010 \001("
  "\0132\".clojure.rt.protobuf.bytecode.Node\"F\n"
  "\020MonitorEnterNode\0222\n\006target\030\001 \001(\0132\".cloj"
  "ure.rt.protobuf.bytecode.Node\"E\n\017Monitor"
  "ExitNode\0222\n\006target\030\001 \001(\0132\".clojure.rt.pr"
  "otobuf.bytecode.Node\"\203\001\n\007NewNode\0220\n\004args"
  "\030\001 \003(\0132\".clojure.rt.protobuf.bytecode.No"
  "de\0221\n\005class\030\002 \001(\0132\".clojure.rt.protobuf."
  "bytecode.Node\022\023\n\013isValidated\030\003 \001(\010\"\227\001\n\016P"
  "rimInvokeNode\0220\n\004args\030\001 \003(\0132\".clojure.rt"
  ".protobuf.bytecode.Node\022.\n\002fn\030\002 \001(\0132\".cl"
  "ojure.rt.protobuf.bytecode.Node\022\014\n\004meta\030"
  "\003 \001(\t\022\025\n\rprimInterface\030\004 \001(\t\"\262\001\n\022Protoco"
  "lInvokeNode\0220\n\004args\030\001 \003(\0132\".clojure.rt.p"
  "rotobuf.bytecode.Node\0226\n\nprotocolFn\030\002 \001("
  "\0132\".clojure.rt.protobuf.bytecode.Node\0222\n"
  "\006target\030\003 \001(\0132\".clojure.rt.protobuf.byte"
  "code.Node\"P\n\tQuoteNode\0220\n\004expr\030\001 \001(\0132\".c"
  "lojure.rt.protobuf.bytecode.Node\022\021\n\tisLi"
  "teral\030\002 \001(\010\"N\n\tRecurNode\0221\n\005exprs\030\001 \003(\0132"
  "\".clojure.rt.protobuf.bytecode.Node\022\016\n\006l"
  "oopId\030\002 \001(\t\"g\n\tReifyNode\022\021\n\tclassName\030\001 "
  "\001(\t\022\022\n\ninterfaces\030\002 \003(\t\0223\n\007methods\030\003 \003(\013"
  "2\".clojure.rt.protobuf.bytecode.Node\"<\n\007"
  "SetNode\0221\n\005items\030\001 \003(\0132\".clojure.rt.prot"
  "obuf.bytecode.Node\"t\n\rMutateSetNode\0222\n\006t"
  "arget\030\001 \001(\0132\".clojure.rt.protobuf.byteco"
  "de.Node\022/\n\003val\030\002 \001(\0132\".clojure.rt.protob"
  "uf.bytecode.Node\"v\n\016StaticCallNode\0220\n\004ar"
  "gs\030\001 \003(\0132\".clojure.rt.protobuf.bytecode."
  "Node\022\r\n\005class\030\002 \001(\t\022\016\n\006method\030\003 \001(\t\022\023\n\013i"
  "sValidated\030\004 \001(\010\"E\n\017StaticFieldNode\022\024\n\014i"
  "sAssignable\030\001 \001(\010\022\r\n\005class\030\002 \001(\t\022\r\n\005fiel"
  "d\030\003 \001(\t\"\031\n\nTheVarNode\022\013\n\003var\030\001 \001(\t\"B\n\tTh"
  "rowNode\0225\n\texception\030\001 \001(\0132\".clojure.rt."
  "protobuf.bytecode.Node\"\245\001\n\007TryNode\0220\n\004bo"
  "dy\030\001 \001(\0132\".clojure.rt.protobuf.bytecode."
  "Node\0223\n\007catches\030\002 \003(\0132\".clojure.rt.proto"
  "buf.bytecode.Node\0223\n\007finally\030\003 \001(\0132\".clo"
  "jure.rt.protobuf.bytecode.Node\",\n\007VarNod"
  "e\022\024\n\014isAssignable\030\001 \001(\010\022\013\n\003var\030\002 \001(\t\"\?\n\n"
  "VectorNode\0221\n\005items\030\001 \003(\0132\".clojure.rt.p"
  "rotobuf.bytecode.Node\"r\n\014WithMetaNode\0220\n"
  "\004expr\030\001 \001(\0132\".clojure.rt.protobuf.byteco"
  "de.Node\0220\n\004meta\030\002 \001(\0132\".clojure.rt.proto"
  "buf.bytecode.Node\"\223\002\n\004Node\0226\n\003env\030\001 \001(\0132"
  ").clojure.rt.protobuf.bytecode.Environme"
  "nt\022\014\n\004form\030\002 \001(\t\022\021\n\tignoreTag\030\003 \001(\010\022\r\n\005l"
  "oops\030\004 \003(\t\022\014\n\004oTag\030\005 \001(\t\022,\n\002op\030\006 \001(\0162 .c"
  "lojure.rt.protobuf.bytecode.Op\022\020\n\010rawFor"
  "ms\030\007 \003(\t\0226\n\007subnode\030\010 \001(\0132%.clojure.rt.p"
  "rotobuf.bytecode.Subnode\022\013\n\003tag\030\t \001(\t\022\020\n"
  "\010topLevel\030\n \001(\010\">\n\tProgramme\0221\n\005nodes\030\001 "
  "\003(\0132\".clojure.rt.protobuf.bytecode.Node*"
  "\373\004\n\002Op\022\r\n\topBinding\020\000\022\n\n\006opCase\020\001\022\016\n\nopC"
  "aseTest\020\002\022\016\n\nopCaseThen\020\003\022\013\n\007opCatch\020\004\022\013"
  "\n\007opConst\020\005\022\t\n\005opDef\020\006\022\r\n\topDeftype\020\007\022\010\n"
  "\004opDo\020\010\022\010\n\004opFn\020\t\022\016\n\nopFnMethod\020\n\022\021\n\ropH"
  "ostInterop\020\013\022\010\n\004opIf\020\014\022\014\n\010opImport\020\r\022\022\n\016"
  "opInstanceCall\020\016\022\023\n\017opInstanceField\020\017\022\020\n"
  "\014opIsInstance\020\020\022\014\n\010opInvoke\020\021\022\023\n\017opKeywo"
  "rdInvoke\020\022\022\t\n\005opLet\020\023\022\013\n\007opLetfn\020\024\022\013\n\007op"
  "Local\020\025\022\n\n\006opLoop\020\026\022\t\n\005opMap\020\027\022\014\n\010opMeth"
  "od\020\030\022\022\n\016opMonitorEnter\020\031\022\021\n\ropMonitorExi"
  "t\020\032\022\t\n\005opNew\020\033\022\020\n\014opPrimInvoke\020\034\022\024\n\020opPr"
  "otocolInvoke\020\035\022\013\n\007opQuote\020\036\022\013\n\007opRecur\020\037"
  "\022\013\n\007opReify\020 \022\t\n\005opSet\020!\022\017\n\013opMutateSet\020"
  "\"\022\020\n\014opStaticCall\020#\022\021\n\ropStaticField\020$\022\014"
  "\n\010opTheVar\020%\022\013\n\007opThrow\020&\022\t\n\005opTry\020\'\022\t\n\005"
  "opVar\020(\022\014\n\010opVector\020)\022\016\n\nopWithMeta\020**\242\001"
  "\n\tLocalType\022\020\n\014localTypeArg\020\000\022\022\n\016localTy"
  "peCatch\020\001\022\017\n\013localTypeFn\020\002\022\020\n\014localTypeL"
  "et\020\003\022\022\n\016localTypeLetfn\020\004\022\021\n\rlocalTypeLoo"
  "p\020\005\022\022\n\016localTypeField\020\006\022\021\n\rlocalTypeThis"
  "\020\007b\006proto3"
  ;
static ::_pbi::once_flag descriptor_table_bytecode_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_bytecode_2eproto = {
    false, false, 9930, descriptor_table_protodef_bytecode_2eproto,
    "bytecode.proto",
    &descriptor_table_bytecode_2eproto_once, nullptr, 0, 47,
    schemas, file_default_instances, TableStruct_bytecode_2eproto::offsets,
    file_level_metadata_bytecode_2eproto, file_level_enum_descriptors_bytecode_2eproto,
    file_level_service_descriptors_bytecode_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_bytecode_2eproto_getter() {
  return &descriptor_table_bytecode_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_bytecode_2eproto(&descriptor_table_bytecode_2eproto);
namespace clojure {
namespace rt {
namespace protobuf {
namespace bytecode {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CaseNode_SwitchType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_bytecode_2eproto);
  return file_level_enum_descriptors_bytecode_2eproto[0];
}
bool CaseNode_SwitchType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CaseNode_SwitchType CaseNode::switchTypeSparse;
constexpr CaseNode_SwitchType CaseNode::switchTypeCompact;
constexpr CaseNode_SwitchType CaseNode::SwitchType_MIN;
constexpr CaseNode_SwitchType CaseNode::SwitchType_MAX;
constexpr int CaseNode::SwitchType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CaseNode_TestType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_bytecode_2eproto);
  return file_level_enum_descriptors_bytecode_2eproto[1];
}
bool CaseNode_TestType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CaseNode_TestType CaseNode::testTypeInt;
constexpr CaseNode_TestType CaseNode::testTypeHashEquiv;
constexpr CaseNode_TestType CaseNode::testTypeHashIdentity;
constexpr CaseNode_TestType CaseNode::TestType_MIN;
constexpr CaseNode_TestType CaseNode::TestType_MAX;
constexpr int CaseNode::TestType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ConstNode_ConstType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_bytecode_2eproto);
  return file_level_enum_descriptors_bytecode_2eproto[2];
}
bool ConstNode_ConstType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ConstNode_ConstType ConstNode::constTypeNil;
constexpr ConstNode_ConstType ConstNode::constTypeBool;
constexpr ConstNode_ConstType ConstNode::constTypeKeyword;
constexpr ConstNode_ConstType ConstNode::constTypeSymbol;
constexpr ConstNode_ConstType ConstNode::constTypeString;
constexpr ConstNode_ConstType ConstNode::constTypeNumber;
constexpr ConstNode_ConstType ConstNode::constTypeType;
constexpr ConstNode_ConstType ConstNode::constTypeRecord;
constexpr ConstNode_ConstType ConstNode::constTypeMap;
constexpr ConstNode_ConstType ConstNode::constTypeVector;
constexpr ConstNode_ConstType ConstNode::constTypeSet;
constexpr ConstNode_ConstType ConstNode::constTypeSeq;
constexpr ConstNode_ConstType ConstNode::constTypeChar;
constexpr ConstNode_ConstType ConstNode::constTypeRegex;
constexpr ConstNode_ConstType ConstNode::constTypeClass;
constexpr ConstNode_ConstType ConstNode::constTypeVar;
constexpr ConstNode_ConstType ConstNode::constTypeUnknown;
constexpr ConstNode_ConstType ConstNode::ConstType_MIN;
constexpr ConstNode_ConstType ConstNode::ConstType_MAX;
constexpr int ConstNode::ConstType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Op_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_bytecode_2eproto);
  return file_level_enum_descriptors_bytecode_2eproto[3];
}
bool Op_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LocalType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_bytecode_2eproto);
  return file_level_enum_descriptors_bytecode_2eproto[4];
}
bool LocalType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class Environment::_Internal {
 public:
};

Environment::Environment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojure.rt.protobuf.bytecode.Environment)
}
Environment::Environment(const Environment& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Environment* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.locals_){from._impl_.locals_}
    , decltype(_impl_.context_){}
    , decltype(_impl_.ns_){}
    , decltype(_impl_.file_){}
    , decltype(_impl_.column_){}
    , decltype(_impl_.line_){}
    , decltype(_impl_.endcolumn_){}
    , decltype(_impl_.endline_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.context_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.context_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_context().empty()) {
    _this->_impl_.context_.Set(from._internal_context(), 
      _this->GetArenaForAllocation());
  }
  _impl_.ns_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ns_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_ns().empty()) {
    _this->_impl_.ns_.Set(from._internal_ns(), 
      _this->GetArenaForAllocation());
  }
  _impl_.file_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.file_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_file().empty()) {
    _this->_impl_.file_.Set(from._internal_file(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.column_, &from._impl_.column_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.endline_) -
    reinterpret_cast<char*>(&_impl_.column_)) + sizeof(_impl_.endline_));
  // @@protoc_insertion_point(copy_constructor:clojure.rt.protobuf.bytecode.Environment)
}

inline void Environment::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.locals_){arena}
    , decltype(_impl_.context_){}
    , decltype(_impl_.ns_){}
    , decltype(_impl_.file_){}
    , decltype(_impl_.column_){0u}
    , decltype(_impl_.line_){0u}
    , decltype(_impl_.endcolumn_){0u}
    , decltype(_impl_.endline_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.context_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.context_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.ns_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ns_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.file_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.file_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Environment::~Environment() {
  // @@protoc_insertion_point(destructor:clojure.rt.protobuf.bytecode.Environment)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Environment::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.locals_.~RepeatedPtrField();
  _impl_.context_.Destroy();
  _impl_.ns_.Destroy();
  _impl_.file_.Destroy();
}

void Environment::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Environment::Clear() {
// @@protoc_insertion_point(message_clear_start:clojure.rt.protobuf.bytecode.Environment)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.locals_.Clear();
  _impl_.context_.ClearToEmpty();
  _impl_.ns_.ClearToEmpty();
  _impl_.file_.ClearToEmpty();
  ::memset(&_impl_.column_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.endline_) -
      reinterpret_cast<char*>(&_impl_.column_)) + sizeof(_impl_.endline_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Environment::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string context = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_context();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojure.rt.protobuf.bytecode.Environment.context"));
        } else
          goto handle_unusual;
        continue;
      // repeated string locals = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_locals();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "clojure.rt.protobuf.bytecode.Environment.locals"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string ns = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_ns();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojure.rt.protobuf.bytecode.Environment.ns"));
        } else
          goto handle_unusual;
        continue;
      // uint32 column = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.column_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 line = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.line_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 endColumn = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.endcolumn_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 endLine = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.endline_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string file = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_file();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojure.rt.protobuf.bytecode.Environment.file"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Environment::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojure.rt.protobuf.bytecode.Environment)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string context = 1;
  if (!this->_internal_context().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_context().data(), static_cast<int>(this->_internal_context().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojure.rt.protobuf.bytecode.Environment.context");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_context(), target);
  }

  // repeated string locals = 2;
  for (int i = 0, n = this->_internal_locals_size(); i < n; i++) {
    const auto& s = this->_internal_locals(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojure.rt.protobuf.bytecode.Environment.locals");
    target = stream->WriteString(2, s, target);
  }

  // string ns = 3;
  if (!this->_internal_ns().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_ns().data(), static_cast<int>(this->_internal_ns().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojure.rt.protobuf.bytecode.Environment.ns");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_ns(), target);
  }

  // uint32 column = 4;
  if (this->_internal_column() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_column(), target);
  }

  // uint32 line = 5;
  if (this->_internal_line() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_line(), target);
  }

  // uint32 endColumn = 6;
  if (this->_internal_endcolumn() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_endcolumn(), target);
  }

  // uint32 endLine = 7;
  if (this->_internal_endline() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_endline(), target);
  }

  // string file = 8;
  if (!this->_internal_file().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_file().data(), static_cast<int>(this->_internal_file().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojure.rt.protobuf.bytecode.Environment.file");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_file(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojure.rt.protobuf.bytecode.Environment)
  return target;
}

size_t Environment::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojure.rt.protobuf.bytecode.Environment)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string locals = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.locals_.size());
  for (int i = 0, n = _impl_.locals_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.locals_.Get(i));
  }

  // string context = 1;
  if (!this->_internal_context().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_context());
  }

  // string ns = 3;
  if (!this->_internal_ns().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_ns());
  }

  // string file = 8;
  if (!this->_internal_file().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_file());
  }

  // uint32 column = 4;
  if (this->_internal_column() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_column());
  }

  // uint32 line = 5;
  if (this->_internal_line() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_line());
  }

  // uint32 endColumn = 6;
  if (this->_internal_endcolumn() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_endcolumn());
  }

  // uint32 endLine = 7;
  if (this->_internal_endline() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_endline());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Environment::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Environment::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Environment::GetClassData() const { return &_class_data_; }


void Environment::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Environment*>(&to_msg);
  auto& from = static_cast<const Environment&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojure.rt.protobuf.bytecode.Environment)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.locals_.MergeFrom(from._impl_.locals_);
  if (!from._internal_context().empty()) {
    _this->_internal_set_context(from._internal_context());
  }
  if (!from._internal_ns().empty()) {
    _this->_internal_set_ns(from._internal_ns());
  }
  if (!from._internal_file().empty()) {
    _this->_internal_set_file(from._internal_file());
  }
  if (from._internal_column() != 0) {
    _this->_internal_set_column(from._internal_column());
  }
  if (from._internal_line() != 0) {
    _this->_internal_set_line(from._internal_line());
  }
  if (from._internal_endcolumn() != 0) {
    _this->_internal_set_endcolumn(from._internal_endcolumn());
  }
  if (from._internal_endline() != 0) {
    _this->_internal_set_endline(from._internal_endline());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Environment::CopyFrom(const Environment& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojure.rt.protobuf.bytecode.Environment)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Environment::IsInitialized() const {
  return true;
}

void Environment::InternalSwap(Environment* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.locals_.InternalSwap(&other->_impl_.locals_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.context_, lhs_arena,
      &other->_impl_.context_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ns_, lhs_arena,
      &other->_impl_.ns_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.file_, lhs_arena,
      &other->_impl_.file_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Environment, _impl_.endline_)
      + sizeof(Environment::_impl_.endline_)
      - PROTOBUF_FIELD_OFFSET(Environment, _impl_.column_)>(
          reinterpret_cast<char*>(&_impl_.column_),
          reinterpret_cast<char*>(&other->_impl_.column_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Environment::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[0]);
}

// ===================================================================

class Subnode::_Internal {
 public:
  static const ::clojure::rt::protobuf::bytecode::BindingNode& binding(const Subnode* msg);
  static const ::clojure::rt::protobuf::bytecode::CaseNode& case_(const Subnode* msg);
  static const ::clojure::rt::protobuf::bytecode::CaseTestNode& casetest(const Subnode* msg);
  static const ::clojure::rt::protobuf::bytecode::CaseThenNode& casethen(const Subnode* msg);
  static const ::clojure::rt::protobuf::bytecode::CatchNode& catch_(const Subnode* msg);
  static const ::clojure::rt::protobuf::bytecode::ConstNode& const_(const Subnode* msg);
  static const ::clojure::rt::protobuf::bytecode::DefNode& def(const Subnode* msg);
  static const ::clojure::rt::protobuf::bytecode::DeftypeNode& deftype(const Subnode* msg);
  static const ::clojure::rt::protobuf::bytecode::DoNode& do_(const Subnode* msg);
  static const ::clojure::rt::protobuf::bytecode::FnNode& fn(const Subnode* msg);
  static const ::clojure::rt::protobuf::bytecode::FnMethodNode& fnmethod(const Subnode* msg);
  static const ::clojure::rt::protobuf::bytecode::HostInteropNode& hostinterop(const Subnode* msg);
  static const ::clojure::rt::protobuf::bytecode::IfNode& if_(const Subnode* msg);
  static const ::clojure::rt::protobuf::bytecode::ImportNode& import(const Subnode* msg);
  static const ::clojure::rt::protobuf::bytecode::InstanceCallNode& instancecall(const Subnode* msg);
  static const ::clojure::rt::protobuf::bytecode::InstanceFieldNode& instancefield(const Subnode* msg);
  static const ::clojure::rt::protobuf::bytecode::IsInstanceNode& isinstance(const Subnode* msg);
  static const ::clojure::rt::protobuf::bytecode::InvokeNode& invoke(const Subnode* msg);
  static const ::clojure::rt::protobuf::bytecode::KeywordInvokeNode& keywordinvoke(const Subnode* msg);
  static const ::clojure::rt::protobuf::bytecode::LetNode& let(const Subnode* msg);
  static const ::clojure::rt::protobuf::bytecode::LetfnNode& letfn(const Subnode* msg);
  static const ::clojure::rt::protobuf::bytecode::LocalNode& local(const Subnode* msg);
  static const ::clojure::rt::protobuf::bytecode::LoopNode& loop(const Subnode* msg);
  static const ::clojure::rt::protobuf::bytecode::MapNode& map(const Subnode* msg);
  static const ::clojure::rt::protobuf::bytecode::MethodNode& method(const Subnode* msg);
  static const ::clojure::rt::protobuf::bytecode::MonitorEnterNode& monitorenter(const Subnode* msg);
  static const ::clojure::rt::protobuf::bytecode::MonitorExitNode& monitorexit(const Subnode* msg);
  static const ::clojure::rt::protobuf::bytecode::NewNode& new_(const Subnode* msg);
  static const ::clojure::rt::protobuf::bytecode::PrimInvokeNode& priminvoke(const Subnode* msg);
  static const ::clojure::rt::protobuf::bytecode::ProtocolInvokeNode& protocolinvoke(const Subnode* msg);
  static const ::clojure::rt::protobuf::bytecode::QuoteNode& quote(const Subnode* msg);
  static const ::clojure::rt::protobuf::bytecode::RecurNode& recur(const Subnode* msg);
  static const ::clojure::rt::protobuf::bytecode::ReifyNode& reify(const Subnode* msg);
  static const ::clojure::rt::protobuf::bytecode::SetNode& set(const Subnode* msg);
  static const ::clojure::rt::protobuf::bytecode::MutateSetNode& mutateset(const Subnode* msg);
  static const ::clojure::rt::protobuf::bytecode::StaticCallNode& staticcall(const Subnode* msg);
  static const ::clojure::rt::protobuf::bytecode::StaticFieldNode& staticfield(const Subnode* msg);
  static const ::clojure::rt::protobuf::bytecode::TheVarNode& thevar(const Subnode* msg);
  static const ::clojure::rt::protobuf::bytecode::ThrowNode& throw_(const Subnode* msg);
  static const ::clojure::rt::protobuf::bytecode::TryNode& try_(const Subnode* msg);
  static const ::clojure::rt::protobuf::bytecode::VarNode& var(const Subnode* msg);
  static const ::clojure::rt::protobuf::bytecode::VectorNode& vector(const Subnode* msg);
  static const ::clojure::rt::protobuf::bytecode::WithMetaNode& withmeta(const Subnode* msg);
};

const ::clojure::rt::protobuf::bytecode::BindingNode&
Subnode::_Internal::binding(const Subnode* msg) {
  return *msg->_impl_.types_.binding_;
}
const ::clojure::rt::protobuf::bytecode::CaseNode&
Subnode::_Internal::case_(const Subnode* msg) {
  return *msg->_impl_.types_.case__;
}
const ::clojure::rt::protobuf::bytecode::CaseTestNode&
Subnode::_Internal::casetest(const Subnode* msg) {
  return *msg->_impl_.types_.casetest_;
}
const ::clojure::rt::protobuf::bytecode::CaseThenNode&
Subnode::_Internal::casethen(const Subnode* msg) {
  return *msg->_impl_.types_.casethen_;
}
const ::clojure::rt::protobuf::bytecode::CatchNode&
Subnode::_Internal::catch_(const Subnode* msg) {
  return *msg->_impl_.types_.catch__;
}
const ::clojure::rt::protobuf::bytecode::ConstNode&
Subnode::_Internal::const_(const Subnode* msg) {
  return *msg->_impl_.types_.const__;
}
const ::clojure::rt::protobuf::bytecode::DefNode&
Subnode::_Internal::def(const Subnode* msg) {
  return *msg->_impl_.types_.def_;
}
const ::clojure::rt::protobuf::bytecode::DeftypeNode&
Subnode::_Internal::deftype(const Subnode* msg) {
  return *msg->_impl_.types_.deftype_;
}
const ::clojure::rt::protobuf::bytecode::DoNode&
Subnode::_Internal::do_(const Subnode* msg) {
  return *msg->_impl_.types_.do__;
}
const ::clojure::rt::protobuf::bytecode::FnNode&
Subnode::_Internal::fn(const Subnode* msg) {
  return *msg->_impl_.types_.fn_;
}
const ::clojure::rt::protobuf::bytecode::FnMethodNode&
Subnode::_Internal::fnmethod(const Subnode* msg) {
  return *msg->_impl_.types_.fnmethod_;
}
const ::clojure::rt::protobuf::bytecode::HostInteropNode&
Subnode::_Internal::hostinterop(const Subnode* msg) {
  return *msg->_impl_.types_.hostinterop_;
}
const ::clojure::rt::protobuf::bytecode::IfNode&
Subnode::_Internal::if_(const Subnode* msg) {
  return *msg->_impl_.types_.if__;
}
const ::clojure::rt::protobuf::bytecode::ImportNode&
Subnode::_Internal::import(const Subnode* msg) {
  return *msg->_impl_.types_.import_;
}
const ::clojure::rt::protobuf::bytecode::InstanceCallNode&
Subnode::_Internal::instancecall(const Subnode* msg) {
  return *msg->_impl_.types_.instancecall_;
}
const ::clojure::rt::protobuf::bytecode::InstanceFieldNode&
Subnode::_Internal::instancefield(const Subnode* msg) {
  return *msg->_impl_.types_.instancefield_;
}
const ::clojure::rt::protobuf::bytecode::IsInstanceNode&
Subnode::_Internal::isinstance(const Subnode* msg) {
  return *msg->_impl_.types_.isinstance_;
}
const ::clojure::rt::protobuf::bytecode::InvokeNode&
Subnode::_Internal::invoke(const Subnode* msg) {
  return *msg->_impl_.types_.invoke_;
}
const ::clojure::rt::protobuf::bytecode::KeywordInvokeNode&
Subnode::_Internal::keywordinvoke(const Subnode* msg) {
  return *msg->_impl_.types_.keywordinvoke_;
}
const ::clojure::rt::protobuf::bytecode::LetNode&
Subnode::_Internal::let(const Subnode* msg) {
  return *msg->_impl_.types_.let_;
}
const ::clojure::rt::protobuf::bytecode::LetfnNode&
Subnode::_Internal::letfn(const Subnode* msg) {
  return *msg->_impl_.types_.letfn_;
}
const ::clojure::rt::protobuf::bytecode::LocalNode&
Subnode::_Internal::local(const Subnode* msg) {
  return *msg->_impl_.types_.local_;
}
const ::clojure::rt::protobuf::bytecode::LoopNode&
Subnode::_Internal::loop(const Subnode* msg) {
  return *msg->_impl_.types_.loop_;
}
const ::clojure::rt::protobuf::bytecode::MapNode&
Subnode::_Internal::map(const Subnode* msg) {
  return *msg->_impl_.types_.map_;
}
const ::clojure::rt::protobuf::bytecode::MethodNode&
Subnode::_Internal::method(const Subnode* msg) {
  return *msg->_impl_.types_.method_;
}
const ::clojure::rt::protobuf::bytecode::MonitorEnterNode&
Subnode::_Internal::monitorenter(const Subnode* msg) {
  return *msg->_impl_.types_.monitorenter_;
}
const ::clojure::rt::protobuf::bytecode::MonitorExitNode&
Subnode::_Internal::monitorexit(const Subnode* msg) {
  return *msg->_impl_.types_.monitorexit_;
}
const ::clojure::rt::protobuf::bytecode::NewNode&
Subnode::_Internal::new_(const Subnode* msg) {
  return *msg->_impl_.types_.new__;
}
const ::clojure::rt::protobuf::bytecode::PrimInvokeNode&
Subnode::_Internal::priminvoke(const Subnode* msg) {
  return *msg->_impl_.types_.priminvoke_;
}
const ::clojure::rt::protobuf::bytecode::ProtocolInvokeNode&
Subnode::_Internal::protocolinvoke(const Subnode* msg) {
  return *msg->_impl_.types_.protocolinvoke_;
}
const ::clojure::rt::protobuf::bytecode::QuoteNode&
Subnode::_Internal::quote(const Subnode* msg) {
  return *msg->_impl_.types_.quote_;
}
const ::clojure::rt::protobuf::bytecode::RecurNode&
Subnode::_Internal::recur(const Subnode* msg) {
  return *msg->_impl_.types_.recur_;
}
const ::clojure::rt::protobuf::bytecode::ReifyNode&
Subnode::_Internal::reify(const Subnode* msg) {
  return *msg->_impl_.types_.reify_;
}
const ::clojure::rt::protobuf::bytecode::SetNode&
Subnode::_Internal::set(const Subnode* msg) {
  return *msg->_impl_.types_.set_;
}
const ::clojure::rt::protobuf::bytecode::MutateSetNode&
Subnode::_Internal::mutateset(const Subnode* msg) {
  return *msg->_impl_.types_.mutateset_;
}
const ::clojure::rt::protobuf::bytecode::StaticCallNode&
Subnode::_Internal::staticcall(const Subnode* msg) {
  return *msg->_impl_.types_.staticcall_;
}
const ::clojure::rt::protobuf::bytecode::StaticFieldNode&
Subnode::_Internal::staticfield(const Subnode* msg) {
  return *msg->_impl_.types_.staticfield_;
}
const ::clojure::rt::protobuf::bytecode::TheVarNode&
Subnode::_Internal::thevar(const Subnode* msg) {
  return *msg->_impl_.types_.thevar_;
}
const ::clojure::rt::protobuf::bytecode::ThrowNode&
Subnode::_Internal::throw_(const Subnode* msg) {
  return *msg->_impl_.types_.throw__;
}
const ::clojure::rt::protobuf::bytecode::TryNode&
Subnode::_Internal::try_(const Subnode* msg) {
  return *msg->_impl_.types_.try__;
}
const ::clojure::rt::protobuf::bytecode::VarNode&
Subnode::_Internal::var(const Subnode* msg) {
  return *msg->_impl_.types_.var_;
}
const ::clojure::rt::protobuf::bytecode::VectorNode&
Subnode::_Internal::vector(const Subnode* msg) {
  return *msg->_impl_.types_.vector_;
}
const ::clojure::rt::protobuf::bytecode::WithMetaNode&
Subnode::_Internal::withmeta(const Subnode* msg) {
  return *msg->_impl_.types_.withmeta_;
}
void Subnode::set_allocated_binding(::clojure::rt::protobuf::bytecode::BindingNode* binding) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (binding) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(binding);
    if (message_arena != submessage_arena) {
      binding = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, binding, submessage_arena);
    }
    set_has_binding();
    _impl_.types_.binding_ = binding;
  }
  // @@protoc_insertion_point(field_set_allocated:clojure.rt.protobuf.bytecode.Subnode.binding)
}
void Subnode::set_allocated_case_(::clojure::rt::protobuf::bytecode::CaseNode* case_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (case_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(case_);
    if (message_arena != submessage_arena) {
      case_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, case_, submessage_arena);
    }
    set_has_case_();
    _impl_.types_.case__ = case_;
  }
  // @@protoc_insertion_point(field_set_allocated:clojure.rt.protobuf.bytecode.Subnode.case)
}
void Subnode::set_allocated_casetest(::clojure::rt::protobuf::bytecode::CaseTestNode* casetest) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (casetest) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(casetest);
    if (message_arena != submessage_arena) {
      casetest = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, casetest, submessage_arena);
    }
    set_has_casetest();
    _impl_.types_.casetest_ = casetest;
  }
  // @@protoc_insertion_point(field_set_allocated:clojure.rt.protobuf.bytecode.Subnode.caseTest)
}
void Subnode::set_allocated_casethen(::clojure::rt::protobuf::bytecode::CaseThenNode* casethen) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (casethen) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(casethen);
    if (message_arena != submessage_arena) {
      casethen = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, casethen, submessage_arena);
    }
    set_has_casethen();
    _impl_.types_.casethen_ = casethen;
  }
  // @@protoc_insertion_point(field_set_allocated:clojure.rt.protobuf.bytecode.Subnode.caseThen)
}
void Subnode::set_allocated_catch_(::clojure::rt::protobuf::bytecode::CatchNode* catch_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (catch_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(catch_);
    if (message_arena != submessage_arena) {
      catch_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, catch_, submessage_arena);
    }
    set_has_catch_();
    _impl_.types_.catch__ = catch_;
  }
  // @@protoc_insertion_point(field_set_allocated:clojure.rt.protobuf.bytecode.Subnode.catch)
}
void Subnode::set_allocated_const_(::clojure::rt::protobuf::bytecode::ConstNode* const_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (const_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(const_);
    if (message_arena != submessage_arena) {
      const_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, const_, submessage_arena);
    }
    set_has_const_();
    _impl_.types_.const__ = const_;
  }
  // @@protoc_insertion_point(field_set_allocated:clojure.rt.protobuf.bytecode.Subnode.const)
}
void Subnode::set_allocated_def(::clojure::rt::protobuf::bytecode::DefNode* def) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (def) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(def);
    if (message_arena != submessage_arena) {
      def = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, def, submessage_arena);
    }
    set_has_def();
    _impl_.types_.def_ = def;
  }
  // @@protoc_insertion_point(field_set_allocated:clojure.rt.protobuf.bytecode.Subnode.def)
}
void Subnode::set_allocated_deftype(::clojure::rt::protobuf::bytecode::DeftypeNode* deftype) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (deftype) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(deftype);
    if (message_arena != submessage_arena) {
      deftype = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, deftype, submessage_arena);
    }
    set_has_deftype();
    _impl_.types_.deftype_ = deftype;
  }
  // @@protoc_insertion_point(field_set_allocated:clojure.rt.protobuf.bytecode.Subnode.deftype)
}
void Subnode::set_allocated_do_(::clojure::rt::protobuf::bytecode::DoNode* do_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (do_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(do_);
    if (message_arena != submessage_arena) {
      do_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, do_, submessage_arena);
    }
    set_has_do_();
    _impl_.types_.do__ = do_;
  }
  // @@protoc_insertion_point(field_set_allocated:clojure.rt.protobuf.bytecode.Subnode.do)
}
void Subnode::set_allocated_fn(::clojure::rt::protobuf::bytecode::FnNode* fn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (fn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fn);
    if (message_arena != submessage_arena) {
      fn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fn, submessage_arena);
    }
    set_has_fn();
    _impl_.types_.fn_ = fn;
  }
  // @@protoc_insertion_point(field_set_allocated:clojure.rt.protobuf.bytecode.Subnode.fn)
}
void Subnode::set_allocated_fnmethod(::clojure::rt::protobuf::bytecode::FnMethodNode* fnmethod) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (fnmethod) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fnmethod);
    if (message_arena != submessage_arena) {
      fnmethod = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fnmethod, submessage_arena);
    }
    set_has_fnmethod();
    _impl_.types_.fnmethod_ = fnmethod;
  }
  // @@protoc_insertion_point(field_set_allocated:clojure.rt.protobuf.bytecode.Subnode.fnMethod)
}
void Subnode::set_allocated_hostinterop(::clojure::rt::protobuf::bytecode::HostInteropNode* hostinterop) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (hostinterop) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(hostinterop);
    if (message_arena != submessage_arena) {
      hostinterop = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hostinterop, submessage_arena);
    }
    set_has_hostinterop();
    _impl_.types_.hostinterop_ = hostinterop;
  }
  // @@protoc_insertion_point(field_set_allocated:clojure.rt.protobuf.bytecode.Subnode.hostInterop)
}
void Subnode::set_allocated_if_(::clojure::rt::protobuf::bytecode::IfNode* if_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (if_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(if_);
    if (message_arena != submessage_arena) {
      if_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, if_, submessage_arena);
    }
    set_has_if_();
    _impl_.types_.if__ = if_;
  }
  // @@protoc_insertion_point(field_set_allocated:clojure.rt.protobuf.bytecode.Subnode.if)
}
void Subnode::set_allocated_import(::clojure::rt::protobuf::bytecode::ImportNode* import) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (import) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(import);
    if (message_arena != submessage_arena) {
      import = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, import, submessage_arena);
    }
    set_has_import();
    _impl_.types_.import_ = import;
  }
  // @@protoc_insertion_point(field_set_allocated:clojure.rt.protobuf.bytecode.Subnode.import)
}
void Subnode::set_allocated_instancecall(::clojure::rt::protobuf::bytecode::InstanceCallNode* instancecall) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (instancecall) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(instancecall);
    if (message_arena != submessage_arena) {
      instancecall = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, instancecall, submessage_arena);
    }
    set_has_instancecall();
    _impl_.types_.instancecall_ = instancecall;
  }
  // @@protoc_insertion_point(field_set_allocated:clojure.rt.protobuf.bytecode.Subnode.instanceCall)
}
void Subnode::set_allocated_instancefield(::clojure::rt::protobuf::bytecode::InstanceFieldNode* instancefield) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (instancefield) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(instancefield);
    if (message_arena != submessage_arena) {
      instancefield = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, instancefield, submessage_arena);
    }
    set_has_instancefield();
    _impl_.types_.instancefield_ = instancefield;
  }
  // @@protoc_insertion_point(field_set_allocated:clojure.rt.protobuf.bytecode.Subnode.instanceField)
}
void Subnode::set_allocated_isinstance(::clojure::rt::protobuf::bytecode::IsInstanceNode* isinstance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (isinstance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(isinstance);
    if (message_arena != submessage_arena) {
      isinstance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, isinstance, submessage_arena);
    }
    set_has_isinstance();
    _impl_.types_.isinstance_ = isinstance;
  }
  // @@protoc_insertion_point(field_set_allocated:clojure.rt.protobuf.bytecode.Subnode.isInstance)
}
void Subnode::set_allocated_invoke(::clojure::rt::protobuf::bytecode::InvokeNode* invoke) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (invoke) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(invoke);
    if (message_arena != submessage_arena) {
      invoke = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, invoke, submessage_arena);
    }
    set_has_invoke();
    _impl_.types_.invoke_ = invoke;
  }
  // @@protoc_insertion_point(field_set_allocated:clojure.rt.protobuf.bytecode.Subnode.invoke)
}
void Subnode::set_allocated_keywordinvoke(::clojure::rt::protobuf::bytecode::KeywordInvokeNode* keywordinvoke) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (keywordinvoke) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(keywordinvoke);
    if (message_arena != submessage_arena) {
      keywordinvoke = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, keywordinvoke, submessage_arena);
    }
    set_has_keywordinvoke();
    _impl_.types_.keywordinvoke_ = keywordinvoke;
  }
  // @@protoc_insertion_point(field_set_allocated:clojure.rt.protobuf.bytecode.Subnode.keywordInvoke)
}
void Subnode::set_allocated_let(::clojure::rt::protobuf::bytecode::LetNode* let) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (let) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(let);
    if (message_arena != submessage_arena) {
      let = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, let, submessage_arena);
    }
    set_has_let();
    _impl_.types_.let_ = let;
  }
  // @@protoc_insertion_point(field_set_allocated:clojure.rt.protobuf.bytecode.Subnode.let)
}
void Subnode::set_allocated_letfn(::clojure::rt::protobuf::bytecode::LetfnNode* letfn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (letfn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(letfn);
    if (message_arena != submessage_arena) {
      letfn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, letfn, submessage_arena);
    }
    set_has_letfn();
    _impl_.types_.letfn_ = letfn;
  }
  // @@protoc_insertion_point(field_set_allocated:clojure.rt.protobuf.bytecode.Subnode.letfn)
}
void Subnode::set_allocated_local(::clojure::rt::protobuf::bytecode::LocalNode* local) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (local) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(local);
    if (message_arena != submessage_arena) {
      local = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, local, submessage_arena);
    }
    set_has_local();
    _impl_.types_.local_ = local;
  }
  // @@protoc_insertion_point(field_set_allocated:clojure.rt.protobuf.bytecode.Subnode.local)
}
void Subnode::set_allocated_loop(::clojure::rt::protobuf::bytecode::LoopNode* loop) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (loop) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(loop);
    if (message_arena != submessage_arena) {
      loop = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, loop, submessage_arena);
    }
    set_has_loop();
    _impl_.types_.loop_ = loop;
  }
  // @@protoc_insertion_point(field_set_allocated:clojure.rt.protobuf.bytecode.Subnode.loop)
}
void Subnode::set_allocated_map(::clojure::rt::protobuf::bytecode::MapNode* map) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (map) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(map);
    if (message_arena != submessage_arena) {
      map = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, map, submessage_arena);
    }
    set_has_map();
    _impl_.types_.map_ = map;
  }
  // @@protoc_insertion_point(field_set_allocated:clojure.rt.protobuf.bytecode.Subnode.map)
}
void Subnode::set_allocated_method(::clojure::rt::protobuf::bytecode::MethodNode* method) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (method) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(method);
    if (message_arena != submessage_arena) {
      method = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, method, submessage_arena);
    }
    set_has_method();
    _impl_.types_.method_ = method;
  }
  // @@protoc_insertion_point(field_set_allocated:clojure.rt.protobuf.bytecode.Subnode.method)
}
void Subnode::set_allocated_monitorenter(::clojure::rt::protobuf::bytecode::MonitorEnterNode* monitorenter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (monitorenter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(monitorenter);
    if (message_arena != submessage_arena) {
      monitorenter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, monitorenter, submessage_arena);
    }
    set_has_monitorenter();
    _impl_.types_.monitorenter_ = monitorenter;
  }
  // @@protoc_insertion_point(field_set_allocated:clojure.rt.protobuf.bytecode.Subnode.monitorEnter)
}
void Subnode::set_allocated_monitorexit(::clojure::rt::protobuf::bytecode::MonitorExitNode* monitorexit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (monitorexit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(monitorexit);
    if (message_arena != submessage_arena) {
      monitorexit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, monitorexit, submessage_arena);
    }
    set_has_monitorexit();
    _impl_.types_.monitorexit_ = monitorexit;
  }
  // @@protoc_insertion_point(field_set_allocated:clojure.rt.protobuf.bytecode.Subnode.monitorExit)
}
void Subnode::set_allocated_new_(::clojure::rt::protobuf::bytecode::NewNode* new_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (new_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(new_);
    if (message_arena != submessage_arena) {
      new_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, new_, submessage_arena);
    }
    set_has_new_();
    _impl_.types_.new__ = new_;
  }
  // @@protoc_insertion_point(field_set_allocated:clojure.rt.protobuf.bytecode.Subnode.new)
}
void Subnode::set_allocated_priminvoke(::clojure::rt::protobuf::bytecode::PrimInvokeNode* priminvoke) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (priminvoke) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(priminvoke);
    if (message_arena != submessage_arena) {
      priminvoke = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, priminvoke, submessage_arena);
    }
    set_has_priminvoke();
    _impl_.types_.priminvoke_ = priminvoke;
  }
  // @@protoc_insertion_point(field_set_allocated:clojure.rt.protobuf.bytecode.Subnode.primInvoke)
}
void Subnode::set_allocated_protocolinvoke(::clojure::rt::protobuf::bytecode::ProtocolInvokeNode* protocolinvoke) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (protocolinvoke) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(protocolinvoke);
    if (message_arena != submessage_arena) {
      protocolinvoke = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, protocolinvoke, submessage_arena);
    }
    set_has_protocolinvoke();
    _impl_.types_.protocolinvoke_ = protocolinvoke;
  }
  // @@protoc_insertion_point(field_set_allocated:clojure.rt.protobuf.bytecode.Subnode.protocolInvoke)
}
void Subnode::set_allocated_quote(::clojure::rt::protobuf::bytecode::QuoteNode* quote) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (quote) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(quote);
    if (message_arena != submessage_arena) {
      quote = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, quote, submessage_arena);
    }
    set_has_quote();
    _impl_.types_.quote_ = quote;
  }
  // @@protoc_insertion_point(field_set_allocated:clojure.rt.protobuf.bytecode.Subnode.quote)
}
void Subnode::set_allocated_recur(::clojure::rt::protobuf::bytecode::RecurNode* recur) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (recur) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(recur);
    if (message_arena != submessage_arena) {
      recur = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, recur, submessage_arena);
    }
    set_has_recur();
    _impl_.types_.recur_ = recur;
  }
  // @@protoc_insertion_point(field_set_allocated:clojure.rt.protobuf.bytecode.Subnode.recur)
}
void Subnode::set_allocated_reify(::clojure::rt::protobuf::bytecode::ReifyNode* reify) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (reify) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reify);
    if (message_arena != submessage_arena) {
      reify = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reify, submessage_arena);
    }
    set_has_reify();
    _impl_.types_.reify_ = reify;
  }
  // @@protoc_insertion_point(field_set_allocated:clojure.rt.protobuf.bytecode.Subnode.reify)
}
void Subnode::set_allocated_set(::clojure::rt::protobuf::bytecode::SetNode* set) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (set) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(set);
    if (message_arena != submessage_arena) {
      set = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, set, submessage_arena);
    }
    set_has_set();
    _impl_.types_.set_ = set;
  }
  // @@protoc_insertion_point(field_set_allocated:clojure.rt.protobuf.bytecode.Subnode.set)
}
void Subnode::set_allocated_mutateset(::clojure::rt::protobuf::bytecode::MutateSetNode* mutateset) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (mutateset) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(mutateset);
    if (message_arena != submessage_arena) {
      mutateset = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mutateset, submessage_arena);
    }
    set_has_mutateset();
    _impl_.types_.mutateset_ = mutateset;
  }
  // @@protoc_insertion_point(field_set_allocated:clojure.rt.protobuf.bytecode.Subnode.mutateSet)
}
void Subnode::set_allocated_staticcall(::clojure::rt::protobuf::bytecode::StaticCallNode* staticcall) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (staticcall) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(staticcall);
    if (message_arena != submessage_arena) {
      staticcall = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, staticcall, submessage_arena);
    }
    set_has_staticcall();
    _impl_.types_.staticcall_ = staticcall;
  }
  // @@protoc_insertion_point(field_set_allocated:clojure.rt.protobuf.bytecode.Subnode.staticCall)
}
void Subnode::set_allocated_staticfield(::clojure::rt::protobuf::bytecode::StaticFieldNode* staticfield) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (staticfield) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(staticfield);
    if (message_arena != submessage_arena) {
      staticfield = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, staticfield, submessage_arena);
    }
    set_has_staticfield();
    _impl_.types_.staticfield_ = staticfield;
  }
  // @@protoc_insertion_point(field_set_allocated:clojure.rt.protobuf.bytecode.Subnode.staticField)
}
void Subnode::set_allocated_thevar(::clojure::rt::protobuf::bytecode::TheVarNode* thevar) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (thevar) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(thevar);
    if (message_arena != submessage_arena) {
      thevar = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, thevar, submessage_arena);
    }
    set_has_thevar();
    _impl_.types_.thevar_ = thevar;
  }
  // @@protoc_insertion_point(field_set_allocated:clojure.rt.protobuf.bytecode.Subnode.theVar)
}
void Subnode::set_allocated_throw_(::clojure::rt::protobuf::bytecode::ThrowNode* throw_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (throw_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(throw_);
    if (message_arena != submessage_arena) {
      throw_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, throw_, submessage_arena);
    }
    set_has_throw_();
    _impl_.types_.throw__ = throw_;
  }
  // @@protoc_insertion_point(field_set_allocated:clojure.rt.protobuf.bytecode.Subnode.throw)
}
void Subnode::set_allocated_try_(::clojure::rt::protobuf::bytecode::TryNode* try_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (try_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(try_);
    if (message_arena != submessage_arena) {
      try_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, try_, submessage_arena);
    }
    set_has_try_();
    _impl_.types_.try__ = try_;
  }
  // @@protoc_insertion_point(field_set_allocated:clojure.rt.protobuf.bytecode.Subnode.try)
}
void Subnode::set_allocated_var(::clojure::rt::protobuf::bytecode::VarNode* var) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (var) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(var);
    if (message_arena != submessage_arena) {
      var = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, var, submessage_arena);
    }
    set_has_var();
    _impl_.types_.var_ = var;
  }
  // @@protoc_insertion_point(field_set_allocated:clojure.rt.protobuf.bytecode.Subnode.var)
}
void Subnode::set_allocated_vector(::clojure::rt::protobuf::bytecode::VectorNode* vector) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (vector) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(vector);
    if (message_arena != submessage_arena) {
      vector = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vector, submessage_arena);
    }
    set_has_vector();
    _impl_.types_.vector_ = vector;
  }
  // @@protoc_insertion_point(field_set_allocated:clojure.rt.protobuf.bytecode.Subnode.vector)
}
void Subnode::set_allocated_withmeta(::clojure::rt::protobuf::bytecode::WithMetaNode* withmeta) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_types();
  if (withmeta) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(withmeta);
    if (message_arena != submessage_arena) {
      withmeta = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, withmeta, submessage_arena);
    }
    set_has_withmeta();
    _impl_.types_.withmeta_ = withmeta;
  }
  // @@protoc_insertion_point(field_set_allocated:clojure.rt.protobuf.bytecode.Subnode.withMeta)
}
Subnode::Subnode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojure.rt.protobuf.bytecode.Subnode)
}
Subnode::Subnode(const Subnode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Subnode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.types_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_types();
  switch (from.types_case()) {
    case kBinding: {
      _this->_internal_mutable_binding()->::clojure::rt::protobuf::bytecode::BindingNode::MergeFrom(
          from._internal_binding());
      break;
    }
    case kCase: {
      _this->_internal_mutable_case_()->::clojure::rt::protobuf::bytecode::CaseNode::MergeFrom(
          from._internal_case_());
      break;
    }
    case kCaseTest: {
      _this->_internal_mutable_casetest()->::clojure::rt::protobuf::bytecode::CaseTestNode::MergeFrom(
          from._internal_casetest());
      break;
    }
    case kCaseThen: {
      _this->_internal_mutable_casethen()->::clojure::rt::protobuf::bytecode::CaseThenNode::MergeFrom(
          from._internal_casethen());
      break;
    }
    case kCatch: {
      _this->_internal_mutable_catch_()->::clojure::rt::protobuf::bytecode::CatchNode::MergeFrom(
          from._internal_catch_());
      break;
    }
    case kConst: {
      _this->_internal_mutable_const_()->::clojure::rt::protobuf::bytecode::ConstNode::MergeFrom(
          from._internal_const_());
      break;
    }
    case kDef: {
      _this->_internal_mutable_def()->::clojure::rt::protobuf::bytecode::DefNode::MergeFrom(
          from._internal_def());
      break;
    }
    case kDeftype: {
      _this->_internal_mutable_deftype()->::clojure::rt::protobuf::bytecode::DeftypeNode::MergeFrom(
          from._internal_deftype());
      break;
    }
    case kDo: {
      _this->_internal_mutable_do_()->::clojure::rt::protobuf::bytecode::DoNode::MergeFrom(
          from._internal_do_());
      break;
    }
    case kFn: {
      _this->_internal_mutable_fn()->::clojure::rt::protobuf::bytecode::FnNode::MergeFrom(
          from._internal_fn());
      break;
    }
    case kFnMethod: {
      _this->_internal_mutable_fnmethod()->::clojure::rt::protobuf::bytecode::FnMethodNode::MergeFrom(
          from._internal_fnmethod());
      break;
    }
    case kHostInterop: {
      _this->_internal_mutable_hostinterop()->::clojure::rt::protobuf::bytecode::HostInteropNode::MergeFrom(
          from._internal_hostinterop());
      break;
    }
    case kIf: {
      _this->_internal_mutable_if_()->::clojure::rt::protobuf::bytecode::IfNode::MergeFrom(
          from._internal_if_());
      break;
    }
    case kImport: {
      _this->_internal_mutable_import()->::clojure::rt::protobuf::bytecode::ImportNode::MergeFrom(
          from._internal_import());
      break;
    }
    case kInstanceCall: {
      _this->_internal_mutable_instancecall()->::clojure::rt::protobuf::bytecode::InstanceCallNode::MergeFrom(
          from._internal_instancecall());
      break;
    }
    case kInstanceField: {
      _this->_internal_mutable_instancefield()->::clojure::rt::protobuf::bytecode::InstanceFieldNode::MergeFrom(
          from._internal_instancefield());
      break;
    }
    case kIsInstance: {
      _this->_internal_mutable_isinstance()->::clojure::rt::protobuf::bytecode::IsInstanceNode::MergeFrom(
          from._internal_isinstance());
      break;
    }
    case kInvoke: {
      _this->_internal_mutable_invoke()->::clojure::rt::protobuf::bytecode::InvokeNode::MergeFrom(
          from._internal_invoke());
      break;
    }
    case kKeywordInvoke: {
      _this->_internal_mutable_keywordinvoke()->::clojure::rt::protobuf::bytecode::KeywordInvokeNode::MergeFrom(
          from._internal_keywordinvoke());
      break;
    }
    case kLet: {
      _this->_internal_mutable_let()->::clojure::rt::protobuf::bytecode::LetNode::MergeFrom(
          from._internal_let());
      break;
    }
    case kLetfn: {
      _this->_internal_mutable_letfn()->::clojure::rt::protobuf::bytecode::LetfnNode::MergeFrom(
          from._internal_letfn());
      break;
    }
    case kLocal: {
      _this->_internal_mutable_local()->::clojure::rt::protobuf::bytecode::LocalNode::MergeFrom(
          from._internal_local());
      break;
    }
    case kLoop: {
      _this->_internal_mutable_loop()->::clojure::rt::protobuf::bytecode::LoopNode::MergeFrom(
          from._internal_loop());
      break;
    }
    case kMap: {
      _this->_internal_mutable_map()->::clojure::rt::protobuf::bytecode::MapNode::MergeFrom(
          from._internal_map());
      break;
    }
    case kMethod: {
      _this->_internal_mutable_method()->::clojure::rt::protobuf::bytecode::MethodNode::MergeFrom(
          from._internal_method());
      break;
    }
    case kMonitorEnter: {
      _this->_internal_mutable_monitorenter()->::clojure::rt::protobuf::bytecode::MonitorEnterNode::MergeFrom(
          from._internal_monitorenter());
      break;
    }
    case kMonitorExit: {
      _this->_internal_mutable_monitorexit()->::clojure::rt::protobuf::bytecode::MonitorExitNode::MergeFrom(
          from._internal_monitorexit());
      break;
    }
    case kNew: {
      _this->_internal_mutable_new_()->::clojure::rt::protobuf::bytecode::NewNode::MergeFrom(
          from._internal_new_());
      break;
    }
    case kPrimInvoke: {
      _this->_internal_mutable_priminvoke()->::clojure::rt::protobuf::bytecode::PrimInvokeNode::MergeFrom(
          from._internal_priminvoke());
      break;
    }
    case kProtocolInvoke: {
      _this->_internal_mutable_protocolinvoke()->::clojure::rt::protobuf::bytecode::ProtocolInvokeNode::MergeFrom(
          from._internal_protocolinvoke());
      break;
    }
    case kQuote: {
      _this->_internal_mutable_quote()->::clojure::rt::protobuf::bytecode::QuoteNode::MergeFrom(
          from._internal_quote());
      break;
    }
    case kRecur: {
      _this->_internal_mutable_recur()->::clojure::rt::protobuf::bytecode::RecurNode::MergeFrom(
          from._internal_recur());
      break;
    }
    case kReify: {
      _this->_internal_mutable_reify()->::clojure::rt::protobuf::bytecode::ReifyNode::MergeFrom(
          from._internal_reify());
      break;
    }
    case kSet: {
      _this->_internal_mutable_set()->::clojure::rt::protobuf::bytecode::SetNode::MergeFrom(
          from._internal_set());
      break;
    }
    case kMutateSet: {
      _this->_internal_mutable_mutateset()->::clojure::rt::protobuf::bytecode::MutateSetNode::MergeFrom(
          from._internal_mutateset());
      break;
    }
    case kStaticCall: {
      _this->_internal_mutable_staticcall()->::clojure::rt::protobuf::bytecode::StaticCallNode::MergeFrom(
          from._internal_staticcall());
      break;
    }
    case kStaticField: {
      _this->_internal_mutable_staticfield()->::clojure::rt::protobuf::bytecode::StaticFieldNode::MergeFrom(
          from._internal_staticfield());
      break;
    }
    case kTheVar: {
      _this->_internal_mutable_thevar()->::clojure::rt::protobuf::bytecode::TheVarNode::MergeFrom(
          from._internal_thevar());
      break;
    }
    case kThrow: {
      _this->_internal_mutable_throw_()->::clojure::rt::protobuf::bytecode::ThrowNode::MergeFrom(
          from._internal_throw_());
      break;
    }
    case kTry: {
      _this->_internal_mutable_try_()->::clojure::rt::protobuf::bytecode::TryNode::MergeFrom(
          from._internal_try_());
      break;
    }
    case kVar: {
      _this->_internal_mutable_var()->::clojure::rt::protobuf::bytecode::VarNode::MergeFrom(
          from._internal_var());
      break;
    }
    case kVector: {
      _this->_internal_mutable_vector()->::clojure::rt::protobuf::bytecode::VectorNode::MergeFrom(
          from._internal_vector());
      break;
    }
    case kWithMeta: {
      _this->_internal_mutable_withmeta()->::clojure::rt::protobuf::bytecode::WithMetaNode::MergeFrom(
          from._internal_withmeta());
      break;
    }
    case TYPES_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:clojure.rt.protobuf.bytecode.Subnode)
}

inline void Subnode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.types_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_types();
}

Subnode::~Subnode() {
  // @@protoc_insertion_point(destructor:clojure.rt.protobuf.bytecode.Subnode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Subnode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_types()) {
    clear_types();
  }
}

void Subnode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Subnode::clear_types() {
// @@protoc_insertion_point(one_of_clear_start:clojure.rt.protobuf.bytecode.Subnode)
  switch (types_case()) {
    case kBinding: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.binding_;
      }
      break;
    }
    case kCase: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.case__;
      }
      break;
    }
    case kCaseTest: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.casetest_;
      }
      break;
    }
    case kCaseThen: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.casethen_;
      }
      break;
    }
    case kCatch: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.catch__;
      }
      break;
    }
    case kConst: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.const__;
      }
      break;
    }
    case kDef: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.def_;
      }
      break;
    }
    case kDeftype: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.deftype_;
      }
      break;
    }
    case kDo: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.do__;
      }
      break;
    }
    case kFn: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.fn_;
      }
      break;
    }
    case kFnMethod: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.fnmethod_;
      }
      break;
    }
    case kHostInterop: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.hostinterop_;
      }
      break;
    }
    case kIf: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.if__;
      }
      break;
    }
    case kImport: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.import_;
      }
      break;
    }
    case kInstanceCall: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.instancecall_;
      }
      break;
    }
    case kInstanceField: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.instancefield_;
      }
      break;
    }
    case kIsInstance: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.isinstance_;
      }
      break;
    }
    case kInvoke: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.invoke_;
      }
      break;
    }
    case kKeywordInvoke: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.keywordinvoke_;
      }
      break;
    }
    case kLet: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.let_;
      }
      break;
    }
    case kLetfn: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.letfn_;
      }
      break;
    }
    case kLocal: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.local_;
      }
      break;
    }
    case kLoop: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.loop_;
      }
      break;
    }
    case kMap: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.map_;
      }
      break;
    }
    case kMethod: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.method_;
      }
      break;
    }
    case kMonitorEnter: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.monitorenter_;
      }
      break;
    }
    case kMonitorExit: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.monitorexit_;
      }
      break;
    }
    case kNew: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.new__;
      }
      break;
    }
    case kPrimInvoke: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.priminvoke_;
      }
      break;
    }
    case kProtocolInvoke: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.protocolinvoke_;
      }
      break;
    }
    case kQuote: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.quote_;
      }
      break;
    }
    case kRecur: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.recur_;
      }
      break;
    }
    case kReify: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.reify_;
      }
      break;
    }
    case kSet: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.set_;
      }
      break;
    }
    case kMutateSet: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.mutateset_;
      }
      break;
    }
    case kStaticCall: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.staticcall_;
      }
      break;
    }
    case kStaticField: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.staticfield_;
      }
      break;
    }
    case kTheVar: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.thevar_;
      }
      break;
    }
    case kThrow: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.throw__;
      }
      break;
    }
    case kTry: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.try__;
      }
      break;
    }
    case kVar: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.var_;
      }
      break;
    }
    case kVector: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.vector_;
      }
      break;
    }
    case kWithMeta: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.types_.withmeta_;
      }
      break;
    }
    case TYPES_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = TYPES_NOT_SET;
}


void Subnode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojure.rt.protobuf.bytecode.Subnode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_types();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Subnode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .clojure.rt.protobuf.bytecode.BindingNode binding = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_binding(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.CaseNode case = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_case_(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.CaseTestNode caseTest = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_casetest(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.CaseThenNode caseThen = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_casethen(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.CatchNode catch = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_catch_(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.ConstNode const = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_const_(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.DefNode def = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_def(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.DeftypeNode deftype = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_deftype(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.DoNode do = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_do_(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.FnNode fn = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_fn(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.FnMethodNode fnMethod = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_fnmethod(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.HostInteropNode hostInterop = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_hostinterop(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.IfNode if = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_if_(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.ImportNode import = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_import(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.InstanceCallNode instanceCall = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_instancecall(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.InstanceFieldNode instanceField = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_instancefield(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.IsInstanceNode isInstance = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_isinstance(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.InvokeNode invoke = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_invoke(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.KeywordInvokeNode keywordInvoke = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_keywordinvoke(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.LetNode let = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_let(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.LetfnNode letfn = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          ptr = ctx->ParseMessage(_internal_mutable_letfn(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.LocalNode local = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          ptr = ctx->ParseMessage(_internal_mutable_local(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.LoopNode loop = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 186)) {
          ptr = ctx->ParseMessage(_internal_mutable_loop(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.MapNode map = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 194)) {
          ptr = ctx->ParseMessage(_internal_mutable_map(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.MethodNode method = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 202)) {
          ptr = ctx->ParseMessage(_internal_mutable_method(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.MonitorEnterNode monitorEnter = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 210)) {
          ptr = ctx->ParseMessage(_internal_mutable_monitorenter(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.MonitorExitNode monitorExit = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 218)) {
          ptr = ctx->ParseMessage(_internal_mutable_monitorexit(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.NewNode new = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 226)) {
          ptr = ctx->ParseMessage(_internal_mutable_new_(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.PrimInvokeNode primInvoke = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 234)) {
          ptr = ctx->ParseMessage(_internal_mutable_priminvoke(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.ProtocolInvokeNode protocolInvoke = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 242)) {
          ptr = ctx->ParseMessage(_internal_mutable_protocolinvoke(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.QuoteNode quote = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 250)) {
          ptr = ctx->ParseMessage(_internal_mutable_quote(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.RecurNode recur = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 2)) {
          ptr = ctx->ParseMessage(_internal_mutable_recur(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.ReifyNode reify = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_reify(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.SetNode set = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_set(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.MutateSetNode mutateSet = 35;
      case 35:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_mutateset(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.StaticCallNode staticCall = 36;
      case 36:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_staticcall(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.StaticFieldNode staticField = 37;
      case 37:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_staticfield(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.TheVarNode theVar = 38;
      case 38:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_thevar(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.ThrowNode throw = 39;
      case 39:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_throw_(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.TryNode try = 40;
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_try_(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.VarNode var = 41;
      case 41:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_var(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.VectorNode vector = 42;
      case 42:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_vector(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.WithMetaNode withMeta = 43;
      case 43:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_withmeta(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Subnode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojure.rt.protobuf.bytecode.Subnode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .clojure.rt.protobuf.bytecode.BindingNode binding = 1;
  if (_internal_has_binding()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::binding(this),
        _Internal::binding(this).GetCachedSize(), target, stream);
  }

  // .clojure.rt.protobuf.bytecode.CaseNode case = 2;
  if (_internal_has_case_()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::case_(this),
        _Internal::case_(this).GetCachedSize(), target, stream);
  }

  // .clojure.rt.protobuf.bytecode.CaseTestNode caseTest = 3;
  if (_internal_has_casetest()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::casetest(this),
        _Internal::casetest(this).GetCachedSize(), target, stream);
  }

  // .clojure.rt.protobuf.bytecode.CaseThenNode caseThen = 4;
  if (_internal_has_casethen()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::casethen(this),
        _Internal::casethen(this).GetCachedSize(), target, stream);
  }

  // .clojure.rt.protobuf.bytecode.CatchNode catch = 5;
  if (_internal_has_catch_()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::catch_(this),
        _Internal::catch_(this).GetCachedSize(), target, stream);
  }

  // .clojure.rt.protobuf.bytecode.ConstNode const = 6;
  if (_internal_has_const_()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::const_(this),
        _Internal::const_(this).GetCachedSize(), target, stream);
  }

  // .clojure.rt.protobuf.bytecode.DefNode def = 7;
  if (_internal_has_def()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::def(this),
        _Internal::def(this).GetCachedSize(), target, stream);
  }

  // .clojure.rt.protobuf.bytecode.DeftypeNode deftype = 8;
  if (_internal_has_deftype()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::deftype(this),
        _Internal::deftype(this).GetCachedSize(), target, stream);
  }

  // .clojure.rt.protobuf.bytecode.DoNode do = 9;
  if (_internal_has_do_()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::do_(this),
        _Internal::do_(this).GetCachedSize(), target, stream);
  }

  // .clojure.rt.protobuf.bytecode.FnNode fn = 10;
  if (_internal_has_fn()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::fn(this),
        _Internal::fn(this).GetCachedSize(), target, stream);
  }

  // .clojure.rt.protobuf.bytecode.FnMethodNode fnMethod = 11;
  if (_internal_has_fnmethod()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::fnmethod(this),
        _Internal::fnmethod(this).GetCachedSize(), target, stream);
  }

  // .clojure.rt.protobuf.bytecode.HostInteropNode hostInterop = 12;
  if (_internal_has_hostinterop()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::hostinterop(this),
        _Internal::hostinterop(this).GetCachedSize(), target, stream);
  }

  // .clojure.rt.protobuf.bytecode.IfNode if = 13;
  if (_internal_has_if_()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, _Internal::if_(this),
        _Internal::if_(this).GetCachedSize(), target, stream);
  }

  // .clojure.rt.protobuf.bytecode.ImportNode import = 14;
  if (_internal_has_import()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(14, _Internal::import(this),
        _Internal::import(this).GetCachedSize(), target, stream);
  }

  // .clojure.rt.protobuf.bytecode.InstanceCallNode instanceCall = 15;
  if (_internal_has_instancecall()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(15, _Internal::instancecall(this),
        _Internal::instancecall(this).GetCachedSize(), target, stream);
  }

  // .clojure.rt.protobuf.bytecode.InstanceFieldNode instanceField = 16;
  if (_internal_has_instancefield()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(16, _Internal::instancefield(this),
        _Internal::instancefield(this).GetCachedSize(), target, stream);
  }

  // .clojure.rt.protobuf.bytecode.IsInstanceNode isInstance = 17;
  if (_internal_has_isinstance()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(17, _Internal::isinstance(this),
        _Internal::isinstance(this).GetCachedSize(), target, stream);
  }

  // .clojure.rt.protobuf.bytecode.InvokeNode invoke = 18;
  if (_internal_has_invoke()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(18, _Internal::invoke(this),
        _Internal::invoke(this).GetCachedSize(), target, stream);
  }

  // .clojure.rt.protobuf.bytecode.KeywordInvokeNode keywordInvoke = 19;
  if (_internal_has_keywordinvoke()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(19, _Internal::keywordinvoke(this),
        _Internal::keywordinvoke(this).GetCachedSize(), target, stream);
  }

  // .clojure.rt.protobuf.bytecode.LetNode let = 20;
  if (_internal_has_let()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(20, _Internal::let(this),
        _Internal::let(this).GetCachedSize(), target, stream);
  }

  // .clojure.rt.protobuf.bytecode.LetfnNode letfn = 21;
  if (_internal_has_letfn()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(21, _Internal::letfn(this),
        _Internal::letfn(this).GetCachedSize(), target, stream);
  }

  // .clojure.rt.protobuf.bytecode.LocalNode local = 22;
  if (_internal_has_local()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(22, _Internal::local(this),
        _Internal::local(this).GetCachedSize(), target, stream);
  }

  // .clojure.rt.protobuf.bytecode.LoopNode loop = 23;
  if (_internal_has_loop()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(23, _Internal::loop(this),
        _Internal::loop(this).GetCachedSize(), target, stream);
  }

  // .clojure.rt.protobuf.bytecode.MapNode map = 24;
  if (_internal_has_map()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(24, _Internal::map(this),
        _Internal::map(this).GetCachedSize(), target, stream);
  }

  // .clojure.rt.protobuf.bytecode.MethodNode method = 25;
  if (_internal_has_method()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(25, _Internal::method(this),
        _Internal::method(this).GetCachedSize(), target, stream);
  }

  // .clojure.rt.protobuf.bytecode.MonitorEnterNode monitorEnter = 26;
  if (_internal_has_monitorenter()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(26, _Internal::monitorenter(this),
        _Internal::monitorenter(this).GetCachedSize(), target, stream);
  }

  // .clojure.rt.protobuf.bytecode.MonitorExitNode monitorExit = 27;
  if (_internal_has_monitorexit()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(27, _Internal::monitorexit(this),
        _Internal::monitorexit(this).GetCachedSize(), target, stream);
  }

  // .clojure.rt.protobuf.bytecode.NewNode new = 28;
  if (_internal_has_new_()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(28, _Internal::new_(this),
        _Internal::new_(this).GetCachedSize(), target, stream);
  }

  // .clojure.rt.protobuf.bytecode.PrimInvokeNode primInvoke = 29;
  if (_internal_has_priminvoke()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(29, _Internal::priminvoke(this),
        _Internal::priminvoke(this).GetCachedSize(), target, stream);
  }

  // .clojure.rt.protobuf.bytecode.ProtocolInvokeNode protocolInvoke = 30;
  if (_internal_has_protocolinvoke()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(30, _Internal::protocolinvoke(this),
        _Internal::protocolinvoke(this).GetCachedSize(), target, stream);
  }

  // .clojure.rt.protobuf.bytecode.QuoteNode quote = 31;
  if (_internal_has_quote()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(31, _Internal::quote(this),
        _Internal::quote(this).GetCachedSize(), target, stream);
  }

  // .clojure.rt.protobuf.bytecode.RecurNode recur = 32;
  if (_internal_has_recur()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(32, _Internal::recur(this),
        _Internal::recur(this).GetCachedSize(), target, stream);
  }

  // .clojure.rt.protobuf.bytecode.ReifyNode reify = 33;
  if (_internal_has_reify()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(33, _Internal::reify(this),
        _Internal::reify(this).GetCachedSize(), target, stream);
  }

  // .clojure.rt.protobuf.bytecode.SetNode set = 34;
  if (_internal_has_set()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(34, _Internal::set(this),
        _Internal::set(this).GetCachedSize(), target, stream);
  }

  // .clojure.rt.protobuf.bytecode.MutateSetNode mutateSet = 35;
  if (_internal_has_mutateset()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(35, _Internal::mutateset(this),
        _Internal::mutateset(this).GetCachedSize(), target, stream);
  }

  // .clojure.rt.protobuf.bytecode.StaticCallNode staticCall = 36;
  if (_internal_has_staticcall()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(36, _Internal::staticcall(this),
        _Internal::staticcall(this).GetCachedSize(), target, stream);
  }

  // .clojure.rt.protobuf.bytecode.StaticFieldNode staticField = 37;
  if (_internal_has_staticfield()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(37, _Internal::staticfield(this),
        _Internal::staticfield(this).GetCachedSize(), target, stream);
  }

  // .clojure.rt.protobuf.bytecode.TheVarNode theVar = 38;
  if (_internal_has_thevar()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(38, _Internal::thevar(this),
        _Internal::thevar(this).GetCachedSize(), target, stream);
  }

  // .clojure.rt.protobuf.bytecode.ThrowNode throw = 39;
  if (_internal_has_throw_()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(39, _Internal::throw_(this),
        _Internal::throw_(this).GetCachedSize(), target, stream);
  }

  // .clojure.rt.protobuf.bytecode.TryNode try = 40;
  if (_internal_has_try_()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(40, _Internal::try_(this),
        _Internal::try_(this).GetCachedSize(), target, stream);
  }

  // .clojure.rt.protobuf.bytecode.VarNode var = 41;
  if (_internal_has_var()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(41, _Internal::var(this),
        _Internal::var(this).GetCachedSize(), target, stream);
  }

  // .clojure.rt.protobuf.bytecode.VectorNode vector = 42;
  if (_internal_has_vector()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(42, _Internal::vector(this),
        _Internal::vector(this).GetCachedSize(), target, stream);
  }

  // .clojure.rt.protobuf.bytecode.WithMetaNode withMeta = 43;
  if (_internal_has_withmeta()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(43, _Internal::withmeta(this),
        _Internal::withmeta(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojure.rt.protobuf.bytecode.Subnode)
  return target;
}

size_t Subnode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojure.rt.protobuf.bytecode.Subnode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (types_case()) {
    // .clojure.rt.protobuf.bytecode.BindingNode binding = 1;
    case kBinding: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.binding_);
      break;
    }
    // .clojure.rt.protobuf.bytecode.CaseNode case = 2;
    case kCase: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.case__);
      break;
    }
    // .clojure.rt.protobuf.bytecode.CaseTestNode caseTest = 3;
    case kCaseTest: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.casetest_);
      break;
    }
    // .clojure.rt.protobuf.bytecode.CaseThenNode caseThen = 4;
    case kCaseThen: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.casethen_);
      break;
    }
    // .clojure.rt.protobuf.bytecode.CatchNode catch = 5;
    case kCatch: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.catch__);
      break;
    }
    // .clojure.rt.protobuf.bytecode.ConstNode const = 6;
    case kConst: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.const__);
      break;
    }
    // .clojure.rt.protobuf.bytecode.DefNode def = 7;
    case kDef: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.def_);
      break;
    }
    // .clojure.rt.protobuf.bytecode.DeftypeNode deftype = 8;
    case kDeftype: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.deftype_);
      break;
    }
    // .clojure.rt.protobuf.bytecode.DoNode do = 9;
    case kDo: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.do__);
      break;
    }
    // .clojure.rt.protobuf.bytecode.FnNode fn = 10;
    case kFn: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.fn_);
      break;
    }
    // .clojure.rt.protobuf.bytecode.FnMethodNode fnMethod = 11;
    case kFnMethod: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.fnmethod_);
      break;
    }
    // .clojure.rt.protobuf.bytecode.HostInteropNode hostInterop = 12;
    case kHostInterop: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.hostinterop_);
      break;
    }
    // .clojure.rt.protobuf.bytecode.IfNode if = 13;
    case kIf: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.if__);
      break;
    }
    // .clojure.rt.protobuf.bytecode.ImportNode import = 14;
    case kImport: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.import_);
      break;
    }
    // .clojure.rt.protobuf.bytecode.InstanceCallNode instanceCall = 15;
    case kInstanceCall: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.instancecall_);
      break;
    }
    // .clojure.rt.protobuf.bytecode.InstanceFieldNode instanceField = 16;
    case kInstanceField: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.instancefield_);
      break;
    }
    // .clojure.rt.protobuf.bytecode.IsInstanceNode isInstance = 17;
    case kIsInstance: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.isinstance_);
      break;
    }
    // .clojure.rt.protobuf.bytecode.InvokeNode invoke = 18;
    case kInvoke: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.invoke_);
      break;
    }
    // .clojure.rt.protobuf.bytecode.KeywordInvokeNode keywordInvoke = 19;
    case kKeywordInvoke: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.keywordinvoke_);
      break;
    }
    // .clojure.rt.protobuf.bytecode.LetNode let = 20;
    case kLet: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.let_);
      break;
    }
    // .clojure.rt.protobuf.bytecode.LetfnNode letfn = 21;
    case kLetfn: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.letfn_);
      break;
    }
    // .clojure.rt.protobuf.bytecode.LocalNode local = 22;
    case kLocal: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.local_);
      break;
    }
    // .clojure.rt.protobuf.bytecode.LoopNode loop = 23;
    case kLoop: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.loop_);
      break;
    }
    // .clojure.rt.protobuf.bytecode.MapNode map = 24;
    case kMap: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.map_);
      break;
    }
    // .clojure.rt.protobuf.bytecode.MethodNode method = 25;
    case kMethod: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.method_);
      break;
    }
    // .clojure.rt.protobuf.bytecode.MonitorEnterNode monitorEnter = 26;
    case kMonitorEnter: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.monitorenter_);
      break;
    }
    // .clojure.rt.protobuf.bytecode.MonitorExitNode monitorExit = 27;
    case kMonitorExit: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.monitorexit_);
      break;
    }
    // .clojure.rt.protobuf.bytecode.NewNode new = 28;
    case kNew: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.new__);
      break;
    }
    // .clojure.rt.protobuf.bytecode.PrimInvokeNode primInvoke = 29;
    case kPrimInvoke: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.priminvoke_);
      break;
    }
    // .clojure.rt.protobuf.bytecode.ProtocolInvokeNode protocolInvoke = 30;
    case kProtocolInvoke: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.protocolinvoke_);
      break;
    }
    // .clojure.rt.protobuf.bytecode.QuoteNode quote = 31;
    case kQuote: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.quote_);
      break;
    }
    // .clojure.rt.protobuf.bytecode.RecurNode recur = 32;
    case kRecur: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.recur_);
      break;
    }
    // .clojure.rt.protobuf.bytecode.ReifyNode reify = 33;
    case kReify: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.reify_);
      break;
    }
    // .clojure.rt.protobuf.bytecode.SetNode set = 34;
    case kSet: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.set_);
      break;
    }
    // .clojure.rt.protobuf.bytecode.MutateSetNode mutateSet = 35;
    case kMutateSet: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.mutateset_);
      break;
    }
    // .clojure.rt.protobuf.bytecode.StaticCallNode staticCall = 36;
    case kStaticCall: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.staticcall_);
      break;
    }
    // .clojure.rt.protobuf.bytecode.StaticFieldNode staticField = 37;
    case kStaticField: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.staticfield_);
      break;
    }
    // .clojure.rt.protobuf.bytecode.TheVarNode theVar = 38;
    case kTheVar: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.thevar_);
      break;
    }
    // .clojure.rt.protobuf.bytecode.ThrowNode throw = 39;
    case kThrow: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.throw__);
      break;
    }
    // .clojure.rt.protobuf.bytecode.TryNode try = 40;
    case kTry: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.try__);
      break;
    }
    // .clojure.rt.protobuf.bytecode.VarNode var = 41;
    case kVar: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.var_);
      break;
    }
    // .clojure.rt.protobuf.bytecode.VectorNode vector = 42;
    case kVector: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.vector_);
      break;
    }
    // .clojure.rt.protobuf.bytecode.WithMetaNode withMeta = 43;
    case kWithMeta: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.types_.withmeta_);
      break;
    }
    case TYPES_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Subnode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Subnode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Subnode::GetClassData() const { return &_class_data_; }


void Subnode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Subnode*>(&to_msg);
  auto& from = static_cast<const Subnode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojure.rt.protobuf.bytecode.Subnode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.types_case()) {
    case kBinding: {
      _this->_internal_mutable_binding()->::clojure::rt::protobuf::bytecode::BindingNode::MergeFrom(
          from._internal_binding());
      break;
    }
    case kCase: {
      _this->_internal_mutable_case_()->::clojure::rt::protobuf::bytecode::CaseNode::MergeFrom(
          from._internal_case_());
      break;
    }
    case kCaseTest: {
      _this->_internal_mutable_casetest()->::clojure::rt::protobuf::bytecode::CaseTestNode::MergeFrom(
          from._internal_casetest());
      break;
    }
    case kCaseThen: {
      _this->_internal_mutable_casethen()->::clojure::rt::protobuf::bytecode::CaseThenNode::MergeFrom(
          from._internal_casethen());
      break;
    }
    case kCatch: {
      _this->_internal_mutable_catch_()->::clojure::rt::protobuf::bytecode::CatchNode::MergeFrom(
          from._internal_catch_());
      break;
    }
    case kConst: {
      _this->_internal_mutable_const_()->::clojure::rt::protobuf::bytecode::ConstNode::MergeFrom(
          from._internal_const_());
      break;
    }
    case kDef: {
      _this->_internal_mutable_def()->::clojure::rt::protobuf::bytecode::DefNode::MergeFrom(
          from._internal_def());
      break;
    }
    case kDeftype: {
      _this->_internal_mutable_deftype()->::clojure::rt::protobuf::bytecode::DeftypeNode::MergeFrom(
          from._internal_deftype());
      break;
    }
    case kDo: {
      _this->_internal_mutable_do_()->::clojure::rt::protobuf::bytecode::DoNode::MergeFrom(
          from._internal_do_());
      break;
    }
    case kFn: {
      _this->_internal_mutable_fn()->::clojure::rt::protobuf::bytecode::FnNode::MergeFrom(
          from._internal_fn());
      break;
    }
    case kFnMethod: {
      _this->_internal_mutable_fnmethod()->::clojure::rt::protobuf::bytecode::FnMethodNode::MergeFrom(
          from._internal_fnmethod());
      break;
    }
    case kHostInterop: {
      _this->_internal_mutable_hostinterop()->::clojure::rt::protobuf::bytecode::HostInteropNode::MergeFrom(
          from._internal_hostinterop());
      break;
    }
    case kIf: {
      _this->_internal_mutable_if_()->::clojure::rt::protobuf::bytecode::IfNode::MergeFrom(
          from._internal_if_());
      break;
    }
    case kImport: {
      _this->_internal_mutable_import()->::clojure::rt::protobuf::bytecode::ImportNode::MergeFrom(
          from._internal_import());
      break;
    }
    case kInstanceCall: {
      _this->_internal_mutable_instancecall()->::clojure::rt::protobuf::bytecode::InstanceCallNode::MergeFrom(
          from._internal_instancecall());
      break;
    }
    case kInstanceField: {
      _this->_internal_mutable_instancefield()->::clojure::rt::protobuf::bytecode::InstanceFieldNode::MergeFrom(
          from._internal_instancefield());
      break;
    }
    case kIsInstance: {
      _this->_internal_mutable_isinstance()->::clojure::rt::protobuf::bytecode::IsInstanceNode::MergeFrom(
          from._internal_isinstance());
      break;
    }
    case kInvoke: {
      _this->_internal_mutable_invoke()->::clojure::rt::protobuf::bytecode::InvokeNode::MergeFrom(
          from._internal_invoke());
      break;
    }
    case kKeywordInvoke: {
      _this->_internal_mutable_keywordinvoke()->::clojure::rt::protobuf::bytecode::KeywordInvokeNode::MergeFrom(
          from._internal_keywordinvoke());
      break;
    }
    case kLet: {
      _this->_internal_mutable_let()->::clojure::rt::protobuf::bytecode::LetNode::MergeFrom(
          from._internal_let());
      break;
    }
    case kLetfn: {
      _this->_internal_mutable_letfn()->::clojure::rt::protobuf::bytecode::LetfnNode::MergeFrom(
          from._internal_letfn());
      break;
    }
    case kLocal: {
      _this->_internal_mutable_local()->::clojure::rt::protobuf::bytecode::LocalNode::MergeFrom(
          from._internal_local());
      break;
    }
    case kLoop: {
      _this->_internal_mutable_loop()->::clojure::rt::protobuf::bytecode::LoopNode::MergeFrom(
          from._internal_loop());
      break;
    }
    case kMap: {
      _this->_internal_mutable_map()->::clojure::rt::protobuf::bytecode::MapNode::MergeFrom(
          from._internal_map());
      break;
    }
    case kMethod: {
      _this->_internal_mutable_method()->::clojure::rt::protobuf::bytecode::MethodNode::MergeFrom(
          from._internal_method());
      break;
    }
    case kMonitorEnter: {
      _this->_internal_mutable_monitorenter()->::clojure::rt::protobuf::bytecode::MonitorEnterNode::MergeFrom(
          from._internal_monitorenter());
      break;
    }
    case kMonitorExit: {
      _this->_internal_mutable_monitorexit()->::clojure::rt::protobuf::bytecode::MonitorExitNode::MergeFrom(
          from._internal_monitorexit());
      break;
    }
    case kNew: {
      _this->_internal_mutable_new_()->::clojure::rt::protobuf::bytecode::NewNode::MergeFrom(
          from._internal_new_());
      break;
    }
    case kPrimInvoke: {
      _this->_internal_mutable_priminvoke()->::clojure::rt::protobuf::bytecode::PrimInvokeNode::MergeFrom(
          from._internal_priminvoke());
      break;
    }
    case kProtocolInvoke: {
      _this->_internal_mutable_protocolinvoke()->::clojure::rt::protobuf::bytecode::ProtocolInvokeNode::MergeFrom(
          from._internal_protocolinvoke());
      break;
    }
    case kQuote: {
      _this->_internal_mutable_quote()->::clojure::rt::protobuf::bytecode::QuoteNode::MergeFrom(
          from._internal_quote());
      break;
    }
    case kRecur: {
      _this->_internal_mutable_recur()->::clojure::rt::protobuf::bytecode::RecurNode::MergeFrom(
          from._internal_recur());
      break;
    }
    case kReify: {
      _this->_internal_mutable_reify()->::clojure::rt::protobuf::bytecode::ReifyNode::MergeFrom(
          from._internal_reify());
      break;
    }
    case kSet: {
      _this->_internal_mutable_set()->::clojure::rt::protobuf::bytecode::SetNode::MergeFrom(
          from._internal_set());
      break;
    }
    case kMutateSet: {
      _this->_internal_mutable_mutateset()->::clojure::rt::protobuf::bytecode::MutateSetNode::MergeFrom(
          from._internal_mutateset());
      break;
    }
    case kStaticCall: {
      _this->_internal_mutable_staticcall()->::clojure::rt::protobuf::bytecode::StaticCallNode::MergeFrom(
          from._internal_staticcall());
      break;
    }
    case kStaticField: {
      _this->_internal_mutable_staticfield()->::clojure::rt::protobuf::bytecode::StaticFieldNode::MergeFrom(
          from._internal_staticfield());
      break;
    }
    case kTheVar: {
      _this->_internal_mutable_thevar()->::clojure::rt::protobuf::bytecode::TheVarNode::MergeFrom(
          from._internal_thevar());
      break;
    }
    case kThrow: {
      _this->_internal_mutable_throw_()->::clojure::rt::protobuf::bytecode::ThrowNode::MergeFrom(
          from._internal_throw_());
      break;
    }
    case kTry: {
      _this->_internal_mutable_try_()->::clojure::rt::protobuf::bytecode::TryNode::MergeFrom(
          from._internal_try_());
      break;
    }
    case kVar: {
      _this->_internal_mutable_var()->::clojure::rt::protobuf::bytecode::VarNode::MergeFrom(
          from._internal_var());
      break;
    }
    case kVector: {
      _this->_internal_mutable_vector()->::clojure::rt::protobuf::bytecode::VectorNode::MergeFrom(
          from._internal_vector());
      break;
    }
    case kWithMeta: {
      _this->_internal_mutable_withmeta()->::clojure::rt::protobuf::bytecode::WithMetaNode::MergeFrom(
          from._internal_withmeta());
      break;
    }
    case TYPES_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Subnode::CopyFrom(const Subnode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojure.rt.protobuf.bytecode.Subnode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Subnode::IsInitialized() const {
  return true;
}

void Subnode::InternalSwap(Subnode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.types_, other->_impl_.types_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Subnode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[1]);
}

// ===================================================================

class BindingNode::_Internal {
 public:
  static const ::clojure::rt::protobuf::bytecode::Node& init(const BindingNode* msg);
};

const ::clojure::rt::protobuf::bytecode::Node&
BindingNode::_Internal::init(const BindingNode* msg) {
  return *msg->_impl_.init_;
}
BindingNode::BindingNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojure.rt.protobuf.bytecode.BindingNode)
}
BindingNode::BindingNode(const BindingNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BindingNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.init_){nullptr}
    , decltype(_impl_.argid_){}
    , decltype(_impl_.local_){}
    , decltype(_impl_.isvariadic_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_init()) {
    _this->_impl_.init_ = new ::clojure::rt::protobuf::bytecode::Node(*from._impl_.init_);
  }
  ::memcpy(&_impl_.argid_, &from._impl_.argid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.isvariadic_) -
    reinterpret_cast<char*>(&_impl_.argid_)) + sizeof(_impl_.isvariadic_));
  // @@protoc_insertion_point(copy_constructor:clojure.rt.protobuf.bytecode.BindingNode)
}

inline void BindingNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.init_){nullptr}
    , decltype(_impl_.argid_){0u}
    , decltype(_impl_.local_){0}
    , decltype(_impl_.isvariadic_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

BindingNode::~BindingNode() {
  // @@protoc_insertion_point(destructor:clojure.rt.protobuf.bytecode.BindingNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BindingNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.init_;
}

void BindingNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BindingNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojure.rt.protobuf.bytecode.BindingNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.init_ != nullptr) {
    delete _impl_.init_;
  }
  _impl_.init_ = nullptr;
  ::memset(&_impl_.argid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.isvariadic_) -
      reinterpret_cast<char*>(&_impl_.argid_)) + sizeof(_impl_.isvariadic_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BindingNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 argId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.argid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.Node init = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_init(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.LocalType local = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_local(static_cast<::clojure::rt::protobuf::bytecode::LocalType>(val));
        } else
          goto handle_unusual;
        continue;
      // string name = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojure.rt.protobuf.bytecode.BindingNode.name"));
        } else
          goto handle_unusual;
        continue;
      // bool isVariadic = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.isvariadic_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BindingNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojure.rt.protobuf.bytecode.BindingNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 argId = 1;
  if (this->_internal_argid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_argid(), target);
  }

  // .clojure.rt.protobuf.bytecode.Node init = 2;
  if (this->_internal_has_init()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::init(this),
        _Internal::init(this).GetCachedSize(), target, stream);
  }

  // .clojure.rt.protobuf.bytecode.LocalType local = 3;
  if (this->_internal_local() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_local(), target);
  }

  // string name = 4;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojure.rt.protobuf.bytecode.BindingNode.name");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_name(), target);
  }

  // bool isVariadic = 5;
  if (this->_internal_isvariadic() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_isvariadic(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojure.rt.protobuf.bytecode.BindingNode)
  return target;
}

size_t BindingNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojure.rt.protobuf.bytecode.BindingNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 4;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .clojure.rt.protobuf.bytecode.Node init = 2;
  if (this->_internal_has_init()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.init_);
  }

  // uint32 argId = 1;
  if (this->_internal_argid() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_argid());
  }

  // .clojure.rt.protobuf.bytecode.LocalType local = 3;
  if (this->_internal_local() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_local());
  }

  // bool isVariadic = 5;
  if (this->_internal_isvariadic() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BindingNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BindingNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BindingNode::GetClassData() const { return &_class_data_; }


void BindingNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BindingNode*>(&to_msg);
  auto& from = static_cast<const BindingNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojure.rt.protobuf.bytecode.BindingNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_has_init()) {
    _this->_internal_mutable_init()->::clojure::rt::protobuf::bytecode::Node::MergeFrom(
        from._internal_init());
  }
  if (from._internal_argid() != 0) {
    _this->_internal_set_argid(from._internal_argid());
  }
  if (from._internal_local() != 0) {
    _this->_internal_set_local(from._internal_local());
  }
  if (from._internal_isvariadic() != 0) {
    _this->_internal_set_isvariadic(from._internal_isvariadic());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BindingNode::CopyFrom(const BindingNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojure.rt.protobuf.bytecode.BindingNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BindingNode::IsInitialized() const {
  return true;
}

void BindingNode::InternalSwap(BindingNode* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BindingNode, _impl_.isvariadic_)
      + sizeof(BindingNode::_impl_.isvariadic_)
      - PROTOBUF_FIELD_OFFSET(BindingNode, _impl_.init_)>(
          reinterpret_cast<char*>(&_impl_.init_),
          reinterpret_cast<char*>(&other->_impl_.init_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BindingNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[2]);
}

// ===================================================================

class CaseNode::_Internal {
 public:
  static const ::clojure::rt::protobuf::bytecode::Node& default_(const CaseNode* msg);
  static const ::clojure::rt::protobuf::bytecode::Node& test(const CaseNode* msg);
};

const ::clojure::rt::protobuf::bytecode::Node&
CaseNode::_Internal::default_(const CaseNode* msg) {
  return *msg->_impl_.default__;
}
const ::clojure::rt::protobuf::bytecode::Node&
CaseNode::_Internal::test(const CaseNode* msg) {
  return *msg->_impl_.test_;
}
CaseNode::CaseNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojure.rt.protobuf.bytecode.CaseNode)
}
CaseNode::CaseNode(const CaseNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CaseNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.tests_){from._impl_.tests_}
    , decltype(_impl_.thens_){from._impl_.thens_}
    , decltype(_impl_.high_){}
    , decltype(_impl_.low_){}
    , decltype(_impl_.isskipcheck_){}
    , decltype(_impl_.default__){nullptr}
    , decltype(_impl_.test_){nullptr}
    , decltype(_impl_.mask_){}
    , decltype(_impl_.shift_){}
    , decltype(_impl_.switchtype_){}
    , decltype(_impl_.testtype_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.high_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.high_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_high().empty()) {
    _this->_impl_.high_.Set(from._internal_high(), 
      _this->GetArenaForAllocation());
  }
  _impl_.low_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.low_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_low().empty()) {
    _this->_impl_.low_.Set(from._internal_low(), 
      _this->GetArenaForAllocation());
  }
  _impl_.isskipcheck_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.isskipcheck_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_isskipcheck().empty()) {
    _this->_impl_.isskipcheck_.Set(from._internal_isskipcheck(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_default_()) {
    _this->_impl_.default__ = new ::clojure::rt::protobuf::bytecode::Node(*from._impl_.default__);
  }
  if (from._internal_has_test()) {
    _this->_impl_.test_ = new ::clojure::rt::protobuf::bytecode::Node(*from._impl_.test_);
  }
  ::memcpy(&_impl_.mask_, &from._impl_.mask_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.testtype_) -
    reinterpret_cast<char*>(&_impl_.mask_)) + sizeof(_impl_.testtype_));
  // @@protoc_insertion_point(copy_constructor:clojure.rt.protobuf.bytecode.CaseNode)
}

inline void CaseNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.tests_){arena}
    , decltype(_impl_.thens_){arena}
    , decltype(_impl_.high_){}
    , decltype(_impl_.low_){}
    , decltype(_impl_.isskipcheck_){}
    , decltype(_impl_.default__){nullptr}
    , decltype(_impl_.test_){nullptr}
    , decltype(_impl_.mask_){0u}
    , decltype(_impl_.shift_){0u}
    , decltype(_impl_.switchtype_){0}
    , decltype(_impl_.testtype_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.high_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.high_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.low_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.low_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.isskipcheck_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.isskipcheck_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CaseNode::~CaseNode() {
  // @@protoc_insertion_point(destructor:clojure.rt.protobuf.bytecode.CaseNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CaseNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.tests_.~RepeatedPtrField();
  _impl_.thens_.~RepeatedPtrField();
  _impl_.high_.Destroy();
  _impl_.low_.Destroy();
  _impl_.isskipcheck_.Destroy();
  if (this != internal_default_instance()) delete _impl_.default__;
  if (this != internal_default_instance()) delete _impl_.test_;
}

void CaseNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CaseNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojure.rt.protobuf.bytecode.CaseNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.tests_.Clear();
  _impl_.thens_.Clear();
  _impl_.high_.ClearToEmpty();
  _impl_.low_.ClearToEmpty();
  _impl_.isskipcheck_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.default__ != nullptr) {
    delete _impl_.default__;
  }
  _impl_.default__ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.test_ != nullptr) {
    delete _impl_.test_;
  }
  _impl_.test_ = nullptr;
  ::memset(&_impl_.mask_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.testtype_) -
      reinterpret_cast<char*>(&_impl_.mask_)) + sizeof(_impl_.testtype_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CaseNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .clojure.rt.protobuf.bytecode.Node default = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_default_(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string high = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_high();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojure.rt.protobuf.bytecode.CaseNode.high"));
        } else
          goto handle_unusual;
        continue;
      // string low = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_low();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojure.rt.protobuf.bytecode.CaseNode.low"));
        } else
          goto handle_unusual;
        continue;
      // uint32 mask = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.mask_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 shift = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.shift_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string isSkipCheck = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_isskipcheck();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojure.rt.protobuf.bytecode.CaseNode.isSkipCheck"));
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.CaseNode.SwitchType switchType = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_switchtype(static_cast<::clojure::rt::protobuf::bytecode::CaseNode_SwitchType>(val));
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.Node test = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_test(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.CaseNode.TestType testType = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_testtype(static_cast<::clojure::rt::protobuf::bytecode::CaseNode_TestType>(val));
        } else
          goto handle_unusual;
        continue;
      // repeated .clojure.rt.protobuf.bytecode.Node tests = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_tests(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .clojure.rt.protobuf.bytecode.Node thens = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_thens(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CaseNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojure.rt.protobuf.bytecode.CaseNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .clojure.rt.protobuf.bytecode.Node default = 1;
  if (this->_internal_has_default_()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::default_(this),
        _Internal::default_(this).GetCachedSize(), target, stream);
  }

  // string high = 2;
  if (!this->_internal_high().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_high().data(), static_cast<int>(this->_internal_high().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojure.rt.protobuf.bytecode.CaseNode.high");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_high(), target);
  }

  // string low = 3;
  if (!this->_internal_low().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_low().data(), static_cast<int>(this->_internal_low().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojure.rt.protobuf.bytecode.CaseNode.low");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_low(), target);
  }

  // uint32 mask = 4;
  if (this->_internal_mask() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_mask(), target);
  }

  // uint32 shift = 5;
  if (this->_internal_shift() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_shift(), target);
  }

  // string isSkipCheck = 6;
  if (!this->_internal_isskipcheck().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_isskipcheck().data(), static_cast<int>(this->_internal_isskipcheck().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojure.rt.protobuf.bytecode.CaseNode.isSkipCheck");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_isskipcheck(), target);
  }

  // .clojure.rt.protobuf.bytecode.CaseNode.SwitchType switchType = 7;
  if (this->_internal_switchtype() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      7, this->_internal_switchtype(), target);
  }

  // .clojure.rt.protobuf.bytecode.Node test = 8;
  if (this->_internal_has_test()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::test(this),
        _Internal::test(this).GetCachedSize(), target, stream);
  }

  // .clojure.rt.protobuf.bytecode.CaseNode.TestType testType = 9;
  if (this->_internal_testtype() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      9, this->_internal_testtype(), target);
  }

  // repeated .clojure.rt.protobuf.bytecode.Node tests = 10;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_tests_size()); i < n; i++) {
    const auto& repfield = this->_internal_tests(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(10, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .clojure.rt.protobuf.bytecode.Node thens = 11;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_thens_size()); i < n; i++) {
    const auto& repfield = this->_internal_thens(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(11, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojure.rt.protobuf.bytecode.CaseNode)
  return target;
}

size_t CaseNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojure.rt.protobuf.bytecode.CaseNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .clojure.rt.protobuf.bytecode.Node tests = 10;
  total_size += 1UL * this->_internal_tests_size();
  for (const auto& msg : this->_impl_.tests_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .clojure.rt.protobuf.bytecode.Node thens = 11;
  total_size += 1UL * this->_internal_thens_size();
  for (const auto& msg : this->_impl_.thens_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string high = 2;
  if (!this->_internal_high().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_high());
  }

  // string low = 3;
  if (!this->_internal_low().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_low());
  }

  // string isSkipCheck = 6;
  if (!this->_internal_isskipcheck().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_isskipcheck());
  }

  // .clojure.rt.protobuf.bytecode.Node default = 1;
  if (this->_internal_has_default_()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.default__);
  }

  // .clojure.rt.protobuf.bytecode.Node test = 8;
  if (this->_internal_has_test()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.test_);
  }

  // uint32 mask = 4;
  if (this->_internal_mask() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_mask());
  }

  // uint32 shift = 5;
  if (this->_internal_shift() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_shift());
  }

  // .clojure.rt.protobuf.bytecode.CaseNode.SwitchType switchType = 7;
  if (this->_internal_switchtype() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_switchtype());
  }

  // .clojure.rt.protobuf.bytecode.CaseNode.TestType testType = 9;
  if (this->_internal_testtype() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_testtype());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CaseNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CaseNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CaseNode::GetClassData() const { return &_class_data_; }


void CaseNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CaseNode*>(&to_msg);
  auto& from = static_cast<const CaseNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojure.rt.protobuf.bytecode.CaseNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.tests_.MergeFrom(from._impl_.tests_);
  _this->_impl_.thens_.MergeFrom(from._impl_.thens_);
  if (!from._internal_high().empty()) {
    _this->_internal_set_high(from._internal_high());
  }
  if (!from._internal_low().empty()) {
    _this->_internal_set_low(from._internal_low());
  }
  if (!from._internal_isskipcheck().empty()) {
    _this->_internal_set_isskipcheck(from._internal_isskipcheck());
  }
  if (from._internal_has_default_()) {
    _this->_internal_mutable_default_()->::clojure::rt::protobuf::bytecode::Node::MergeFrom(
        from._internal_default_());
  }
  if (from._internal_has_test()) {
    _this->_internal_mutable_test()->::clojure::rt::protobuf::bytecode::Node::MergeFrom(
        from._internal_test());
  }
  if (from._internal_mask() != 0) {
    _this->_internal_set_mask(from._internal_mask());
  }
  if (from._internal_shift() != 0) {
    _this->_internal_set_shift(from._internal_shift());
  }
  if (from._internal_switchtype() != 0) {
    _this->_internal_set_switchtype(from._internal_switchtype());
  }
  if (from._internal_testtype() != 0) {
    _this->_internal_set_testtype(from._internal_testtype());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CaseNode::CopyFrom(const CaseNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojure.rt.protobuf.bytecode.CaseNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CaseNode::IsInitialized() const {
  return true;
}

void CaseNode::InternalSwap(CaseNode* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.tests_.InternalSwap(&other->_impl_.tests_);
  _impl_.thens_.InternalSwap(&other->_impl_.thens_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.high_, lhs_arena,
      &other->_impl_.high_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.low_, lhs_arena,
      &other->_impl_.low_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.isskipcheck_, lhs_arena,
      &other->_impl_.isskipcheck_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CaseNode, _impl_.testtype_)
      + sizeof(CaseNode::_impl_.testtype_)
      - PROTOBUF_FIELD_OFFSET(CaseNode, _impl_.default__)>(
          reinterpret_cast<char*>(&_impl_.default__),
          reinterpret_cast<char*>(&other->_impl_.default__));
}

::PROTOBUF_NAMESPACE_ID::Metadata CaseNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[3]);
}

// ===================================================================

class CaseTestNode::_Internal {
 public:
  static const ::clojure::rt::protobuf::bytecode::Node& test(const CaseTestNode* msg);
};

const ::clojure::rt::protobuf::bytecode::Node&
CaseTestNode::_Internal::test(const CaseTestNode* msg) {
  return *msg->_impl_.test_;
}
CaseTestNode::CaseTestNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojure.rt.protobuf.bytecode.CaseTestNode)
}
CaseTestNode::CaseTestNode(const CaseTestNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CaseTestNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.test_){nullptr}
    , decltype(_impl_.hash_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_test()) {
    _this->_impl_.test_ = new ::clojure::rt::protobuf::bytecode::Node(*from._impl_.test_);
  }
  _this->_impl_.hash_ = from._impl_.hash_;
  // @@protoc_insertion_point(copy_constructor:clojure.rt.protobuf.bytecode.CaseTestNode)
}

inline void CaseTestNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.test_){nullptr}
    , decltype(_impl_.hash_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CaseTestNode::~CaseTestNode() {
  // @@protoc_insertion_point(destructor:clojure.rt.protobuf.bytecode.CaseTestNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CaseTestNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.test_;
}

void CaseTestNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CaseTestNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojure.rt.protobuf.bytecode.CaseTestNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.test_ != nullptr) {
    delete _impl_.test_;
  }
  _impl_.test_ = nullptr;
  _impl_.hash_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CaseTestNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 hash = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.hash_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.Node test = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_test(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CaseTestNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojure.rt.protobuf.bytecode.CaseTestNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 hash = 1;
  if (this->_internal_hash() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_hash(), target);
  }

  // .clojure.rt.protobuf.bytecode.Node test = 2;
  if (this->_internal_has_test()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::test(this),
        _Internal::test(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojure.rt.protobuf.bytecode.CaseTestNode)
  return target;
}

size_t CaseTestNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojure.rt.protobuf.bytecode.CaseTestNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .clojure.rt.protobuf.bytecode.Node test = 2;
  if (this->_internal_has_test()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.test_);
  }

  // uint32 hash = 1;
  if (this->_internal_hash() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_hash());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CaseTestNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CaseTestNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CaseTestNode::GetClassData() const { return &_class_data_; }


void CaseTestNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CaseTestNode*>(&to_msg);
  auto& from = static_cast<const CaseTestNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojure.rt.protobuf.bytecode.CaseTestNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_test()) {
    _this->_internal_mutable_test()->::clojure::rt::protobuf::bytecode::Node::MergeFrom(
        from._internal_test());
  }
  if (from._internal_hash() != 0) {
    _this->_internal_set_hash(from._internal_hash());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CaseTestNode::CopyFrom(const CaseTestNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojure.rt.protobuf.bytecode.CaseTestNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CaseTestNode::IsInitialized() const {
  return true;
}

void CaseTestNode::InternalSwap(CaseTestNode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CaseTestNode, _impl_.hash_)
      + sizeof(CaseTestNode::_impl_.hash_)
      - PROTOBUF_FIELD_OFFSET(CaseTestNode, _impl_.test_)>(
          reinterpret_cast<char*>(&_impl_.test_),
          reinterpret_cast<char*>(&other->_impl_.test_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CaseTestNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[4]);
}

// ===================================================================

class CaseThenNode::_Internal {
 public:
  static const ::clojure::rt::protobuf::bytecode::Node& then(const CaseThenNode* msg);
};

const ::clojure::rt::protobuf::bytecode::Node&
CaseThenNode::_Internal::then(const CaseThenNode* msg) {
  return *msg->_impl_.then_;
}
CaseThenNode::CaseThenNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojure.rt.protobuf.bytecode.CaseThenNode)
}
CaseThenNode::CaseThenNode(const CaseThenNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CaseThenNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.then_){nullptr}
    , decltype(_impl_.hash_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_then()) {
    _this->_impl_.then_ = new ::clojure::rt::protobuf::bytecode::Node(*from._impl_.then_);
  }
  _this->_impl_.hash_ = from._impl_.hash_;
  // @@protoc_insertion_point(copy_constructor:clojure.rt.protobuf.bytecode.CaseThenNode)
}

inline void CaseThenNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.then_){nullptr}
    , decltype(_impl_.hash_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CaseThenNode::~CaseThenNode() {
  // @@protoc_insertion_point(destructor:clojure.rt.protobuf.bytecode.CaseThenNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CaseThenNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.then_;
}

void CaseThenNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CaseThenNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojure.rt.protobuf.bytecode.CaseThenNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.then_ != nullptr) {
    delete _impl_.then_;
  }
  _impl_.then_ = nullptr;
  _impl_.hash_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CaseThenNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 hash = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.hash_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.Node then = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_then(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CaseThenNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojure.rt.protobuf.bytecode.CaseThenNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 hash = 1;
  if (this->_internal_hash() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_hash(), target);
  }

  // .clojure.rt.protobuf.bytecode.Node then = 2;
  if (this->_internal_has_then()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::then(this),
        _Internal::then(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojure.rt.protobuf.bytecode.CaseThenNode)
  return target;
}

size_t CaseThenNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojure.rt.protobuf.bytecode.CaseThenNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .clojure.rt.protobuf.bytecode.Node then = 2;
  if (this->_internal_has_then()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.then_);
  }

  // uint32 hash = 1;
  if (this->_internal_hash() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_hash());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CaseThenNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CaseThenNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CaseThenNode::GetClassData() const { return &_class_data_; }


void CaseThenNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CaseThenNode*>(&to_msg);
  auto& from = static_cast<const CaseThenNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojure.rt.protobuf.bytecode.CaseThenNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_then()) {
    _this->_internal_mutable_then()->::clojure::rt::protobuf::bytecode::Node::MergeFrom(
        from._internal_then());
  }
  if (from._internal_hash() != 0) {
    _this->_internal_set_hash(from._internal_hash());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CaseThenNode::CopyFrom(const CaseThenNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojure.rt.protobuf.bytecode.CaseThenNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CaseThenNode::IsInitialized() const {
  return true;
}

void CaseThenNode::InternalSwap(CaseThenNode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CaseThenNode, _impl_.hash_)
      + sizeof(CaseThenNode::_impl_.hash_)
      - PROTOBUF_FIELD_OFFSET(CaseThenNode, _impl_.then_)>(
          reinterpret_cast<char*>(&_impl_.then_),
          reinterpret_cast<char*>(&other->_impl_.then_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CaseThenNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[5]);
}

// ===================================================================

class CatchNode::_Internal {
 public:
  static const ::clojure::rt::protobuf::bytecode::Node& body(const CatchNode* msg);
  static const ::clojure::rt::protobuf::bytecode::Node& class_(const CatchNode* msg);
  static const ::clojure::rt::protobuf::bytecode::Node& local(const CatchNode* msg);
};

const ::clojure::rt::protobuf::bytecode::Node&
CatchNode::_Internal::body(const CatchNode* msg) {
  return *msg->_impl_.body_;
}
const ::clojure::rt::protobuf::bytecode::Node&
CatchNode::_Internal::class_(const CatchNode* msg) {
  return *msg->_impl_.class__;
}
const ::clojure::rt::protobuf::bytecode::Node&
CatchNode::_Internal::local(const CatchNode* msg) {
  return *msg->_impl_.local_;
}
CatchNode::CatchNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojure.rt.protobuf.bytecode.CatchNode)
}
CatchNode::CatchNode(const CatchNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CatchNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.body_){nullptr}
    , decltype(_impl_.class__){nullptr}
    , decltype(_impl_.local_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_body()) {
    _this->_impl_.body_ = new ::clojure::rt::protobuf::bytecode::Node(*from._impl_.body_);
  }
  if (from._internal_has_class_()) {
    _this->_impl_.class__ = new ::clojure::rt::protobuf::bytecode::Node(*from._impl_.class__);
  }
  if (from._internal_has_local()) {
    _this->_impl_.local_ = new ::clojure::rt::protobuf::bytecode::Node(*from._impl_.local_);
  }
  // @@protoc_insertion_point(copy_constructor:clojure.rt.protobuf.bytecode.CatchNode)
}

inline void CatchNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.body_){nullptr}
    , decltype(_impl_.class__){nullptr}
    , decltype(_impl_.local_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CatchNode::~CatchNode() {
  // @@protoc_insertion_point(destructor:clojure.rt.protobuf.bytecode.CatchNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CatchNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.body_;
  if (this != internal_default_instance()) delete _impl_.class__;
  if (this != internal_default_instance()) delete _impl_.local_;
}

void CatchNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CatchNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojure.rt.protobuf.bytecode.CatchNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.body_ != nullptr) {
    delete _impl_.body_;
  }
  _impl_.body_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.class__ != nullptr) {
    delete _impl_.class__;
  }
  _impl_.class__ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.local_ != nullptr) {
    delete _impl_.local_;
  }
  _impl_.local_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CatchNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .clojure.rt.protobuf.bytecode.Node body = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_body(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.Node class = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_class_(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.Node local = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_local(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CatchNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojure.rt.protobuf.bytecode.CatchNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .clojure.rt.protobuf.bytecode.Node body = 1;
  if (this->_internal_has_body()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::body(this),
        _Internal::body(this).GetCachedSize(), target, stream);
  }

  // .clojure.rt.protobuf.bytecode.Node class = 2;
  if (this->_internal_has_class_()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::class_(this),
        _Internal::class_(this).GetCachedSize(), target, stream);
  }

  // .clojure.rt.protobuf.bytecode.Node local = 3;
  if (this->_internal_has_local()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::local(this),
        _Internal::local(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojure.rt.protobuf.bytecode.CatchNode)
  return target;
}

size_t CatchNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojure.rt.protobuf.bytecode.CatchNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .clojure.rt.protobuf.bytecode.Node body = 1;
  if (this->_internal_has_body()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.body_);
  }

  // .clojure.rt.protobuf.bytecode.Node class = 2;
  if (this->_internal_has_class_()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.class__);
  }

  // .clojure.rt.protobuf.bytecode.Node local = 3;
  if (this->_internal_has_local()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.local_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CatchNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CatchNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CatchNode::GetClassData() const { return &_class_data_; }


void CatchNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CatchNode*>(&to_msg);
  auto& from = static_cast<const CatchNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojure.rt.protobuf.bytecode.CatchNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_body()) {
    _this->_internal_mutable_body()->::clojure::rt::protobuf::bytecode::Node::MergeFrom(
        from._internal_body());
  }
  if (from._internal_has_class_()) {
    _this->_internal_mutable_class_()->::clojure::rt::protobuf::bytecode::Node::MergeFrom(
        from._internal_class_());
  }
  if (from._internal_has_local()) {
    _this->_internal_mutable_local()->::clojure::rt::protobuf::bytecode::Node::MergeFrom(
        from._internal_local());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CatchNode::CopyFrom(const CatchNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojure.rt.protobuf.bytecode.CatchNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CatchNode::IsInitialized() const {
  return true;
}

void CatchNode::InternalSwap(CatchNode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CatchNode, _impl_.local_)
      + sizeof(CatchNode::_impl_.local_)
      - PROTOBUF_FIELD_OFFSET(CatchNode, _impl_.body_)>(
          reinterpret_cast<char*>(&_impl_.body_),
          reinterpret_cast<char*>(&other->_impl_.body_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CatchNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[6]);
}

// ===================================================================

class ConstNode::_Internal {
 public:
  static const ::clojure::rt::protobuf::bytecode::Node& meta(const ConstNode* msg);
};

const ::clojure::rt::protobuf::bytecode::Node&
ConstNode::_Internal::meta(const ConstNode* msg) {
  return *msg->_impl_.meta_;
}
ConstNode::ConstNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojure.rt.protobuf.bytecode.ConstNode)
}
ConstNode::ConstNode(const ConstNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ConstNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.val_){}
    , decltype(_impl_.meta_){nullptr}
    , decltype(_impl_.isliteral_){}
    , decltype(_impl_.type_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.val_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.val_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_val().empty()) {
    _this->_impl_.val_.Set(from._internal_val(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_meta()) {
    _this->_impl_.meta_ = new ::clojure::rt::protobuf::bytecode::Node(*from._impl_.meta_);
  }
  ::memcpy(&_impl_.isliteral_, &from._impl_.isliteral_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.type_) -
    reinterpret_cast<char*>(&_impl_.isliteral_)) + sizeof(_impl_.type_));
  // @@protoc_insertion_point(copy_constructor:clojure.rt.protobuf.bytecode.ConstNode)
}

inline void ConstNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.val_){}
    , decltype(_impl_.meta_){nullptr}
    , decltype(_impl_.isliteral_){false}
    , decltype(_impl_.type_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.val_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.val_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ConstNode::~ConstNode() {
  // @@protoc_insertion_point(destructor:clojure.rt.protobuf.bytecode.ConstNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ConstNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.val_.Destroy();
  if (this != internal_default_instance()) delete _impl_.meta_;
}

void ConstNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ConstNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojure.rt.protobuf.bytecode.ConstNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.val_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.meta_ != nullptr) {
    delete _impl_.meta_;
  }
  _impl_.meta_ = nullptr;
  ::memset(&_impl_.isliteral_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.type_) -
      reinterpret_cast<char*>(&_impl_.isliteral_)) + sizeof(_impl_.type_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ConstNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool isLiteral = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.isliteral_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.Node meta = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_meta(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.ConstNode.ConstType type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::clojure::rt::protobuf::bytecode::ConstNode_ConstType>(val));
        } else
          goto handle_unusual;
        continue;
      // string val = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_val();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojure.rt.protobuf.bytecode.ConstNode.val"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ConstNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojure.rt.protobuf.bytecode.ConstNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool isLiteral = 1;
  if (this->_internal_isliteral() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_isliteral(), target);
  }

  // .clojure.rt.protobuf.bytecode.Node meta = 2;
  if (this->_internal_has_meta()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::meta(this),
        _Internal::meta(this).GetCachedSize(), target, stream);
  }

  // .clojure.rt.protobuf.bytecode.ConstNode.ConstType type = 3;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_type(), target);
  }

  // string val = 4;
  if (!this->_internal_val().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_val().data(), static_cast<int>(this->_internal_val().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojure.rt.protobuf.bytecode.ConstNode.val");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_val(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojure.rt.protobuf.bytecode.ConstNode)
  return target;
}

size_t ConstNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojure.rt.protobuf.bytecode.ConstNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string val = 4;
  if (!this->_internal_val().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_val());
  }

  // .clojure.rt.protobuf.bytecode.Node meta = 2;
  if (this->_internal_has_meta()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.meta_);
  }

  // bool isLiteral = 1;
  if (this->_internal_isliteral() != 0) {
    total_size += 1 + 1;
  }

  // .clojure.rt.protobuf.bytecode.ConstNode.ConstType type = 3;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ConstNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ConstNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ConstNode::GetClassData() const { return &_class_data_; }


void ConstNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ConstNode*>(&to_msg);
  auto& from = static_cast<const ConstNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojure.rt.protobuf.bytecode.ConstNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_val().empty()) {
    _this->_internal_set_val(from._internal_val());
  }
  if (from._internal_has_meta()) {
    _this->_internal_mutable_meta()->::clojure::rt::protobuf::bytecode::Node::MergeFrom(
        from._internal_meta());
  }
  if (from._internal_isliteral() != 0) {
    _this->_internal_set_isliteral(from._internal_isliteral());
  }
  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ConstNode::CopyFrom(const ConstNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojure.rt.protobuf.bytecode.ConstNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConstNode::IsInitialized() const {
  return true;
}

void ConstNode::InternalSwap(ConstNode* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.val_, lhs_arena,
      &other->_impl_.val_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ConstNode, _impl_.type_)
      + sizeof(ConstNode::_impl_.type_)
      - PROTOBUF_FIELD_OFFSET(ConstNode, _impl_.meta_)>(
          reinterpret_cast<char*>(&_impl_.meta_),
          reinterpret_cast<char*>(&other->_impl_.meta_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ConstNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[7]);
}

// ===================================================================

class DefNode::_Internal {
 public:
  static const ::clojure::rt::protobuf::bytecode::Node& init(const DefNode* msg);
  static const ::clojure::rt::protobuf::bytecode::Node& meta(const DefNode* msg);
};

const ::clojure::rt::protobuf::bytecode::Node&
DefNode::_Internal::init(const DefNode* msg) {
  return *msg->_impl_.init_;
}
const ::clojure::rt::protobuf::bytecode::Node&
DefNode::_Internal::meta(const DefNode* msg) {
  return *msg->_impl_.meta_;
}
DefNode::DefNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojure.rt.protobuf.bytecode.DefNode)
}
DefNode::DefNode(const DefNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DefNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.doc_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.var_){}
    , decltype(_impl_.init_){nullptr}
    , decltype(_impl_.meta_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.doc_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.doc_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_doc().empty()) {
    _this->_impl_.doc_.Set(from._internal_doc(), 
      _this->GetArenaForAllocation());
  }
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.var_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.var_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_var().empty()) {
    _this->_impl_.var_.Set(from._internal_var(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_init()) {
    _this->_impl_.init_ = new ::clojure::rt::protobuf::bytecode::Node(*from._impl_.init_);
  }
  if (from._internal_has_meta()) {
    _this->_impl_.meta_ = new ::clojure::rt::protobuf::bytecode::Node(*from._impl_.meta_);
  }
  // @@protoc_insertion_point(copy_constructor:clojure.rt.protobuf.bytecode.DefNode)
}

inline void DefNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.doc_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.var_){}
    , decltype(_impl_.init_){nullptr}
    , decltype(_impl_.meta_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.doc_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.doc_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.var_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.var_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DefNode::~DefNode() {
  // @@protoc_insertion_point(destructor:clojure.rt.protobuf.bytecode.DefNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DefNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.doc_.Destroy();
  _impl_.name_.Destroy();
  _impl_.var_.Destroy();
  if (this != internal_default_instance()) delete _impl_.init_;
  if (this != internal_default_instance()) delete _impl_.meta_;
}

void DefNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DefNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojure.rt.protobuf.bytecode.DefNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.doc_.ClearToEmpty();
  _impl_.name_.ClearToEmpty();
  _impl_.var_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.init_ != nullptr) {
    delete _impl_.init_;
  }
  _impl_.init_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.meta_ != nullptr) {
    delete _impl_.meta_;
  }
  _impl_.meta_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DefNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string doc = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_doc();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojure.rt.protobuf.bytecode.DefNode.doc"));
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.Node init = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_init(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.Node meta = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_meta(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string name = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojure.rt.protobuf.bytecode.DefNode.name"));
        } else
          goto handle_unusual;
        continue;
      // string var = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_var();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojure.rt.protobuf.bytecode.DefNode.var"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DefNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojure.rt.protobuf.bytecode.DefNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string doc = 1;
  if (!this->_internal_doc().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_doc().data(), static_cast<int>(this->_internal_doc().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojure.rt.protobuf.bytecode.DefNode.doc");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_doc(), target);
  }

  // .clojure.rt.protobuf.bytecode.Node init = 2;
  if (this->_internal_has_init()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::init(this),
        _Internal::init(this).GetCachedSize(), target, stream);
  }

  // .clojure.rt.protobuf.bytecode.Node meta = 3;
  if (this->_internal_has_meta()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::meta(this),
        _Internal::meta(this).GetCachedSize(), target, stream);
  }

  // string name = 4;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojure.rt.protobuf.bytecode.DefNode.name");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_name(), target);
  }

  // string var = 5;
  if (!this->_internal_var().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_var().data(), static_cast<int>(this->_internal_var().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojure.rt.protobuf.bytecode.DefNode.var");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_var(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojure.rt.protobuf.bytecode.DefNode)
  return target;
}

size_t DefNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojure.rt.protobuf.bytecode.DefNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string doc = 1;
  if (!this->_internal_doc().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_doc());
  }

  // string name = 4;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string var = 5;
  if (!this->_internal_var().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_var());
  }

  // .clojure.rt.protobuf.bytecode.Node init = 2;
  if (this->_internal_has_init()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.init_);
  }

  // .clojure.rt.protobuf.bytecode.Node meta = 3;
  if (this->_internal_has_meta()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.meta_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DefNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DefNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DefNode::GetClassData() const { return &_class_data_; }


void DefNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DefNode*>(&to_msg);
  auto& from = static_cast<const DefNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojure.rt.protobuf.bytecode.DefNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_doc().empty()) {
    _this->_internal_set_doc(from._internal_doc());
  }
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_var().empty()) {
    _this->_internal_set_var(from._internal_var());
  }
  if (from._internal_has_init()) {
    _this->_internal_mutable_init()->::clojure::rt::protobuf::bytecode::Node::MergeFrom(
        from._internal_init());
  }
  if (from._internal_has_meta()) {
    _this->_internal_mutable_meta()->::clojure::rt::protobuf::bytecode::Node::MergeFrom(
        from._internal_meta());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DefNode::CopyFrom(const DefNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojure.rt.protobuf.bytecode.DefNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DefNode::IsInitialized() const {
  return true;
}

void DefNode::InternalSwap(DefNode* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.doc_, lhs_arena,
      &other->_impl_.doc_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.var_, lhs_arena,
      &other->_impl_.var_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DefNode, _impl_.meta_)
      + sizeof(DefNode::_impl_.meta_)
      - PROTOBUF_FIELD_OFFSET(DefNode, _impl_.init_)>(
          reinterpret_cast<char*>(&_impl_.init_),
          reinterpret_cast<char*>(&other->_impl_.init_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DefNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[8]);
}

// ===================================================================

class DeftypeNode::_Internal {
 public:
};

DeftypeNode::DeftypeNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojure.rt.protobuf.bytecode.DeftypeNode)
}
DeftypeNode::DeftypeNode(const DeftypeNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DeftypeNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.fields_){from._impl_.fields_}
    , decltype(_impl_.interfaces_){from._impl_.interfaces_}
    , decltype(_impl_.methods_){from._impl_.methods_}
    , decltype(_impl_.classname_){}
    , decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.classname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.classname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_classname().empty()) {
    _this->_impl_.classname_.Set(from._internal_classname(), 
      _this->GetArenaForAllocation());
  }
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:clojure.rt.protobuf.bytecode.DeftypeNode)
}

inline void DeftypeNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.fields_){arena}
    , decltype(_impl_.interfaces_){arena}
    , decltype(_impl_.methods_){arena}
    , decltype(_impl_.classname_){}
    , decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.classname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.classname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DeftypeNode::~DeftypeNode() {
  // @@protoc_insertion_point(destructor:clojure.rt.protobuf.bytecode.DeftypeNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeftypeNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.fields_.~RepeatedPtrField();
  _impl_.interfaces_.~RepeatedPtrField();
  _impl_.methods_.~RepeatedPtrField();
  _impl_.classname_.Destroy();
  _impl_.name_.Destroy();
}

void DeftypeNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeftypeNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojure.rt.protobuf.bytecode.DeftypeNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.fields_.Clear();
  _impl_.interfaces_.Clear();
  _impl_.methods_.Clear();
  _impl_.classname_.ClearToEmpty();
  _impl_.name_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DeftypeNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string className = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_classname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojure.rt.protobuf.bytecode.DeftypeNode.className"));
        } else
          goto handle_unusual;
        continue;
      // repeated .clojure.rt.protobuf.bytecode.Node fields = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_fields(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string interfaces = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_interfaces();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "clojure.rt.protobuf.bytecode.DeftypeNode.interfaces"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .clojure.rt.protobuf.bytecode.Node methods = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_methods(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string name = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojure.rt.protobuf.bytecode.DeftypeNode.name"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeftypeNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojure.rt.protobuf.bytecode.DeftypeNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string className = 1;
  if (!this->_internal_classname().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_classname().data(), static_cast<int>(this->_internal_classname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojure.rt.protobuf.bytecode.DeftypeNode.className");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_classname(), target);
  }

  // repeated .clojure.rt.protobuf.bytecode.Node fields = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_fields_size()); i < n; i++) {
    const auto& repfield = this->_internal_fields(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated string interfaces = 3;
  for (int i = 0, n = this->_internal_interfaces_size(); i < n; i++) {
    const auto& s = this->_internal_interfaces(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojure.rt.protobuf.bytecode.DeftypeNode.interfaces");
    target = stream->WriteString(3, s, target);
  }

  // repeated .clojure.rt.protobuf.bytecode.Node methods = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_methods_size()); i < n; i++) {
    const auto& repfield = this->_internal_methods(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // string name = 5;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojure.rt.protobuf.bytecode.DeftypeNode.name");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojure.rt.protobuf.bytecode.DeftypeNode)
  return target;
}

size_t DeftypeNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojure.rt.protobuf.bytecode.DeftypeNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .clojure.rt.protobuf.bytecode.Node fields = 2;
  total_size += 1UL * this->_internal_fields_size();
  for (const auto& msg : this->_impl_.fields_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated string interfaces = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.interfaces_.size());
  for (int i = 0, n = _impl_.interfaces_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.interfaces_.Get(i));
  }

  // repeated .clojure.rt.protobuf.bytecode.Node methods = 4;
  total_size += 1UL * this->_internal_methods_size();
  for (const auto& msg : this->_impl_.methods_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string className = 1;
  if (!this->_internal_classname().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_classname());
  }

  // string name = 5;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DeftypeNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DeftypeNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DeftypeNode::GetClassData() const { return &_class_data_; }


void DeftypeNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DeftypeNode*>(&to_msg);
  auto& from = static_cast<const DeftypeNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojure.rt.protobuf.bytecode.DeftypeNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.fields_.MergeFrom(from._impl_.fields_);
  _this->_impl_.interfaces_.MergeFrom(from._impl_.interfaces_);
  _this->_impl_.methods_.MergeFrom(from._impl_.methods_);
  if (!from._internal_classname().empty()) {
    _this->_internal_set_classname(from._internal_classname());
  }
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DeftypeNode::CopyFrom(const DeftypeNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojure.rt.protobuf.bytecode.DeftypeNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeftypeNode::IsInitialized() const {
  return true;
}

void DeftypeNode::InternalSwap(DeftypeNode* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.fields_.InternalSwap(&other->_impl_.fields_);
  _impl_.interfaces_.InternalSwap(&other->_impl_.interfaces_);
  _impl_.methods_.InternalSwap(&other->_impl_.methods_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.classname_, lhs_arena,
      &other->_impl_.classname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata DeftypeNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[9]);
}

// ===================================================================

class DoNode::_Internal {
 public:
  static const ::clojure::rt::protobuf::bytecode::Node& ret(const DoNode* msg);
};

const ::clojure::rt::protobuf::bytecode::Node&
DoNode::_Internal::ret(const DoNode* msg) {
  return *msg->_impl_.ret_;
}
DoNode::DoNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojure.rt.protobuf.bytecode.DoNode)
}
DoNode::DoNode(const DoNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DoNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.statements_){from._impl_.statements_}
    , decltype(_impl_.ret_){nullptr}
    , decltype(_impl_.isbody_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_ret()) {
    _this->_impl_.ret_ = new ::clojure::rt::protobuf::bytecode::Node(*from._impl_.ret_);
  }
  _this->_impl_.isbody_ = from._impl_.isbody_;
  // @@protoc_insertion_point(copy_constructor:clojure.rt.protobuf.bytecode.DoNode)
}

inline void DoNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.statements_){arena}
    , decltype(_impl_.ret_){nullptr}
    , decltype(_impl_.isbody_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

DoNode::~DoNode() {
  // @@protoc_insertion_point(destructor:clojure.rt.protobuf.bytecode.DoNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DoNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.statements_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.ret_;
}

void DoNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DoNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojure.rt.protobuf.bytecode.DoNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.statements_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.ret_ != nullptr) {
    delete _impl_.ret_;
  }
  _impl_.ret_ = nullptr;
  _impl_.isbody_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DoNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool isBody = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.isbody_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.Node ret = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_ret(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .clojure.rt.protobuf.bytecode.Node statements = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_statements(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DoNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojure.rt.protobuf.bytecode.DoNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool isBody = 1;
  if (this->_internal_isbody() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_isbody(), target);
  }

  // .clojure.rt.protobuf.bytecode.Node ret = 2;
  if (this->_internal_has_ret()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::ret(this),
        _Internal::ret(this).GetCachedSize(), target, stream);
  }

  // repeated .clojure.rt.protobuf.bytecode.Node statements = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_statements_size()); i < n; i++) {
    const auto& repfield = this->_internal_statements(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojure.rt.protobuf.bytecode.DoNode)
  return target;
}

size_t DoNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojure.rt.protobuf.bytecode.DoNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .clojure.rt.protobuf.bytecode.Node statements = 3;
  total_size += 1UL * this->_internal_statements_size();
  for (const auto& msg : this->_impl_.statements_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .clojure.rt.protobuf.bytecode.Node ret = 2;
  if (this->_internal_has_ret()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.ret_);
  }

  // bool isBody = 1;
  if (this->_internal_isbody() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DoNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DoNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DoNode::GetClassData() const { return &_class_data_; }


void DoNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DoNode*>(&to_msg);
  auto& from = static_cast<const DoNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojure.rt.protobuf.bytecode.DoNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.statements_.MergeFrom(from._impl_.statements_);
  if (from._internal_has_ret()) {
    _this->_internal_mutable_ret()->::clojure::rt::protobuf::bytecode::Node::MergeFrom(
        from._internal_ret());
  }
  if (from._internal_isbody() != 0) {
    _this->_internal_set_isbody(from._internal_isbody());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DoNode::CopyFrom(const DoNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojure.rt.protobuf.bytecode.DoNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DoNode::IsInitialized() const {
  return true;
}

void DoNode::InternalSwap(DoNode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.statements_.InternalSwap(&other->_impl_.statements_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DoNode, _impl_.isbody_)
      + sizeof(DoNode::_impl_.isbody_)
      - PROTOBUF_FIELD_OFFSET(DoNode, _impl_.ret_)>(
          reinterpret_cast<char*>(&_impl_.ret_),
          reinterpret_cast<char*>(&other->_impl_.ret_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DoNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[10]);
}

// ===================================================================

class FnNode::_Internal {
 public:
  static const ::clojure::rt::protobuf::bytecode::Node& local(const FnNode* msg);
};

const ::clojure::rt::protobuf::bytecode::Node&
FnNode::_Internal::local(const FnNode* msg) {
  return *msg->_impl_.local_;
}
FnNode::FnNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojure.rt.protobuf.bytecode.FnNode)
}
FnNode::FnNode(const FnNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FnNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.methods_){from._impl_.methods_}
    , decltype(_impl_.local_){nullptr}
    , decltype(_impl_.maxfixedarity_){}
    , decltype(_impl_.once_){}
    , decltype(_impl_.isvariadic_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_local()) {
    _this->_impl_.local_ = new ::clojure::rt::protobuf::bytecode::Node(*from._impl_.local_);
  }
  ::memcpy(&_impl_.maxfixedarity_, &from._impl_.maxfixedarity_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.isvariadic_) -
    reinterpret_cast<char*>(&_impl_.maxfixedarity_)) + sizeof(_impl_.isvariadic_));
  // @@protoc_insertion_point(copy_constructor:clojure.rt.protobuf.bytecode.FnNode)
}

inline void FnNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.methods_){arena}
    , decltype(_impl_.local_){nullptr}
    , decltype(_impl_.maxfixedarity_){0u}
    , decltype(_impl_.once_){false}
    , decltype(_impl_.isvariadic_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

FnNode::~FnNode() {
  // @@protoc_insertion_point(destructor:clojure.rt.protobuf.bytecode.FnNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FnNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.methods_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.local_;
}

void FnNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FnNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojure.rt.protobuf.bytecode.FnNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.methods_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.local_ != nullptr) {
    delete _impl_.local_;
  }
  _impl_.local_ = nullptr;
  ::memset(&_impl_.maxfixedarity_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.isvariadic_) -
      reinterpret_cast<char*>(&_impl_.maxfixedarity_)) + sizeof(_impl_.isvariadic_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FnNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .clojure.rt.protobuf.bytecode.Node local = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_local(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 maxFixedArity = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.maxfixedarity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .clojure.rt.protobuf.bytecode.Node methods = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_methods(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // bool once = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.once_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool isVariadic = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.isvariadic_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FnNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojure.rt.protobuf.bytecode.FnNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .clojure.rt.protobuf.bytecode.Node local = 1;
  if (this->_internal_has_local()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::local(this),
        _Internal::local(this).GetCachedSize(), target, stream);
  }

  // uint32 maxFixedArity = 2;
  if (this->_internal_maxfixedarity() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_maxfixedarity(), target);
  }

  // repeated .clojure.rt.protobuf.bytecode.Node methods = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_methods_size()); i < n; i++) {
    const auto& repfield = this->_internal_methods(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // bool once = 4;
  if (this->_internal_once() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_once(), target);
  }

  // bool isVariadic = 5;
  if (this->_internal_isvariadic() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_isvariadic(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojure.rt.protobuf.bytecode.FnNode)
  return target;
}

size_t FnNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojure.rt.protobuf.bytecode.FnNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .clojure.rt.protobuf.bytecode.Node methods = 3;
  total_size += 1UL * this->_internal_methods_size();
  for (const auto& msg : this->_impl_.methods_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .clojure.rt.protobuf.bytecode.Node local = 1;
  if (this->_internal_has_local()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.local_);
  }

  // uint32 maxFixedArity = 2;
  if (this->_internal_maxfixedarity() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_maxfixedarity());
  }

  // bool once = 4;
  if (this->_internal_once() != 0) {
    total_size += 1 + 1;
  }

  // bool isVariadic = 5;
  if (this->_internal_isvariadic() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FnNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FnNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FnNode::GetClassData() const { return &_class_data_; }


void FnNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FnNode*>(&to_msg);
  auto& from = static_cast<const FnNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojure.rt.protobuf.bytecode.FnNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.methods_.MergeFrom(from._impl_.methods_);
  if (from._internal_has_local()) {
    _this->_internal_mutable_local()->::clojure::rt::protobuf::bytecode::Node::MergeFrom(
        from._internal_local());
  }
  if (from._internal_maxfixedarity() != 0) {
    _this->_internal_set_maxfixedarity(from._internal_maxfixedarity());
  }
  if (from._internal_once() != 0) {
    _this->_internal_set_once(from._internal_once());
  }
  if (from._internal_isvariadic() != 0) {
    _this->_internal_set_isvariadic(from._internal_isvariadic());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FnNode::CopyFrom(const FnNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojure.rt.protobuf.bytecode.FnNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FnNode::IsInitialized() const {
  return true;
}

void FnNode::InternalSwap(FnNode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.methods_.InternalSwap(&other->_impl_.methods_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FnNode, _impl_.isvariadic_)
      + sizeof(FnNode::_impl_.isvariadic_)
      - PROTOBUF_FIELD_OFFSET(FnNode, _impl_.local_)>(
          reinterpret_cast<char*>(&_impl_.local_),
          reinterpret_cast<char*>(&other->_impl_.local_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FnNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[11]);
}

// ===================================================================

class FnMethodNode::_Internal {
 public:
  static const ::clojure::rt::protobuf::bytecode::Node& body(const FnMethodNode* msg);
};

const ::clojure::rt::protobuf::bytecode::Node&
FnMethodNode::_Internal::body(const FnMethodNode* msg) {
  return *msg->_impl_.body_;
}
FnMethodNode::FnMethodNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojure.rt.protobuf.bytecode.FnMethodNode)
}
FnMethodNode::FnMethodNode(const FnMethodNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FnMethodNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.params_){from._impl_.params_}
    , decltype(_impl_.loopid_){}
    , decltype(_impl_.body_){nullptr}
    , decltype(_impl_.fixedarity_){}
    , decltype(_impl_.isvariadic_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.loopid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.loopid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_loopid().empty()) {
    _this->_impl_.loopid_.Set(from._internal_loopid(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_body()) {
    _this->_impl_.body_ = new ::clojure::rt::protobuf::bytecode::Node(*from._impl_.body_);
  }
  ::memcpy(&_impl_.fixedarity_, &from._impl_.fixedarity_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.isvariadic_) -
    reinterpret_cast<char*>(&_impl_.fixedarity_)) + sizeof(_impl_.isvariadic_));
  // @@protoc_insertion_point(copy_constructor:clojure.rt.protobuf.bytecode.FnMethodNode)
}

inline void FnMethodNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.params_){arena}
    , decltype(_impl_.loopid_){}
    , decltype(_impl_.body_){nullptr}
    , decltype(_impl_.fixedarity_){0u}
    , decltype(_impl_.isvariadic_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.loopid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.loopid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

FnMethodNode::~FnMethodNode() {
  // @@protoc_insertion_point(destructor:clojure.rt.protobuf.bytecode.FnMethodNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FnMethodNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.params_.~RepeatedPtrField();
  _impl_.loopid_.Destroy();
  if (this != internal_default_instance()) delete _impl_.body_;
}

void FnMethodNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FnMethodNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojure.rt.protobuf.bytecode.FnMethodNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.params_.Clear();
  _impl_.loopid_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.body_ != nullptr) {
    delete _impl_.body_;
  }
  _impl_.body_ = nullptr;
  ::memset(&_impl_.fixedarity_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.isvariadic_) -
      reinterpret_cast<char*>(&_impl_.fixedarity_)) + sizeof(_impl_.isvariadic_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FnMethodNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .clojure.rt.protobuf.bytecode.Node body = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_body(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 fixedArity = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.fixedarity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string loopId = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_loopid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojure.rt.protobuf.bytecode.FnMethodNode.loopId"));
        } else
          goto handle_unusual;
        continue;
      // repeated .clojure.rt.protobuf.bytecode.Node params = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_params(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // bool isVariadic = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.isvariadic_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FnMethodNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojure.rt.protobuf.bytecode.FnMethodNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .clojure.rt.protobuf.bytecode.Node body = 1;
  if (this->_internal_has_body()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::body(this),
        _Internal::body(this).GetCachedSize(), target, stream);
  }

  // uint32 fixedArity = 2;
  if (this->_internal_fixedarity() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_fixedarity(), target);
  }

  // string loopId = 3;
  if (!this->_internal_loopid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_loopid().data(), static_cast<int>(this->_internal_loopid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojure.rt.protobuf.bytecode.FnMethodNode.loopId");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_loopid(), target);
  }

  // repeated .clojure.rt.protobuf.bytecode.Node params = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_params_size()); i < n; i++) {
    const auto& repfield = this->_internal_params(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // bool isVariadic = 5;
  if (this->_internal_isvariadic() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_isvariadic(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojure.rt.protobuf.bytecode.FnMethodNode)
  return target;
}

size_t FnMethodNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojure.rt.protobuf.bytecode.FnMethodNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .clojure.rt.protobuf.bytecode.Node params = 4;
  total_size += 1UL * this->_internal_params_size();
  for (const auto& msg : this->_impl_.params_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string loopId = 3;
  if (!this->_internal_loopid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_loopid());
  }

  // .clojure.rt.protobuf.bytecode.Node body = 1;
  if (this->_internal_has_body()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.body_);
  }

  // uint32 fixedArity = 2;
  if (this->_internal_fixedarity() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_fixedarity());
  }

  // bool isVariadic = 5;
  if (this->_internal_isvariadic() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FnMethodNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FnMethodNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FnMethodNode::GetClassData() const { return &_class_data_; }


void FnMethodNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FnMethodNode*>(&to_msg);
  auto& from = static_cast<const FnMethodNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojure.rt.protobuf.bytecode.FnMethodNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.params_.MergeFrom(from._impl_.params_);
  if (!from._internal_loopid().empty()) {
    _this->_internal_set_loopid(from._internal_loopid());
  }
  if (from._internal_has_body()) {
    _this->_internal_mutable_body()->::clojure::rt::protobuf::bytecode::Node::MergeFrom(
        from._internal_body());
  }
  if (from._internal_fixedarity() != 0) {
    _this->_internal_set_fixedarity(from._internal_fixedarity());
  }
  if (from._internal_isvariadic() != 0) {
    _this->_internal_set_isvariadic(from._internal_isvariadic());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FnMethodNode::CopyFrom(const FnMethodNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojure.rt.protobuf.bytecode.FnMethodNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FnMethodNode::IsInitialized() const {
  return true;
}

void FnMethodNode::InternalSwap(FnMethodNode* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.params_.InternalSwap(&other->_impl_.params_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.loopid_, lhs_arena,
      &other->_impl_.loopid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FnMethodNode, _impl_.isvariadic_)
      + sizeof(FnMethodNode::_impl_.isvariadic_)
      - PROTOBUF_FIELD_OFFSET(FnMethodNode, _impl_.body_)>(
          reinterpret_cast<char*>(&_impl_.body_),
          reinterpret_cast<char*>(&other->_impl_.body_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FnMethodNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[12]);
}

// ===================================================================

class HostInteropNode::_Internal {
 public:
  static const ::clojure::rt::protobuf::bytecode::Node& target(const HostInteropNode* msg);
};

const ::clojure::rt::protobuf::bytecode::Node&
HostInteropNode::_Internal::target(const HostInteropNode* msg) {
  return *msg->_impl_.target_;
}
HostInteropNode::HostInteropNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojure.rt.protobuf.bytecode.HostInteropNode)
}
HostInteropNode::HostInteropNode(const HostInteropNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  HostInteropNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.morf_){}
    , decltype(_impl_.target_){nullptr}
    , decltype(_impl_.isassignable_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.morf_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.morf_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_morf().empty()) {
    _this->_impl_.morf_.Set(from._internal_morf(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_target()) {
    _this->_impl_.target_ = new ::clojure::rt::protobuf::bytecode::Node(*from._impl_.target_);
  }
  _this->_impl_.isassignable_ = from._impl_.isassignable_;
  // @@protoc_insertion_point(copy_constructor:clojure.rt.protobuf.bytecode.HostInteropNode)
}

inline void HostInteropNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.morf_){}
    , decltype(_impl_.target_){nullptr}
    , decltype(_impl_.isassignable_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.morf_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.morf_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

HostInteropNode::~HostInteropNode() {
  // @@protoc_insertion_point(destructor:clojure.rt.protobuf.bytecode.HostInteropNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void HostInteropNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.morf_.Destroy();
  if (this != internal_default_instance()) delete _impl_.target_;
}

void HostInteropNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void HostInteropNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojure.rt.protobuf.bytecode.HostInteropNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.morf_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.target_ != nullptr) {
    delete _impl_.target_;
  }
  _impl_.target_ = nullptr;
  _impl_.isassignable_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* HostInteropNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool isAssignable = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.isassignable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string mOrF = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_morf();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojure.rt.protobuf.bytecode.HostInteropNode.mOrF"));
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.Node target = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_target(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* HostInteropNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojure.rt.protobuf.bytecode.HostInteropNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool isAssignable = 1;
  if (this->_internal_isassignable() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_isassignable(), target);
  }

  // string mOrF = 2;
  if (!this->_internal_morf().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_morf().data(), static_cast<int>(this->_internal_morf().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojure.rt.protobuf.bytecode.HostInteropNode.mOrF");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_morf(), target);
  }

  // .clojure.rt.protobuf.bytecode.Node target = 3;
  if (this->_internal_has_target()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::target(this),
        _Internal::target(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojure.rt.protobuf.bytecode.HostInteropNode)
  return target;
}

size_t HostInteropNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojure.rt.protobuf.bytecode.HostInteropNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string mOrF = 2;
  if (!this->_internal_morf().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_morf());
  }

  // .clojure.rt.protobuf.bytecode.Node target = 3;
  if (this->_internal_has_target()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.target_);
  }

  // bool isAssignable = 1;
  if (this->_internal_isassignable() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData HostInteropNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    HostInteropNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*HostInteropNode::GetClassData() const { return &_class_data_; }


void HostInteropNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<HostInteropNode*>(&to_msg);
  auto& from = static_cast<const HostInteropNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojure.rt.protobuf.bytecode.HostInteropNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_morf().empty()) {
    _this->_internal_set_morf(from._internal_morf());
  }
  if (from._internal_has_target()) {
    _this->_internal_mutable_target()->::clojure::rt::protobuf::bytecode::Node::MergeFrom(
        from._internal_target());
  }
  if (from._internal_isassignable() != 0) {
    _this->_internal_set_isassignable(from._internal_isassignable());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void HostInteropNode::CopyFrom(const HostInteropNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojure.rt.protobuf.bytecode.HostInteropNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HostInteropNode::IsInitialized() const {
  return true;
}

void HostInteropNode::InternalSwap(HostInteropNode* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.morf_, lhs_arena,
      &other->_impl_.morf_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(HostInteropNode, _impl_.isassignable_)
      + sizeof(HostInteropNode::_impl_.isassignable_)
      - PROTOBUF_FIELD_OFFSET(HostInteropNode, _impl_.target_)>(
          reinterpret_cast<char*>(&_impl_.target_),
          reinterpret_cast<char*>(&other->_impl_.target_));
}

::PROTOBUF_NAMESPACE_ID::Metadata HostInteropNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[13]);
}

// ===================================================================

class IfNode::_Internal {
 public:
  static const ::clojure::rt::protobuf::bytecode::Node& else_(const IfNode* msg);
  static const ::clojure::rt::protobuf::bytecode::Node& test(const IfNode* msg);
  static const ::clojure::rt::protobuf::bytecode::Node& then(const IfNode* msg);
};

const ::clojure::rt::protobuf::bytecode::Node&
IfNode::_Internal::else_(const IfNode* msg) {
  return *msg->_impl_.else__;
}
const ::clojure::rt::protobuf::bytecode::Node&
IfNode::_Internal::test(const IfNode* msg) {
  return *msg->_impl_.test_;
}
const ::clojure::rt::protobuf::bytecode::Node&
IfNode::_Internal::then(const IfNode* msg) {
  return *msg->_impl_.then_;
}
IfNode::IfNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojure.rt.protobuf.bytecode.IfNode)
}
IfNode::IfNode(const IfNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  IfNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.else__){nullptr}
    , decltype(_impl_.test_){nullptr}
    , decltype(_impl_.then_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_else_()) {
    _this->_impl_.else__ = new ::clojure::rt::protobuf::bytecode::Node(*from._impl_.else__);
  }
  if (from._internal_has_test()) {
    _this->_impl_.test_ = new ::clojure::rt::protobuf::bytecode::Node(*from._impl_.test_);
  }
  if (from._internal_has_then()) {
    _this->_impl_.then_ = new ::clojure::rt::protobuf::bytecode::Node(*from._impl_.then_);
  }
  // @@protoc_insertion_point(copy_constructor:clojure.rt.protobuf.bytecode.IfNode)
}

inline void IfNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.else__){nullptr}
    , decltype(_impl_.test_){nullptr}
    , decltype(_impl_.then_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

IfNode::~IfNode() {
  // @@protoc_insertion_point(destructor:clojure.rt.protobuf.bytecode.IfNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IfNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.else__;
  if (this != internal_default_instance()) delete _impl_.test_;
  if (this != internal_default_instance()) delete _impl_.then_;
}

void IfNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IfNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojure.rt.protobuf.bytecode.IfNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.else__ != nullptr) {
    delete _impl_.else__;
  }
  _impl_.else__ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.test_ != nullptr) {
    delete _impl_.test_;
  }
  _impl_.test_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.then_ != nullptr) {
    delete _impl_.then_;
  }
  _impl_.then_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IfNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .clojure.rt.protobuf.bytecode.Node else = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_else_(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.Node test = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_test(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.Node then = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_then(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IfNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojure.rt.protobuf.bytecode.IfNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .clojure.rt.protobuf.bytecode.Node else = 1;
  if (this->_internal_has_else_()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::else_(this),
        _Internal::else_(this).GetCachedSize(), target, stream);
  }

  // .clojure.rt.protobuf.bytecode.Node test = 2;
  if (this->_internal_has_test()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::test(this),
        _Internal::test(this).GetCachedSize(), target, stream);
  }

  // .clojure.rt.protobuf.bytecode.Node then = 3;
  if (this->_internal_has_then()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::then(this),
        _Internal::then(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojure.rt.protobuf.bytecode.IfNode)
  return target;
}

size_t IfNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojure.rt.protobuf.bytecode.IfNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .clojure.rt.protobuf.bytecode.Node else = 1;
  if (this->_internal_has_else_()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.else__);
  }

  // .clojure.rt.protobuf.bytecode.Node test = 2;
  if (this->_internal_has_test()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.test_);
  }

  // .clojure.rt.protobuf.bytecode.Node then = 3;
  if (this->_internal_has_then()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.then_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IfNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    IfNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IfNode::GetClassData() const { return &_class_data_; }


void IfNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<IfNode*>(&to_msg);
  auto& from = static_cast<const IfNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojure.rt.protobuf.bytecode.IfNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_else_()) {
    _this->_internal_mutable_else_()->::clojure::rt::protobuf::bytecode::Node::MergeFrom(
        from._internal_else_());
  }
  if (from._internal_has_test()) {
    _this->_internal_mutable_test()->::clojure::rt::protobuf::bytecode::Node::MergeFrom(
        from._internal_test());
  }
  if (from._internal_has_then()) {
    _this->_internal_mutable_then()->::clojure::rt::protobuf::bytecode::Node::MergeFrom(
        from._internal_then());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IfNode::CopyFrom(const IfNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojure.rt.protobuf.bytecode.IfNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IfNode::IsInitialized() const {
  return true;
}

void IfNode::InternalSwap(IfNode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IfNode, _impl_.then_)
      + sizeof(IfNode::_impl_.then_)
      - PROTOBUF_FIELD_OFFSET(IfNode, _impl_.else__)>(
          reinterpret_cast<char*>(&_impl_.else__),
          reinterpret_cast<char*>(&other->_impl_.else__));
}

::PROTOBUF_NAMESPACE_ID::Metadata IfNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[14]);
}

// ===================================================================

class ImportNode::_Internal {
 public:
};

ImportNode::ImportNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojure.rt.protobuf.bytecode.ImportNode)
}
ImportNode::ImportNode(const ImportNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ImportNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.class__){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.class__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.class__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_class_().empty()) {
    _this->_impl_.class__.Set(from._internal_class_(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:clojure.rt.protobuf.bytecode.ImportNode)
}

inline void ImportNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.class__){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.class__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.class__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ImportNode::~ImportNode() {
  // @@protoc_insertion_point(destructor:clojure.rt.protobuf.bytecode.ImportNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ImportNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.class__.Destroy();
}

void ImportNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ImportNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojure.rt.protobuf.bytecode.ImportNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.class__.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ImportNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string class = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_class_();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojure.rt.protobuf.bytecode.ImportNode.class"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ImportNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojure.rt.protobuf.bytecode.ImportNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string class = 1;
  if (!this->_internal_class_().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_class_().data(), static_cast<int>(this->_internal_class_().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojure.rt.protobuf.bytecode.ImportNode.class");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_class_(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojure.rt.protobuf.bytecode.ImportNode)
  return target;
}

size_t ImportNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojure.rt.protobuf.bytecode.ImportNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string class = 1;
  if (!this->_internal_class_().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_class_());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ImportNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ImportNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ImportNode::GetClassData() const { return &_class_data_; }


void ImportNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ImportNode*>(&to_msg);
  auto& from = static_cast<const ImportNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojure.rt.protobuf.bytecode.ImportNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_class_().empty()) {
    _this->_internal_set_class_(from._internal_class_());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ImportNode::CopyFrom(const ImportNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojure.rt.protobuf.bytecode.ImportNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ImportNode::IsInitialized() const {
  return true;
}

void ImportNode::InternalSwap(ImportNode* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.class__, lhs_arena,
      &other->_impl_.class__, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ImportNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[15]);
}

// ===================================================================

class InstanceCallNode::_Internal {
 public:
  static const ::clojure::rt::protobuf::bytecode::Node& instance(const InstanceCallNode* msg);
};

const ::clojure::rt::protobuf::bytecode::Node&
InstanceCallNode::_Internal::instance(const InstanceCallNode* msg) {
  return *msg->_impl_.instance_;
}
InstanceCallNode::InstanceCallNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojure.rt.protobuf.bytecode.InstanceCallNode)
}
InstanceCallNode::InstanceCallNode(const InstanceCallNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  InstanceCallNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.args_){from._impl_.args_}
    , decltype(_impl_.class__){}
    , decltype(_impl_.method_){}
    , decltype(_impl_.instance_){nullptr}
    , decltype(_impl_.isvalidated_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.class__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.class__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_class_().empty()) {
    _this->_impl_.class__.Set(from._internal_class_(), 
      _this->GetArenaForAllocation());
  }
  _impl_.method_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.method_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_method().empty()) {
    _this->_impl_.method_.Set(from._internal_method(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_instance()) {
    _this->_impl_.instance_ = new ::clojure::rt::protobuf::bytecode::Node(*from._impl_.instance_);
  }
  _this->_impl_.isvalidated_ = from._impl_.isvalidated_;
  // @@protoc_insertion_point(copy_constructor:clojure.rt.protobuf.bytecode.InstanceCallNode)
}

inline void InstanceCallNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.args_){arena}
    , decltype(_impl_.class__){}
    , decltype(_impl_.method_){}
    , decltype(_impl_.instance_){nullptr}
    , decltype(_impl_.isvalidated_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.class__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.class__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.method_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.method_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

InstanceCallNode::~InstanceCallNode() {
  // @@protoc_insertion_point(destructor:clojure.rt.protobuf.bytecode.InstanceCallNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InstanceCallNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.args_.~RepeatedPtrField();
  _impl_.class__.Destroy();
  _impl_.method_.Destroy();
  if (this != internal_default_instance()) delete _impl_.instance_;
}

void InstanceCallNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void InstanceCallNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojure.rt.protobuf.bytecode.InstanceCallNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.args_.Clear();
  _impl_.class__.ClearToEmpty();
  _impl_.method_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.instance_ != nullptr) {
    delete _impl_.instance_;
  }
  _impl_.instance_ = nullptr;
  _impl_.isvalidated_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* InstanceCallNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .clojure.rt.protobuf.bytecode.Node args = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_args(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string class = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_class_();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojure.rt.protobuf.bytecode.InstanceCallNode.class"));
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.Node instance = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_instance(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string method = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_method();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojure.rt.protobuf.bytecode.InstanceCallNode.method"));
        } else
          goto handle_unusual;
        continue;
      // bool isValidated = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.isvalidated_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InstanceCallNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojure.rt.protobuf.bytecode.InstanceCallNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .clojure.rt.protobuf.bytecode.Node args = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_args_size()); i < n; i++) {
    const auto& repfield = this->_internal_args(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // string class = 2;
  if (!this->_internal_class_().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_class_().data(), static_cast<int>(this->_internal_class_().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojure.rt.protobuf.bytecode.InstanceCallNode.class");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_class_(), target);
  }

  // .clojure.rt.protobuf.bytecode.Node instance = 3;
  if (this->_internal_has_instance()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::instance(this),
        _Internal::instance(this).GetCachedSize(), target, stream);
  }

  // string method = 4;
  if (!this->_internal_method().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_method().data(), static_cast<int>(this->_internal_method().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojure.rt.protobuf.bytecode.InstanceCallNode.method");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_method(), target);
  }

  // bool isValidated = 5;
  if (this->_internal_isvalidated() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_isvalidated(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojure.rt.protobuf.bytecode.InstanceCallNode)
  return target;
}

size_t InstanceCallNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojure.rt.protobuf.bytecode.InstanceCallNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .clojure.rt.protobuf.bytecode.Node args = 1;
  total_size += 1UL * this->_internal_args_size();
  for (const auto& msg : this->_impl_.args_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string class = 2;
  if (!this->_internal_class_().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_class_());
  }

  // string method = 4;
  if (!this->_internal_method().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_method());
  }

  // .clojure.rt.protobuf.bytecode.Node instance = 3;
  if (this->_internal_has_instance()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.instance_);
  }

  // bool isValidated = 5;
  if (this->_internal_isvalidated() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData InstanceCallNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    InstanceCallNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*InstanceCallNode::GetClassData() const { return &_class_data_; }


void InstanceCallNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<InstanceCallNode*>(&to_msg);
  auto& from = static_cast<const InstanceCallNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojure.rt.protobuf.bytecode.InstanceCallNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.args_.MergeFrom(from._impl_.args_);
  if (!from._internal_class_().empty()) {
    _this->_internal_set_class_(from._internal_class_());
  }
  if (!from._internal_method().empty()) {
    _this->_internal_set_method(from._internal_method());
  }
  if (from._internal_has_instance()) {
    _this->_internal_mutable_instance()->::clojure::rt::protobuf::bytecode::Node::MergeFrom(
        from._internal_instance());
  }
  if (from._internal_isvalidated() != 0) {
    _this->_internal_set_isvalidated(from._internal_isvalidated());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void InstanceCallNode::CopyFrom(const InstanceCallNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojure.rt.protobuf.bytecode.InstanceCallNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InstanceCallNode::IsInitialized() const {
  return true;
}

void InstanceCallNode::InternalSwap(InstanceCallNode* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.args_.InternalSwap(&other->_impl_.args_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.class__, lhs_arena,
      &other->_impl_.class__, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.method_, lhs_arena,
      &other->_impl_.method_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(InstanceCallNode, _impl_.isvalidated_)
      + sizeof(InstanceCallNode::_impl_.isvalidated_)
      - PROTOBUF_FIELD_OFFSET(InstanceCallNode, _impl_.instance_)>(
          reinterpret_cast<char*>(&_impl_.instance_),
          reinterpret_cast<char*>(&other->_impl_.instance_));
}

::PROTOBUF_NAMESPACE_ID::Metadata InstanceCallNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[16]);
}

// ===================================================================

class InstanceFieldNode::_Internal {
 public:
  static const ::clojure::rt::protobuf::bytecode::Node& instance(const InstanceFieldNode* msg);
};

const ::clojure::rt::protobuf::bytecode::Node&
InstanceFieldNode::_Internal::instance(const InstanceFieldNode* msg) {
  return *msg->_impl_.instance_;
}
InstanceFieldNode::InstanceFieldNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojure.rt.protobuf.bytecode.InstanceFieldNode)
}
InstanceFieldNode::InstanceFieldNode(const InstanceFieldNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  InstanceFieldNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.class__){}
    , decltype(_impl_.field_){}
    , decltype(_impl_.instance_){nullptr}
    , decltype(_impl_.isassignable_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.class__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.class__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_class_().empty()) {
    _this->_impl_.class__.Set(from._internal_class_(), 
      _this->GetArenaForAllocation());
  }
  _impl_.field_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.field_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_field().empty()) {
    _this->_impl_.field_.Set(from._internal_field(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_instance()) {
    _this->_impl_.instance_ = new ::clojure::rt::protobuf::bytecode::Node(*from._impl_.instance_);
  }
  _this->_impl_.isassignable_ = from._impl_.isassignable_;
  // @@protoc_insertion_point(copy_constructor:clojure.rt.protobuf.bytecode.InstanceFieldNode)
}

inline void InstanceFieldNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.class__){}
    , decltype(_impl_.field_){}
    , decltype(_impl_.instance_){nullptr}
    , decltype(_impl_.isassignable_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.class__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.class__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.field_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.field_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

InstanceFieldNode::~InstanceFieldNode() {
  // @@protoc_insertion_point(destructor:clojure.rt.protobuf.bytecode.InstanceFieldNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InstanceFieldNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.class__.Destroy();
  _impl_.field_.Destroy();
  if (this != internal_default_instance()) delete _impl_.instance_;
}

void InstanceFieldNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void InstanceFieldNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojure.rt.protobuf.bytecode.InstanceFieldNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.class__.ClearToEmpty();
  _impl_.field_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.instance_ != nullptr) {
    delete _impl_.instance_;
  }
  _impl_.instance_ = nullptr;
  _impl_.isassignable_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* InstanceFieldNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool isAssignable = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.isassignable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string class = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_class_();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojure.rt.protobuf.bytecode.InstanceFieldNode.class"));
        } else
          goto handle_unusual;
        continue;
      // string field = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_field();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojure.rt.protobuf.bytecode.InstanceFieldNode.field"));
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.Node instance = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_instance(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InstanceFieldNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojure.rt.protobuf.bytecode.InstanceFieldNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool isAssignable = 1;
  if (this->_internal_isassignable() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_isassignable(), target);
  }

  // string class = 2;
  if (!this->_internal_class_().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_class_().data(), static_cast<int>(this->_internal_class_().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojure.rt.protobuf.bytecode.InstanceFieldNode.class");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_class_(), target);
  }

  // string field = 3;
  if (!this->_internal_field().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_field().data(), static_cast<int>(this->_internal_field().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojure.rt.protobuf.bytecode.InstanceFieldNode.field");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_field(), target);
  }

  // .clojure.rt.protobuf.bytecode.Node instance = 4;
  if (this->_internal_has_instance()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::instance(this),
        _Internal::instance(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojure.rt.protobuf.bytecode.InstanceFieldNode)
  return target;
}

size_t InstanceFieldNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojure.rt.protobuf.bytecode.InstanceFieldNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string class = 2;
  if (!this->_internal_class_().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_class_());
  }

  // string field = 3;
  if (!this->_internal_field().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_field());
  }

  // .clojure.rt.protobuf.bytecode.Node instance = 4;
  if (this->_internal_has_instance()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.instance_);
  }

  // bool isAssignable = 1;
  if (this->_internal_isassignable() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData InstanceFieldNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    InstanceFieldNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*InstanceFieldNode::GetClassData() const { return &_class_data_; }


void InstanceFieldNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<InstanceFieldNode*>(&to_msg);
  auto& from = static_cast<const InstanceFieldNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojure.rt.protobuf.bytecode.InstanceFieldNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_class_().empty()) {
    _this->_internal_set_class_(from._internal_class_());
  }
  if (!from._internal_field().empty()) {
    _this->_internal_set_field(from._internal_field());
  }
  if (from._internal_has_instance()) {
    _this->_internal_mutable_instance()->::clojure::rt::protobuf::bytecode::Node::MergeFrom(
        from._internal_instance());
  }
  if (from._internal_isassignable() != 0) {
    _this->_internal_set_isassignable(from._internal_isassignable());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void InstanceFieldNode::CopyFrom(const InstanceFieldNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojure.rt.protobuf.bytecode.InstanceFieldNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InstanceFieldNode::IsInitialized() const {
  return true;
}

void InstanceFieldNode::InternalSwap(InstanceFieldNode* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.class__, lhs_arena,
      &other->_impl_.class__, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.field_, lhs_arena,
      &other->_impl_.field_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(InstanceFieldNode, _impl_.isassignable_)
      + sizeof(InstanceFieldNode::_impl_.isassignable_)
      - PROTOBUF_FIELD_OFFSET(InstanceFieldNode, _impl_.instance_)>(
          reinterpret_cast<char*>(&_impl_.instance_),
          reinterpret_cast<char*>(&other->_impl_.instance_));
}

::PROTOBUF_NAMESPACE_ID::Metadata InstanceFieldNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[17]);
}

// ===================================================================

class IsInstanceNode::_Internal {
 public:
  static const ::clojure::rt::protobuf::bytecode::Node& target(const IsInstanceNode* msg);
};

const ::clojure::rt::protobuf::bytecode::Node&
IsInstanceNode::_Internal::target(const IsInstanceNode* msg) {
  return *msg->_impl_.target_;
}
IsInstanceNode::IsInstanceNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojure.rt.protobuf.bytecode.IsInstanceNode)
}
IsInstanceNode::IsInstanceNode(const IsInstanceNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  IsInstanceNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.class__){}
    , decltype(_impl_.target_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.class__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.class__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_class_().empty()) {
    _this->_impl_.class__.Set(from._internal_class_(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_target()) {
    _this->_impl_.target_ = new ::clojure::rt::protobuf::bytecode::Node(*from._impl_.target_);
  }
  // @@protoc_insertion_point(copy_constructor:clojure.rt.protobuf.bytecode.IsInstanceNode)
}

inline void IsInstanceNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.class__){}
    , decltype(_impl_.target_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.class__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.class__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

IsInstanceNode::~IsInstanceNode() {
  // @@protoc_insertion_point(destructor:clojure.rt.protobuf.bytecode.IsInstanceNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IsInstanceNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.class__.Destroy();
  if (this != internal_default_instance()) delete _impl_.target_;
}

void IsInstanceNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IsInstanceNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojure.rt.protobuf.bytecode.IsInstanceNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.class__.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.target_ != nullptr) {
    delete _impl_.target_;
  }
  _impl_.target_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IsInstanceNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string class = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_class_();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojure.rt.protobuf.bytecode.IsInstanceNode.class"));
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.Node target = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_target(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IsInstanceNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojure.rt.protobuf.bytecode.IsInstanceNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string class = 1;
  if (!this->_internal_class_().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_class_().data(), static_cast<int>(this->_internal_class_().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojure.rt.protobuf.bytecode.IsInstanceNode.class");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_class_(), target);
  }

  // .clojure.rt.protobuf.bytecode.Node target = 2;
  if (this->_internal_has_target()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::target(this),
        _Internal::target(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojure.rt.protobuf.bytecode.IsInstanceNode)
  return target;
}

size_t IsInstanceNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojure.rt.protobuf.bytecode.IsInstanceNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string class = 1;
  if (!this->_internal_class_().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_class_());
  }

  // .clojure.rt.protobuf.bytecode.Node target = 2;
  if (this->_internal_has_target()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.target_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IsInstanceNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    IsInstanceNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IsInstanceNode::GetClassData() const { return &_class_data_; }


void IsInstanceNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<IsInstanceNode*>(&to_msg);
  auto& from = static_cast<const IsInstanceNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojure.rt.protobuf.bytecode.IsInstanceNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_class_().empty()) {
    _this->_internal_set_class_(from._internal_class_());
  }
  if (from._internal_has_target()) {
    _this->_internal_mutable_target()->::clojure::rt::protobuf::bytecode::Node::MergeFrom(
        from._internal_target());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IsInstanceNode::CopyFrom(const IsInstanceNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojure.rt.protobuf.bytecode.IsInstanceNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IsInstanceNode::IsInitialized() const {
  return true;
}

void IsInstanceNode::InternalSwap(IsInstanceNode* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.class__, lhs_arena,
      &other->_impl_.class__, rhs_arena
  );
  swap(_impl_.target_, other->_impl_.target_);
}

::PROTOBUF_NAMESPACE_ID::Metadata IsInstanceNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[18]);
}

// ===================================================================

class InvokeNode::_Internal {
 public:
  static const ::clojure::rt::protobuf::bytecode::Node& fn(const InvokeNode* msg);
};

const ::clojure::rt::protobuf::bytecode::Node&
InvokeNode::_Internal::fn(const InvokeNode* msg) {
  return *msg->_impl_.fn_;
}
InvokeNode::InvokeNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojure.rt.protobuf.bytecode.InvokeNode)
}
InvokeNode::InvokeNode(const InvokeNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  InvokeNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.args_){from._impl_.args_}
    , decltype(_impl_.meta_){}
    , decltype(_impl_.fn_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.meta_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.meta_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_meta().empty()) {
    _this->_impl_.meta_.Set(from._internal_meta(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_fn()) {
    _this->_impl_.fn_ = new ::clojure::rt::protobuf::bytecode::Node(*from._impl_.fn_);
  }
  // @@protoc_insertion_point(copy_constructor:clojure.rt.protobuf.bytecode.InvokeNode)
}

inline void InvokeNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.args_){arena}
    , decltype(_impl_.meta_){}
    , decltype(_impl_.fn_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.meta_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.meta_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

InvokeNode::~InvokeNode() {
  // @@protoc_insertion_point(destructor:clojure.rt.protobuf.bytecode.InvokeNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InvokeNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.args_.~RepeatedPtrField();
  _impl_.meta_.Destroy();
  if (this != internal_default_instance()) delete _impl_.fn_;
}

void InvokeNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void InvokeNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojure.rt.protobuf.bytecode.InvokeNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.args_.Clear();
  _impl_.meta_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.fn_ != nullptr) {
    delete _impl_.fn_;
  }
  _impl_.fn_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* InvokeNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .clojure.rt.protobuf.bytecode.Node args = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_args(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.Node fn = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_fn(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string meta = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_meta();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojure.rt.protobuf.bytecode.InvokeNode.meta"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InvokeNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojure.rt.protobuf.bytecode.InvokeNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .clojure.rt.protobuf.bytecode.Node args = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_args_size()); i < n; i++) {
    const auto& repfield = this->_internal_args(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .clojure.rt.protobuf.bytecode.Node fn = 2;
  if (this->_internal_has_fn()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::fn(this),
        _Internal::fn(this).GetCachedSize(), target, stream);
  }

  // string meta = 3;
  if (!this->_internal_meta().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_meta().data(), static_cast<int>(this->_internal_meta().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojure.rt.protobuf.bytecode.InvokeNode.meta");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_meta(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojure.rt.protobuf.bytecode.InvokeNode)
  return target;
}

size_t InvokeNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojure.rt.protobuf.bytecode.InvokeNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .clojure.rt.protobuf.bytecode.Node args = 1;
  total_size += 1UL * this->_internal_args_size();
  for (const auto& msg : this->_impl_.args_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string meta = 3;
  if (!this->_internal_meta().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_meta());
  }

  // .clojure.rt.protobuf.bytecode.Node fn = 2;
  if (this->_internal_has_fn()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.fn_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData InvokeNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    InvokeNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*InvokeNode::GetClassData() const { return &_class_data_; }


void InvokeNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<InvokeNode*>(&to_msg);
  auto& from = static_cast<const InvokeNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojure.rt.protobuf.bytecode.InvokeNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.args_.MergeFrom(from._impl_.args_);
  if (!from._internal_meta().empty()) {
    _this->_internal_set_meta(from._internal_meta());
  }
  if (from._internal_has_fn()) {
    _this->_internal_mutable_fn()->::clojure::rt::protobuf::bytecode::Node::MergeFrom(
        from._internal_fn());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void InvokeNode::CopyFrom(const InvokeNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojure.rt.protobuf.bytecode.InvokeNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InvokeNode::IsInitialized() const {
  return true;
}

void InvokeNode::InternalSwap(InvokeNode* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.args_.InternalSwap(&other->_impl_.args_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.meta_, lhs_arena,
      &other->_impl_.meta_, rhs_arena
  );
  swap(_impl_.fn_, other->_impl_.fn_);
}

::PROTOBUF_NAMESPACE_ID::Metadata InvokeNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[19]);
}

// ===================================================================

class KeywordInvokeNode::_Internal {
 public:
  static const ::clojure::rt::protobuf::bytecode::Node& keyword(const KeywordInvokeNode* msg);
  static const ::clojure::rt::protobuf::bytecode::Node& target(const KeywordInvokeNode* msg);
};

const ::clojure::rt::protobuf::bytecode::Node&
KeywordInvokeNode::_Internal::keyword(const KeywordInvokeNode* msg) {
  return *msg->_impl_.keyword_;
}
const ::clojure::rt::protobuf::bytecode::Node&
KeywordInvokeNode::_Internal::target(const KeywordInvokeNode* msg) {
  return *msg->_impl_.target_;
}
KeywordInvokeNode::KeywordInvokeNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojure.rt.protobuf.bytecode.KeywordInvokeNode)
}
KeywordInvokeNode::KeywordInvokeNode(const KeywordInvokeNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  KeywordInvokeNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.keyword_){nullptr}
    , decltype(_impl_.target_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_keyword()) {
    _this->_impl_.keyword_ = new ::clojure::rt::protobuf::bytecode::Node(*from._impl_.keyword_);
  }
  if (from._internal_has_target()) {
    _this->_impl_.target_ = new ::clojure::rt::protobuf::bytecode::Node(*from._impl_.target_);
  }
  // @@protoc_insertion_point(copy_constructor:clojure.rt.protobuf.bytecode.KeywordInvokeNode)
}

inline void KeywordInvokeNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.keyword_){nullptr}
    , decltype(_impl_.target_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

KeywordInvokeNode::~KeywordInvokeNode() {
  // @@protoc_insertion_point(destructor:clojure.rt.protobuf.bytecode.KeywordInvokeNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KeywordInvokeNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.keyword_;
  if (this != internal_default_instance()) delete _impl_.target_;
}

void KeywordInvokeNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KeywordInvokeNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojure.rt.protobuf.bytecode.KeywordInvokeNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.keyword_ != nullptr) {
    delete _impl_.keyword_;
  }
  _impl_.keyword_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.target_ != nullptr) {
    delete _impl_.target_;
  }
  _impl_.target_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KeywordInvokeNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .clojure.rt.protobuf.bytecode.Node keyword = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_keyword(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.Node target = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_target(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KeywordInvokeNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojure.rt.protobuf.bytecode.KeywordInvokeNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .clojure.rt.protobuf.bytecode.Node keyword = 1;
  if (this->_internal_has_keyword()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::keyword(this),
        _Internal::keyword(this).GetCachedSize(), target, stream);
  }

  // .clojure.rt.protobuf.bytecode.Node target = 2;
  if (this->_internal_has_target()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::target(this),
        _Internal::target(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojure.rt.protobuf.bytecode.KeywordInvokeNode)
  return target;
}

size_t KeywordInvokeNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojure.rt.protobuf.bytecode.KeywordInvokeNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .clojure.rt.protobuf.bytecode.Node keyword = 1;
  if (this->_internal_has_keyword()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.keyword_);
  }

  // .clojure.rt.protobuf.bytecode.Node target = 2;
  if (this->_internal_has_target()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.target_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KeywordInvokeNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    KeywordInvokeNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KeywordInvokeNode::GetClassData() const { return &_class_data_; }


void KeywordInvokeNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<KeywordInvokeNode*>(&to_msg);
  auto& from = static_cast<const KeywordInvokeNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojure.rt.protobuf.bytecode.KeywordInvokeNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_keyword()) {
    _this->_internal_mutable_keyword()->::clojure::rt::protobuf::bytecode::Node::MergeFrom(
        from._internal_keyword());
  }
  if (from._internal_has_target()) {
    _this->_internal_mutable_target()->::clojure::rt::protobuf::bytecode::Node::MergeFrom(
        from._internal_target());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KeywordInvokeNode::CopyFrom(const KeywordInvokeNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojure.rt.protobuf.bytecode.KeywordInvokeNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KeywordInvokeNode::IsInitialized() const {
  return true;
}

void KeywordInvokeNode::InternalSwap(KeywordInvokeNode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KeywordInvokeNode, _impl_.target_)
      + sizeof(KeywordInvokeNode::_impl_.target_)
      - PROTOBUF_FIELD_OFFSET(KeywordInvokeNode, _impl_.keyword_)>(
          reinterpret_cast<char*>(&_impl_.keyword_),
          reinterpret_cast<char*>(&other->_impl_.keyword_));
}

::PROTOBUF_NAMESPACE_ID::Metadata KeywordInvokeNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[20]);
}

// ===================================================================

class LetNode::_Internal {
 public:
  static const ::clojure::rt::protobuf::bytecode::Node& body(const LetNode* msg);
};

const ::clojure::rt::protobuf::bytecode::Node&
LetNode::_Internal::body(const LetNode* msg) {
  return *msg->_impl_.body_;
}
LetNode::LetNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojure.rt.protobuf.bytecode.LetNode)
}
LetNode::LetNode(const LetNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LetNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.bindings_){from._impl_.bindings_}
    , decltype(_impl_.body_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_body()) {
    _this->_impl_.body_ = new ::clojure::rt::protobuf::bytecode::Node(*from._impl_.body_);
  }
  // @@protoc_insertion_point(copy_constructor:clojure.rt.protobuf.bytecode.LetNode)
}

inline void LetNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.bindings_){arena}
    , decltype(_impl_.body_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

LetNode::~LetNode() {
  // @@protoc_insertion_point(destructor:clojure.rt.protobuf.bytecode.LetNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LetNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.bindings_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.body_;
}

void LetNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LetNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojure.rt.protobuf.bytecode.LetNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.bindings_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.body_ != nullptr) {
    delete _impl_.body_;
  }
  _impl_.body_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LetNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .clojure.rt.protobuf.bytecode.Node bindings = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_bindings(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.Node body = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_body(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LetNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojure.rt.protobuf.bytecode.LetNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .clojure.rt.protobuf.bytecode.Node bindings = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_bindings_size()); i < n; i++) {
    const auto& repfield = this->_internal_bindings(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .clojure.rt.protobuf.bytecode.Node body = 2;
  if (this->_internal_has_body()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::body(this),
        _Internal::body(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojure.rt.protobuf.bytecode.LetNode)
  return target;
}

size_t LetNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojure.rt.protobuf.bytecode.LetNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .clojure.rt.protobuf.bytecode.Node bindings = 1;
  total_size += 1UL * this->_internal_bindings_size();
  for (const auto& msg : this->_impl_.bindings_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .clojure.rt.protobuf.bytecode.Node body = 2;
  if (this->_internal_has_body()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.body_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LetNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LetNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LetNode::GetClassData() const { return &_class_data_; }


void LetNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LetNode*>(&to_msg);
  auto& from = static_cast<const LetNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojure.rt.protobuf.bytecode.LetNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.bindings_.MergeFrom(from._impl_.bindings_);
  if (from._internal_has_body()) {
    _this->_internal_mutable_body()->::clojure::rt::protobuf::bytecode::Node::MergeFrom(
        from._internal_body());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LetNode::CopyFrom(const LetNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojure.rt.protobuf.bytecode.LetNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LetNode::IsInitialized() const {
  return true;
}

void LetNode::InternalSwap(LetNode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.bindings_.InternalSwap(&other->_impl_.bindings_);
  swap(_impl_.body_, other->_impl_.body_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LetNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[21]);
}

// ===================================================================

class LetfnNode::_Internal {
 public:
  static const ::clojure::rt::protobuf::bytecode::Node& body(const LetfnNode* msg);
};

const ::clojure::rt::protobuf::bytecode::Node&
LetfnNode::_Internal::body(const LetfnNode* msg) {
  return *msg->_impl_.body_;
}
LetfnNode::LetfnNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojure.rt.protobuf.bytecode.LetfnNode)
}
LetfnNode::LetfnNode(const LetfnNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LetfnNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.bindings_){from._impl_.bindings_}
    , decltype(_impl_.body_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_body()) {
    _this->_impl_.body_ = new ::clojure::rt::protobuf::bytecode::Node(*from._impl_.body_);
  }
  // @@protoc_insertion_point(copy_constructor:clojure.rt.protobuf.bytecode.LetfnNode)
}

inline void LetfnNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.bindings_){arena}
    , decltype(_impl_.body_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

LetfnNode::~LetfnNode() {
  // @@protoc_insertion_point(destructor:clojure.rt.protobuf.bytecode.LetfnNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LetfnNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.bindings_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.body_;
}

void LetfnNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LetfnNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojure.rt.protobuf.bytecode.LetfnNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.bindings_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.body_ != nullptr) {
    delete _impl_.body_;
  }
  _impl_.body_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LetfnNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .clojure.rt.protobuf.bytecode.Node bindings = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_bindings(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.Node body = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_body(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LetfnNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojure.rt.protobuf.bytecode.LetfnNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .clojure.rt.protobuf.bytecode.Node bindings = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_bindings_size()); i < n; i++) {
    const auto& repfield = this->_internal_bindings(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .clojure.rt.protobuf.bytecode.Node body = 2;
  if (this->_internal_has_body()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::body(this),
        _Internal::body(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojure.rt.protobuf.bytecode.LetfnNode)
  return target;
}

size_t LetfnNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojure.rt.protobuf.bytecode.LetfnNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .clojure.rt.protobuf.bytecode.Node bindings = 1;
  total_size += 1UL * this->_internal_bindings_size();
  for (const auto& msg : this->_impl_.bindings_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .clojure.rt.protobuf.bytecode.Node body = 2;
  if (this->_internal_has_body()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.body_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LetfnNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LetfnNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LetfnNode::GetClassData() const { return &_class_data_; }


void LetfnNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LetfnNode*>(&to_msg);
  auto& from = static_cast<const LetfnNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojure.rt.protobuf.bytecode.LetfnNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.bindings_.MergeFrom(from._impl_.bindings_);
  if (from._internal_has_body()) {
    _this->_internal_mutable_body()->::clojure::rt::protobuf::bytecode::Node::MergeFrom(
        from._internal_body());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LetfnNode::CopyFrom(const LetfnNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojure.rt.protobuf.bytecode.LetfnNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LetfnNode::IsInitialized() const {
  return true;
}

void LetfnNode::InternalSwap(LetfnNode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.bindings_.InternalSwap(&other->_impl_.bindings_);
  swap(_impl_.body_, other->_impl_.body_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LetfnNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[22]);
}

// ===================================================================

class LocalNode::_Internal {
 public:
};

LocalNode::LocalNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojure.rt.protobuf.bytecode.LocalNode)
}
LocalNode::LocalNode(const LocalNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LocalNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.argid_){}
    , decltype(_impl_.local_){}
    , decltype(_impl_.isassignable_){}
    , decltype(_impl_.isvariadic_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.argid_, &from._impl_.argid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.isvariadic_) -
    reinterpret_cast<char*>(&_impl_.argid_)) + sizeof(_impl_.isvariadic_));
  // @@protoc_insertion_point(copy_constructor:clojure.rt.protobuf.bytecode.LocalNode)
}

inline void LocalNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.argid_){0u}
    , decltype(_impl_.local_){0}
    , decltype(_impl_.isassignable_){false}
    , decltype(_impl_.isvariadic_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LocalNode::~LocalNode() {
  // @@protoc_insertion_point(destructor:clojure.rt.protobuf.bytecode.LocalNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LocalNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void LocalNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LocalNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojure.rt.protobuf.bytecode.LocalNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  ::memset(&_impl_.argid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.isvariadic_) -
      reinterpret_cast<char*>(&_impl_.argid_)) + sizeof(_impl_.isvariadic_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LocalNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 argId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.argid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool isAssignable = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.isassignable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.LocalType local = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_local(static_cast<::clojure::rt::protobuf::bytecode::LocalType>(val));
        } else
          goto handle_unusual;
        continue;
      // string name = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojure.rt.protobuf.bytecode.LocalNode.name"));
        } else
          goto handle_unusual;
        continue;
      // bool isVariadic = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.isvariadic_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LocalNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojure.rt.protobuf.bytecode.LocalNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 argId = 1;
  if (this->_internal_argid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_argid(), target);
  }

  // bool isAssignable = 2;
  if (this->_internal_isassignable() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_isassignable(), target);
  }

  // .clojure.rt.protobuf.bytecode.LocalType local = 3;
  if (this->_internal_local() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_local(), target);
  }

  // string name = 4;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojure.rt.protobuf.bytecode.LocalNode.name");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_name(), target);
  }

  // bool isVariadic = 5;
  if (this->_internal_isvariadic() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_isvariadic(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojure.rt.protobuf.bytecode.LocalNode)
  return target;
}

size_t LocalNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojure.rt.protobuf.bytecode.LocalNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 4;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // uint32 argId = 1;
  if (this->_internal_argid() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_argid());
  }

  // .clojure.rt.protobuf.bytecode.LocalType local = 3;
  if (this->_internal_local() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_local());
  }

  // bool isAssignable = 2;
  if (this->_internal_isassignable() != 0) {
    total_size += 1 + 1;
  }

  // bool isVariadic = 5;
  if (this->_internal_isvariadic() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LocalNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LocalNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LocalNode::GetClassData() const { return &_class_data_; }


void LocalNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LocalNode*>(&to_msg);
  auto& from = static_cast<const LocalNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojure.rt.protobuf.bytecode.LocalNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_argid() != 0) {
    _this->_internal_set_argid(from._internal_argid());
  }
  if (from._internal_local() != 0) {
    _this->_internal_set_local(from._internal_local());
  }
  if (from._internal_isassignable() != 0) {
    _this->_internal_set_isassignable(from._internal_isassignable());
  }
  if (from._internal_isvariadic() != 0) {
    _this->_internal_set_isvariadic(from._internal_isvariadic());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LocalNode::CopyFrom(const LocalNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojure.rt.protobuf.bytecode.LocalNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LocalNode::IsInitialized() const {
  return true;
}

void LocalNode::InternalSwap(LocalNode* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LocalNode, _impl_.isvariadic_)
      + sizeof(LocalNode::_impl_.isvariadic_)
      - PROTOBUF_FIELD_OFFSET(LocalNode, _impl_.argid_)>(
          reinterpret_cast<char*>(&_impl_.argid_),
          reinterpret_cast<char*>(&other->_impl_.argid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LocalNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[23]);
}

// ===================================================================

class LoopNode::_Internal {
 public:
  static const ::clojure::rt::protobuf::bytecode::Node& body(const LoopNode* msg);
};

const ::clojure::rt::protobuf::bytecode::Node&
LoopNode::_Internal::body(const LoopNode* msg) {
  return *msg->_impl_.body_;
}
LoopNode::LoopNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojure.rt.protobuf.bytecode.LoopNode)
}
LoopNode::LoopNode(const LoopNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LoopNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.bindings_){from._impl_.bindings_}
    , decltype(_impl_.loopid_){}
    , decltype(_impl_.body_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.loopid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.loopid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_loopid().empty()) {
    _this->_impl_.loopid_.Set(from._internal_loopid(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_body()) {
    _this->_impl_.body_ = new ::clojure::rt::protobuf::bytecode::Node(*from._impl_.body_);
  }
  // @@protoc_insertion_point(copy_constructor:clojure.rt.protobuf.bytecode.LoopNode)
}

inline void LoopNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.bindings_){arena}
    , decltype(_impl_.loopid_){}
    , decltype(_impl_.body_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.loopid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.loopid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LoopNode::~LoopNode() {
  // @@protoc_insertion_point(destructor:clojure.rt.protobuf.bytecode.LoopNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LoopNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.bindings_.~RepeatedPtrField();
  _impl_.loopid_.Destroy();
  if (this != internal_default_instance()) delete _impl_.body_;
}

void LoopNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LoopNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojure.rt.protobuf.bytecode.LoopNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.bindings_.Clear();
  _impl_.loopid_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.body_ != nullptr) {
    delete _impl_.body_;
  }
  _impl_.body_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LoopNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .clojure.rt.protobuf.bytecode.Node bindings = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_bindings(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.Node body = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_body(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string loopId = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_loopid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojure.rt.protobuf.bytecode.LoopNode.loopId"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LoopNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojure.rt.protobuf.bytecode.LoopNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .clojure.rt.protobuf.bytecode.Node bindings = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_bindings_size()); i < n; i++) {
    const auto& repfield = this->_internal_bindings(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .clojure.rt.protobuf.bytecode.Node body = 2;
  if (this->_internal_has_body()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::body(this),
        _Internal::body(this).GetCachedSize(), target, stream);
  }

  // string loopId = 3;
  if (!this->_internal_loopid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_loopid().data(), static_cast<int>(this->_internal_loopid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojure.rt.protobuf.bytecode.LoopNode.loopId");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_loopid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojure.rt.protobuf.bytecode.LoopNode)
  return target;
}

size_t LoopNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojure.rt.protobuf.bytecode.LoopNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .clojure.rt.protobuf.bytecode.Node bindings = 1;
  total_size += 1UL * this->_internal_bindings_size();
  for (const auto& msg : this->_impl_.bindings_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string loopId = 3;
  if (!this->_internal_loopid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_loopid());
  }

  // .clojure.rt.protobuf.bytecode.Node body = 2;
  if (this->_internal_has_body()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.body_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LoopNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LoopNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LoopNode::GetClassData() const { return &_class_data_; }


void LoopNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LoopNode*>(&to_msg);
  auto& from = static_cast<const LoopNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojure.rt.protobuf.bytecode.LoopNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.bindings_.MergeFrom(from._impl_.bindings_);
  if (!from._internal_loopid().empty()) {
    _this->_internal_set_loopid(from._internal_loopid());
  }
  if (from._internal_has_body()) {
    _this->_internal_mutable_body()->::clojure::rt::protobuf::bytecode::Node::MergeFrom(
        from._internal_body());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LoopNode::CopyFrom(const LoopNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojure.rt.protobuf.bytecode.LoopNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoopNode::IsInitialized() const {
  return true;
}

void LoopNode::InternalSwap(LoopNode* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.bindings_.InternalSwap(&other->_impl_.bindings_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.loopid_, lhs_arena,
      &other->_impl_.loopid_, rhs_arena
  );
  swap(_impl_.body_, other->_impl_.body_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LoopNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[24]);
}

// ===================================================================

class MapNode::_Internal {
 public:
};

MapNode::MapNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojure.rt.protobuf.bytecode.MapNode)
}
MapNode::MapNode(const MapNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MapNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.keys_){from._impl_.keys_}
    , decltype(_impl_.vals_){from._impl_.vals_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:clojure.rt.protobuf.bytecode.MapNode)
}

inline void MapNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.keys_){arena}
    , decltype(_impl_.vals_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

MapNode::~MapNode() {
  // @@protoc_insertion_point(destructor:clojure.rt.protobuf.bytecode.MapNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MapNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.keys_.~RepeatedPtrField();
  _impl_.vals_.~RepeatedPtrField();
}

void MapNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MapNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojure.rt.protobuf.bytecode.MapNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.keys_.Clear();
  _impl_.vals_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MapNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .clojure.rt.protobuf.bytecode.Node keys = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_keys(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .clojure.rt.protobuf.bytecode.Node vals = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_vals(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MapNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojure.rt.protobuf.bytecode.MapNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .clojure.rt.protobuf.bytecode.Node keys = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_keys_size()); i < n; i++) {
    const auto& repfield = this->_internal_keys(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .clojure.rt.protobuf.bytecode.Node vals = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_vals_size()); i < n; i++) {
    const auto& repfield = this->_internal_vals(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojure.rt.protobuf.bytecode.MapNode)
  return target;
}

size_t MapNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojure.rt.protobuf.bytecode.MapNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .clojure.rt.protobuf.bytecode.Node keys = 1;
  total_size += 1UL * this->_internal_keys_size();
  for (const auto& msg : this->_impl_.keys_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .clojure.rt.protobuf.bytecode.Node vals = 2;
  total_size += 1UL * this->_internal_vals_size();
  for (const auto& msg : this->_impl_.vals_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MapNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MapNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MapNode::GetClassData() const { return &_class_data_; }


void MapNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MapNode*>(&to_msg);
  auto& from = static_cast<const MapNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojure.rt.protobuf.bytecode.MapNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.keys_.MergeFrom(from._impl_.keys_);
  _this->_impl_.vals_.MergeFrom(from._impl_.vals_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MapNode::CopyFrom(const MapNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojure.rt.protobuf.bytecode.MapNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MapNode::IsInitialized() const {
  return true;
}

void MapNode::InternalSwap(MapNode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.keys_.InternalSwap(&other->_impl_.keys_);
  _impl_.vals_.InternalSwap(&other->_impl_.vals_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MapNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[25]);
}

// ===================================================================

class MethodNode::_Internal {
 public:
  static const ::clojure::rt::protobuf::bytecode::Node& body(const MethodNode* msg);
  static const ::clojure::rt::protobuf::bytecode::Node& this_(const MethodNode* msg);
};

const ::clojure::rt::protobuf::bytecode::Node&
MethodNode::_Internal::body(const MethodNode* msg) {
  return *msg->_impl_.body_;
}
const ::clojure::rt::protobuf::bytecode::Node&
MethodNode::_Internal::this_(const MethodNode* msg) {
  return *msg->_impl_.this__;
}
MethodNode::MethodNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojure.rt.protobuf.bytecode.MethodNode)
}
MethodNode::MethodNode(const MethodNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MethodNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.bridges_){from._impl_.bridges_}
    , decltype(_impl_.params_){from._impl_.params_}
    , decltype(_impl_.interface_){}
    , decltype(_impl_.loopid_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.body_){nullptr}
    , decltype(_impl_.this__){nullptr}
    , decltype(_impl_.fixedarity_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.interface_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.interface_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_interface().empty()) {
    _this->_impl_.interface_.Set(from._internal_interface(), 
      _this->GetArenaForAllocation());
  }
  _impl_.loopid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.loopid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_loopid().empty()) {
    _this->_impl_.loopid_.Set(from._internal_loopid(), 
      _this->GetArenaForAllocation());
  }
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_body()) {
    _this->_impl_.body_ = new ::clojure::rt::protobuf::bytecode::Node(*from._impl_.body_);
  }
  if (from._internal_has_this_()) {
    _this->_impl_.this__ = new ::clojure::rt::protobuf::bytecode::Node(*from._impl_.this__);
  }
  _this->_impl_.fixedarity_ = from._impl_.fixedarity_;
  // @@protoc_insertion_point(copy_constructor:clojure.rt.protobuf.bytecode.MethodNode)
}

inline void MethodNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.bridges_){arena}
    , decltype(_impl_.params_){arena}
    , decltype(_impl_.interface_){}
    , decltype(_impl_.loopid_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.body_){nullptr}
    , decltype(_impl_.this__){nullptr}
    , decltype(_impl_.fixedarity_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.interface_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.interface_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.loopid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.loopid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MethodNode::~MethodNode() {
  // @@protoc_insertion_point(destructor:clojure.rt.protobuf.bytecode.MethodNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MethodNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.bridges_.~RepeatedPtrField();
  _impl_.params_.~RepeatedPtrField();
  _impl_.interface_.Destroy();
  _impl_.loopid_.Destroy();
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.body_;
  if (this != internal_default_instance()) delete _impl_.this__;
}

void MethodNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MethodNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojure.rt.protobuf.bytecode.MethodNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.bridges_.Clear();
  _impl_.params_.Clear();
  _impl_.interface_.ClearToEmpty();
  _impl_.loopid_.ClearToEmpty();
  _impl_.name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.body_ != nullptr) {
    delete _impl_.body_;
  }
  _impl_.body_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.this__ != nullptr) {
    delete _impl_.this__;
  }
  _impl_.this__ = nullptr;
  _impl_.fixedarity_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MethodNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .clojure.rt.protobuf.bytecode.Node body = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_body(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string bridges = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_bridges();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "clojure.rt.protobuf.bytecode.MethodNode.bridges"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // uint32 fixedArity = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.fixedarity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string interface = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_interface();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojure.rt.protobuf.bytecode.MethodNode.interface"));
        } else
          goto handle_unusual;
        continue;
      // string loopId = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_loopid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojure.rt.protobuf.bytecode.MethodNode.loopId"));
        } else
          goto handle_unusual;
        continue;
      // string name = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojure.rt.protobuf.bytecode.MethodNode.name"));
        } else
          goto handle_unusual;
        continue;
      // repeated .clojure.rt.protobuf.bytecode.Node params = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_params(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.Node this = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_this_(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MethodNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojure.rt.protobuf.bytecode.MethodNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .clojure.rt.protobuf.bytecode.Node body = 1;
  if (this->_internal_has_body()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::body(this),
        _Internal::body(this).GetCachedSize(), target, stream);
  }

  // repeated string bridges = 2;
  for (int i = 0, n = this->_internal_bridges_size(); i < n; i++) {
    const auto& s = this->_internal_bridges(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojure.rt.protobuf.bytecode.MethodNode.bridges");
    target = stream->WriteString(2, s, target);
  }

  // uint32 fixedArity = 3;
  if (this->_internal_fixedarity() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_fixedarity(), target);
  }

  // string interface = 4;
  if (!this->_internal_interface().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_interface().data(), static_cast<int>(this->_internal_interface().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojure.rt.protobuf.bytecode.MethodNode.interface");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_interface(), target);
  }

  // string loopId = 5;
  if (!this->_internal_loopid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_loopid().data(), static_cast<int>(this->_internal_loopid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojure.rt.protobuf.bytecode.MethodNode.loopId");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_loopid(), target);
  }

  // string name = 6;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojure.rt.protobuf.bytecode.MethodNode.name");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_name(), target);
  }

  // repeated .clojure.rt.protobuf.bytecode.Node params = 7;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_params_size()); i < n; i++) {
    const auto& repfield = this->_internal_params(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .clojure.rt.protobuf.bytecode.Node this = 8;
  if (this->_internal_has_this_()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::this_(this),
        _Internal::this_(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojure.rt.protobuf.bytecode.MethodNode)
  return target;
}

size_t MethodNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojure.rt.protobuf.bytecode.MethodNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string bridges = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.bridges_.size());
  for (int i = 0, n = _impl_.bridges_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.bridges_.Get(i));
  }

  // repeated .clojure.rt.protobuf.bytecode.Node params = 7;
  total_size += 1UL * this->_internal_params_size();
  for (const auto& msg : this->_impl_.params_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string interface = 4;
  if (!this->_internal_interface().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_interface());
  }

  // string loopId = 5;
  if (!this->_internal_loopid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_loopid());
  }

  // string name = 6;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .clojure.rt.protobuf.bytecode.Node body = 1;
  if (this->_internal_has_body()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.body_);
  }

  // .clojure.rt.protobuf.bytecode.Node this = 8;
  if (this->_internal_has_this_()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.this__);
  }

  // uint32 fixedArity = 3;
  if (this->_internal_fixedarity() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_fixedarity());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MethodNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MethodNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MethodNode::GetClassData() const { return &_class_data_; }


void MethodNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MethodNode*>(&to_msg);
  auto& from = static_cast<const MethodNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojure.rt.protobuf.bytecode.MethodNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.bridges_.MergeFrom(from._impl_.bridges_);
  _this->_impl_.params_.MergeFrom(from._impl_.params_);
  if (!from._internal_interface().empty()) {
    _this->_internal_set_interface(from._internal_interface());
  }
  if (!from._internal_loopid().empty()) {
    _this->_internal_set_loopid(from._internal_loopid());
  }
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_has_body()) {
    _this->_internal_mutable_body()->::clojure::rt::protobuf::bytecode::Node::MergeFrom(
        from._internal_body());
  }
  if (from._internal_has_this_()) {
    _this->_internal_mutable_this_()->::clojure::rt::protobuf::bytecode::Node::MergeFrom(
        from._internal_this_());
  }
  if (from._internal_fixedarity() != 0) {
    _this->_internal_set_fixedarity(from._internal_fixedarity());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MethodNode::CopyFrom(const MethodNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojure.rt.protobuf.bytecode.MethodNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MethodNode::IsInitialized() const {
  return true;
}

void MethodNode::InternalSwap(MethodNode* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.bridges_.InternalSwap(&other->_impl_.bridges_);
  _impl_.params_.InternalSwap(&other->_impl_.params_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.interface_, lhs_arena,
      &other->_impl_.interface_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.loopid_, lhs_arena,
      &other->_impl_.loopid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MethodNode, _impl_.fixedarity_)
      + sizeof(MethodNode::_impl_.fixedarity_)
      - PROTOBUF_FIELD_OFFSET(MethodNode, _impl_.body_)>(
          reinterpret_cast<char*>(&_impl_.body_),
          reinterpret_cast<char*>(&other->_impl_.body_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MethodNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[26]);
}

// ===================================================================

class MonitorEnterNode::_Internal {
 public:
  static const ::clojure::rt::protobuf::bytecode::Node& target(const MonitorEnterNode* msg);
};

const ::clojure::rt::protobuf::bytecode::Node&
MonitorEnterNode::_Internal::target(const MonitorEnterNode* msg) {
  return *msg->_impl_.target_;
}
MonitorEnterNode::MonitorEnterNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojure.rt.protobuf.bytecode.MonitorEnterNode)
}
MonitorEnterNode::MonitorEnterNode(const MonitorEnterNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MonitorEnterNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.target_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_target()) {
    _this->_impl_.target_ = new ::clojure::rt::protobuf::bytecode::Node(*from._impl_.target_);
  }
  // @@protoc_insertion_point(copy_constructor:clojure.rt.protobuf.bytecode.MonitorEnterNode)
}

inline void MonitorEnterNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.target_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

MonitorEnterNode::~MonitorEnterNode() {
  // @@protoc_insertion_point(destructor:clojure.rt.protobuf.bytecode.MonitorEnterNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MonitorEnterNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.target_;
}

void MonitorEnterNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MonitorEnterNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojure.rt.protobuf.bytecode.MonitorEnterNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.target_ != nullptr) {
    delete _impl_.target_;
  }
  _impl_.target_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MonitorEnterNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .clojure.rt.protobuf.bytecode.Node target = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_target(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MonitorEnterNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojure.rt.protobuf.bytecode.MonitorEnterNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .clojure.rt.protobuf.bytecode.Node target = 1;
  if (this->_internal_has_target()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::target(this),
        _Internal::target(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojure.rt.protobuf.bytecode.MonitorEnterNode)
  return target;
}

size_t MonitorEnterNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojure.rt.protobuf.bytecode.MonitorEnterNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .clojure.rt.protobuf.bytecode.Node target = 1;
  if (this->_internal_has_target()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.target_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MonitorEnterNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MonitorEnterNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MonitorEnterNode::GetClassData() const { return &_class_data_; }


void MonitorEnterNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MonitorEnterNode*>(&to_msg);
  auto& from = static_cast<const MonitorEnterNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojure.rt.protobuf.bytecode.MonitorEnterNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_target()) {
    _this->_internal_mutable_target()->::clojure::rt::protobuf::bytecode::Node::MergeFrom(
        from._internal_target());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MonitorEnterNode::CopyFrom(const MonitorEnterNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojure.rt.protobuf.bytecode.MonitorEnterNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MonitorEnterNode::IsInitialized() const {
  return true;
}

void MonitorEnterNode::InternalSwap(MonitorEnterNode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.target_, other->_impl_.target_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MonitorEnterNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[27]);
}

// ===================================================================

class MonitorExitNode::_Internal {
 public:
  static const ::clojure::rt::protobuf::bytecode::Node& target(const MonitorExitNode* msg);
};

const ::clojure::rt::protobuf::bytecode::Node&
MonitorExitNode::_Internal::target(const MonitorExitNode* msg) {
  return *msg->_impl_.target_;
}
MonitorExitNode::MonitorExitNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojure.rt.protobuf.bytecode.MonitorExitNode)
}
MonitorExitNode::MonitorExitNode(const MonitorExitNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MonitorExitNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.target_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_target()) {
    _this->_impl_.target_ = new ::clojure::rt::protobuf::bytecode::Node(*from._impl_.target_);
  }
  // @@protoc_insertion_point(copy_constructor:clojure.rt.protobuf.bytecode.MonitorExitNode)
}

inline void MonitorExitNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.target_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

MonitorExitNode::~MonitorExitNode() {
  // @@protoc_insertion_point(destructor:clojure.rt.protobuf.bytecode.MonitorExitNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MonitorExitNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.target_;
}

void MonitorExitNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MonitorExitNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojure.rt.protobuf.bytecode.MonitorExitNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.target_ != nullptr) {
    delete _impl_.target_;
  }
  _impl_.target_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MonitorExitNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .clojure.rt.protobuf.bytecode.Node target = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_target(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MonitorExitNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojure.rt.protobuf.bytecode.MonitorExitNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .clojure.rt.protobuf.bytecode.Node target = 1;
  if (this->_internal_has_target()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::target(this),
        _Internal::target(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojure.rt.protobuf.bytecode.MonitorExitNode)
  return target;
}

size_t MonitorExitNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojure.rt.protobuf.bytecode.MonitorExitNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .clojure.rt.protobuf.bytecode.Node target = 1;
  if (this->_internal_has_target()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.target_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MonitorExitNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MonitorExitNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MonitorExitNode::GetClassData() const { return &_class_data_; }


void MonitorExitNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MonitorExitNode*>(&to_msg);
  auto& from = static_cast<const MonitorExitNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojure.rt.protobuf.bytecode.MonitorExitNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_target()) {
    _this->_internal_mutable_target()->::clojure::rt::protobuf::bytecode::Node::MergeFrom(
        from._internal_target());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MonitorExitNode::CopyFrom(const MonitorExitNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojure.rt.protobuf.bytecode.MonitorExitNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MonitorExitNode::IsInitialized() const {
  return true;
}

void MonitorExitNode::InternalSwap(MonitorExitNode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.target_, other->_impl_.target_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MonitorExitNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[28]);
}

// ===================================================================

class NewNode::_Internal {
 public:
  static const ::clojure::rt::protobuf::bytecode::Node& class_(const NewNode* msg);
};

const ::clojure::rt::protobuf::bytecode::Node&
NewNode::_Internal::class_(const NewNode* msg) {
  return *msg->_impl_.class__;
}
NewNode::NewNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojure.rt.protobuf.bytecode.NewNode)
}
NewNode::NewNode(const NewNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NewNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.args_){from._impl_.args_}
    , decltype(_impl_.class__){nullptr}
    , decltype(_impl_.isvalidated_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_class_()) {
    _this->_impl_.class__ = new ::clojure::rt::protobuf::bytecode::Node(*from._impl_.class__);
  }
  _this->_impl_.isvalidated_ = from._impl_.isvalidated_;
  // @@protoc_insertion_point(copy_constructor:clojure.rt.protobuf.bytecode.NewNode)
}

inline void NewNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.args_){arena}
    , decltype(_impl_.class__){nullptr}
    , decltype(_impl_.isvalidated_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

NewNode::~NewNode() {
  // @@protoc_insertion_point(destructor:clojure.rt.protobuf.bytecode.NewNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NewNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.args_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.class__;
}

void NewNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NewNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojure.rt.protobuf.bytecode.NewNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.args_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.class__ != nullptr) {
    delete _impl_.class__;
  }
  _impl_.class__ = nullptr;
  _impl_.isvalidated_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NewNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .clojure.rt.protobuf.bytecode.Node args = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_args(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.Node class = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_class_(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool isValidated = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.isvalidated_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NewNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojure.rt.protobuf.bytecode.NewNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .clojure.rt.protobuf.bytecode.Node args = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_args_size()); i < n; i++) {
    const auto& repfield = this->_internal_args(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .clojure.rt.protobuf.bytecode.Node class = 2;
  if (this->_internal_has_class_()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::class_(this),
        _Internal::class_(this).GetCachedSize(), target, stream);
  }

  // bool isValidated = 3;
  if (this->_internal_isvalidated() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_isvalidated(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojure.rt.protobuf.bytecode.NewNode)
  return target;
}

size_t NewNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojure.rt.protobuf.bytecode.NewNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .clojure.rt.protobuf.bytecode.Node args = 1;
  total_size += 1UL * this->_internal_args_size();
  for (const auto& msg : this->_impl_.args_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .clojure.rt.protobuf.bytecode.Node class = 2;
  if (this->_internal_has_class_()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.class__);
  }

  // bool isValidated = 3;
  if (this->_internal_isvalidated() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NewNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NewNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NewNode::GetClassData() const { return &_class_data_; }


void NewNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NewNode*>(&to_msg);
  auto& from = static_cast<const NewNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojure.rt.protobuf.bytecode.NewNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.args_.MergeFrom(from._impl_.args_);
  if (from._internal_has_class_()) {
    _this->_internal_mutable_class_()->::clojure::rt::protobuf::bytecode::Node::MergeFrom(
        from._internal_class_());
  }
  if (from._internal_isvalidated() != 0) {
    _this->_internal_set_isvalidated(from._internal_isvalidated());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NewNode::CopyFrom(const NewNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojure.rt.protobuf.bytecode.NewNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NewNode::IsInitialized() const {
  return true;
}

void NewNode::InternalSwap(NewNode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.args_.InternalSwap(&other->_impl_.args_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NewNode, _impl_.isvalidated_)
      + sizeof(NewNode::_impl_.isvalidated_)
      - PROTOBUF_FIELD_OFFSET(NewNode, _impl_.class__)>(
          reinterpret_cast<char*>(&_impl_.class__),
          reinterpret_cast<char*>(&other->_impl_.class__));
}

::PROTOBUF_NAMESPACE_ID::Metadata NewNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[29]);
}

// ===================================================================

class PrimInvokeNode::_Internal {
 public:
  static const ::clojure::rt::protobuf::bytecode::Node& fn(const PrimInvokeNode* msg);
};

const ::clojure::rt::protobuf::bytecode::Node&
PrimInvokeNode::_Internal::fn(const PrimInvokeNode* msg) {
  return *msg->_impl_.fn_;
}
PrimInvokeNode::PrimInvokeNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojure.rt.protobuf.bytecode.PrimInvokeNode)
}
PrimInvokeNode::PrimInvokeNode(const PrimInvokeNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PrimInvokeNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.args_){from._impl_.args_}
    , decltype(_impl_.meta_){}
    , decltype(_impl_.priminterface_){}
    , decltype(_impl_.fn_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.meta_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.meta_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_meta().empty()) {
    _this->_impl_.meta_.Set(from._internal_meta(), 
      _this->GetArenaForAllocation());
  }
  _impl_.priminterface_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.priminterface_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_priminterface().empty()) {
    _this->_impl_.priminterface_.Set(from._internal_priminterface(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_fn()) {
    _this->_impl_.fn_ = new ::clojure::rt::protobuf::bytecode::Node(*from._impl_.fn_);
  }
  // @@protoc_insertion_point(copy_constructor:clojure.rt.protobuf.bytecode.PrimInvokeNode)
}

inline void PrimInvokeNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.args_){arena}
    , decltype(_impl_.meta_){}
    , decltype(_impl_.priminterface_){}
    , decltype(_impl_.fn_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.meta_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.meta_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.priminterface_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.priminterface_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PrimInvokeNode::~PrimInvokeNode() {
  // @@protoc_insertion_point(destructor:clojure.rt.protobuf.bytecode.PrimInvokeNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PrimInvokeNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.args_.~RepeatedPtrField();
  _impl_.meta_.Destroy();
  _impl_.priminterface_.Destroy();
  if (this != internal_default_instance()) delete _impl_.fn_;
}

void PrimInvokeNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PrimInvokeNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojure.rt.protobuf.bytecode.PrimInvokeNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.args_.Clear();
  _impl_.meta_.ClearToEmpty();
  _impl_.priminterface_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.fn_ != nullptr) {
    delete _impl_.fn_;
  }
  _impl_.fn_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PrimInvokeNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .clojure.rt.protobuf.bytecode.Node args = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_args(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.Node fn = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_fn(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string meta = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_meta();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojure.rt.protobuf.bytecode.PrimInvokeNode.meta"));
        } else
          goto handle_unusual;
        continue;
      // string primInterface = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_priminterface();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojure.rt.protobuf.bytecode.PrimInvokeNode.primInterface"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PrimInvokeNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojure.rt.protobuf.bytecode.PrimInvokeNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .clojure.rt.protobuf.bytecode.Node args = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_args_size()); i < n; i++) {
    const auto& repfield = this->_internal_args(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .clojure.rt.protobuf.bytecode.Node fn = 2;
  if (this->_internal_has_fn()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::fn(this),
        _Internal::fn(this).GetCachedSize(), target, stream);
  }

  // string meta = 3;
  if (!this->_internal_meta().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_meta().data(), static_cast<int>(this->_internal_meta().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojure.rt.protobuf.bytecode.PrimInvokeNode.meta");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_meta(), target);
  }

  // string primInterface = 4;
  if (!this->_internal_priminterface().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_priminterface().data(), static_cast<int>(this->_internal_priminterface().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojure.rt.protobuf.bytecode.PrimInvokeNode.primInterface");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_priminterface(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojure.rt.protobuf.bytecode.PrimInvokeNode)
  return target;
}

size_t PrimInvokeNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojure.rt.protobuf.bytecode.PrimInvokeNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .clojure.rt.protobuf.bytecode.Node args = 1;
  total_size += 1UL * this->_internal_args_size();
  for (const auto& msg : this->_impl_.args_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string meta = 3;
  if (!this->_internal_meta().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_meta());
  }

  // string primInterface = 4;
  if (!this->_internal_priminterface().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_priminterface());
  }

  // .clojure.rt.protobuf.bytecode.Node fn = 2;
  if (this->_internal_has_fn()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.fn_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PrimInvokeNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PrimInvokeNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PrimInvokeNode::GetClassData() const { return &_class_data_; }


void PrimInvokeNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PrimInvokeNode*>(&to_msg);
  auto& from = static_cast<const PrimInvokeNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojure.rt.protobuf.bytecode.PrimInvokeNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.args_.MergeFrom(from._impl_.args_);
  if (!from._internal_meta().empty()) {
    _this->_internal_set_meta(from._internal_meta());
  }
  if (!from._internal_priminterface().empty()) {
    _this->_internal_set_priminterface(from._internal_priminterface());
  }
  if (from._internal_has_fn()) {
    _this->_internal_mutable_fn()->::clojure::rt::protobuf::bytecode::Node::MergeFrom(
        from._internal_fn());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PrimInvokeNode::CopyFrom(const PrimInvokeNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojure.rt.protobuf.bytecode.PrimInvokeNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PrimInvokeNode::IsInitialized() const {
  return true;
}

void PrimInvokeNode::InternalSwap(PrimInvokeNode* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.args_.InternalSwap(&other->_impl_.args_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.meta_, lhs_arena,
      &other->_impl_.meta_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.priminterface_, lhs_arena,
      &other->_impl_.priminterface_, rhs_arena
  );
  swap(_impl_.fn_, other->_impl_.fn_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PrimInvokeNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[30]);
}

// ===================================================================

class ProtocolInvokeNode::_Internal {
 public:
  static const ::clojure::rt::protobuf::bytecode::Node& protocolfn(const ProtocolInvokeNode* msg);
  static const ::clojure::rt::protobuf::bytecode::Node& target(const ProtocolInvokeNode* msg);
};

const ::clojure::rt::protobuf::bytecode::Node&
ProtocolInvokeNode::_Internal::protocolfn(const ProtocolInvokeNode* msg) {
  return *msg->_impl_.protocolfn_;
}
const ::clojure::rt::protobuf::bytecode::Node&
ProtocolInvokeNode::_Internal::target(const ProtocolInvokeNode* msg) {
  return *msg->_impl_.target_;
}
ProtocolInvokeNode::ProtocolInvokeNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojure.rt.protobuf.bytecode.ProtocolInvokeNode)
}
ProtocolInvokeNode::ProtocolInvokeNode(const ProtocolInvokeNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ProtocolInvokeNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.args_){from._impl_.args_}
    , decltype(_impl_.protocolfn_){nullptr}
    , decltype(_impl_.target_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_protocolfn()) {
    _this->_impl_.protocolfn_ = new ::clojure::rt::protobuf::bytecode::Node(*from._impl_.protocolfn_);
  }
  if (from._internal_has_target()) {
    _this->_impl_.target_ = new ::clojure::rt::protobuf::bytecode::Node(*from._impl_.target_);
  }
  // @@protoc_insertion_point(copy_constructor:clojure.rt.protobuf.bytecode.ProtocolInvokeNode)
}

inline void ProtocolInvokeNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.args_){arena}
    , decltype(_impl_.protocolfn_){nullptr}
    , decltype(_impl_.target_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ProtocolInvokeNode::~ProtocolInvokeNode() {
  // @@protoc_insertion_point(destructor:clojure.rt.protobuf.bytecode.ProtocolInvokeNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ProtocolInvokeNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.args_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.protocolfn_;
  if (this != internal_default_instance()) delete _impl_.target_;
}

void ProtocolInvokeNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ProtocolInvokeNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojure.rt.protobuf.bytecode.ProtocolInvokeNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.args_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.protocolfn_ != nullptr) {
    delete _impl_.protocolfn_;
  }
  _impl_.protocolfn_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.target_ != nullptr) {
    delete _impl_.target_;
  }
  _impl_.target_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ProtocolInvokeNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .clojure.rt.protobuf.bytecode.Node args = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_args(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.Node protocolFn = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_protocolfn(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.Node target = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_target(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ProtocolInvokeNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojure.rt.protobuf.bytecode.ProtocolInvokeNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .clojure.rt.protobuf.bytecode.Node args = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_args_size()); i < n; i++) {
    const auto& repfield = this->_internal_args(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .clojure.rt.protobuf.bytecode.Node protocolFn = 2;
  if (this->_internal_has_protocolfn()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::protocolfn(this),
        _Internal::protocolfn(this).GetCachedSize(), target, stream);
  }

  // .clojure.rt.protobuf.bytecode.Node target = 3;
  if (this->_internal_has_target()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::target(this),
        _Internal::target(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojure.rt.protobuf.bytecode.ProtocolInvokeNode)
  return target;
}

size_t ProtocolInvokeNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojure.rt.protobuf.bytecode.ProtocolInvokeNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .clojure.rt.protobuf.bytecode.Node args = 1;
  total_size += 1UL * this->_internal_args_size();
  for (const auto& msg : this->_impl_.args_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .clojure.rt.protobuf.bytecode.Node protocolFn = 2;
  if (this->_internal_has_protocolfn()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.protocolfn_);
  }

  // .clojure.rt.protobuf.bytecode.Node target = 3;
  if (this->_internal_has_target()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.target_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ProtocolInvokeNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ProtocolInvokeNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ProtocolInvokeNode::GetClassData() const { return &_class_data_; }


void ProtocolInvokeNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ProtocolInvokeNode*>(&to_msg);
  auto& from = static_cast<const ProtocolInvokeNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojure.rt.protobuf.bytecode.ProtocolInvokeNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.args_.MergeFrom(from._impl_.args_);
  if (from._internal_has_protocolfn()) {
    _this->_internal_mutable_protocolfn()->::clojure::rt::protobuf::bytecode::Node::MergeFrom(
        from._internal_protocolfn());
  }
  if (from._internal_has_target()) {
    _this->_internal_mutable_target()->::clojure::rt::protobuf::bytecode::Node::MergeFrom(
        from._internal_target());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ProtocolInvokeNode::CopyFrom(const ProtocolInvokeNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojure.rt.protobuf.bytecode.ProtocolInvokeNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProtocolInvokeNode::IsInitialized() const {
  return true;
}

void ProtocolInvokeNode::InternalSwap(ProtocolInvokeNode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.args_.InternalSwap(&other->_impl_.args_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ProtocolInvokeNode, _impl_.target_)
      + sizeof(ProtocolInvokeNode::_impl_.target_)
      - PROTOBUF_FIELD_OFFSET(ProtocolInvokeNode, _impl_.protocolfn_)>(
          reinterpret_cast<char*>(&_impl_.protocolfn_),
          reinterpret_cast<char*>(&other->_impl_.protocolfn_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ProtocolInvokeNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[31]);
}

// ===================================================================

class QuoteNode::_Internal {
 public:
  static const ::clojure::rt::protobuf::bytecode::Node& expr(const QuoteNode* msg);
};

const ::clojure::rt::protobuf::bytecode::Node&
QuoteNode::_Internal::expr(const QuoteNode* msg) {
  return *msg->_impl_.expr_;
}
QuoteNode::QuoteNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojure.rt.protobuf.bytecode.QuoteNode)
}
QuoteNode::QuoteNode(const QuoteNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  QuoteNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.expr_){nullptr}
    , decltype(_impl_.isliteral_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_expr()) {
    _this->_impl_.expr_ = new ::clojure::rt::protobuf::bytecode::Node(*from._impl_.expr_);
  }
  _this->_impl_.isliteral_ = from._impl_.isliteral_;
  // @@protoc_insertion_point(copy_constructor:clojure.rt.protobuf.bytecode.QuoteNode)
}

inline void QuoteNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.expr_){nullptr}
    , decltype(_impl_.isliteral_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

QuoteNode::~QuoteNode() {
  // @@protoc_insertion_point(destructor:clojure.rt.protobuf.bytecode.QuoteNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void QuoteNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.expr_;
}

void QuoteNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void QuoteNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojure.rt.protobuf.bytecode.QuoteNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.expr_ != nullptr) {
    delete _impl_.expr_;
  }
  _impl_.expr_ = nullptr;
  _impl_.isliteral_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* QuoteNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .clojure.rt.protobuf.bytecode.Node expr = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_expr(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool isLiteral = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.isliteral_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* QuoteNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojure.rt.protobuf.bytecode.QuoteNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .clojure.rt.protobuf.bytecode.Node expr = 1;
  if (this->_internal_has_expr()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::expr(this),
        _Internal::expr(this).GetCachedSize(), target, stream);
  }

  // bool isLiteral = 2;
  if (this->_internal_isliteral() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_isliteral(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojure.rt.protobuf.bytecode.QuoteNode)
  return target;
}

size_t QuoteNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojure.rt.protobuf.bytecode.QuoteNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .clojure.rt.protobuf.bytecode.Node expr = 1;
  if (this->_internal_has_expr()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.expr_);
  }

  // bool isLiteral = 2;
  if (this->_internal_isliteral() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData QuoteNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    QuoteNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*QuoteNode::GetClassData() const { return &_class_data_; }


void QuoteNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<QuoteNode*>(&to_msg);
  auto& from = static_cast<const QuoteNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojure.rt.protobuf.bytecode.QuoteNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_expr()) {
    _this->_internal_mutable_expr()->::clojure::rt::protobuf::bytecode::Node::MergeFrom(
        from._internal_expr());
  }
  if (from._internal_isliteral() != 0) {
    _this->_internal_set_isliteral(from._internal_isliteral());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void QuoteNode::CopyFrom(const QuoteNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojure.rt.protobuf.bytecode.QuoteNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool QuoteNode::IsInitialized() const {
  return true;
}

void QuoteNode::InternalSwap(QuoteNode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(QuoteNode, _impl_.isliteral_)
      + sizeof(QuoteNode::_impl_.isliteral_)
      - PROTOBUF_FIELD_OFFSET(QuoteNode, _impl_.expr_)>(
          reinterpret_cast<char*>(&_impl_.expr_),
          reinterpret_cast<char*>(&other->_impl_.expr_));
}

::PROTOBUF_NAMESPACE_ID::Metadata QuoteNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[32]);
}

// ===================================================================

class RecurNode::_Internal {
 public:
};

RecurNode::RecurNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojure.rt.protobuf.bytecode.RecurNode)
}
RecurNode::RecurNode(const RecurNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RecurNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.exprs_){from._impl_.exprs_}
    , decltype(_impl_.loopid_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.loopid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.loopid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_loopid().empty()) {
    _this->_impl_.loopid_.Set(from._internal_loopid(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:clojure.rt.protobuf.bytecode.RecurNode)
}

inline void RecurNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.exprs_){arena}
    , decltype(_impl_.loopid_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.loopid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.loopid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RecurNode::~RecurNode() {
  // @@protoc_insertion_point(destructor:clojure.rt.protobuf.bytecode.RecurNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RecurNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.exprs_.~RepeatedPtrField();
  _impl_.loopid_.Destroy();
}

void RecurNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RecurNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojure.rt.protobuf.bytecode.RecurNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.exprs_.Clear();
  _impl_.loopid_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RecurNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .clojure.rt.protobuf.bytecode.Node exprs = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_exprs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string loopId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_loopid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojure.rt.protobuf.bytecode.RecurNode.loopId"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RecurNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojure.rt.protobuf.bytecode.RecurNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .clojure.rt.protobuf.bytecode.Node exprs = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_exprs_size()); i < n; i++) {
    const auto& repfield = this->_internal_exprs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // string loopId = 2;
  if (!this->_internal_loopid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_loopid().data(), static_cast<int>(this->_internal_loopid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojure.rt.protobuf.bytecode.RecurNode.loopId");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_loopid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojure.rt.protobuf.bytecode.RecurNode)
  return target;
}

size_t RecurNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojure.rt.protobuf.bytecode.RecurNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .clojure.rt.protobuf.bytecode.Node exprs = 1;
  total_size += 1UL * this->_internal_exprs_size();
  for (const auto& msg : this->_impl_.exprs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string loopId = 2;
  if (!this->_internal_loopid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_loopid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RecurNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RecurNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RecurNode::GetClassData() const { return &_class_data_; }


void RecurNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RecurNode*>(&to_msg);
  auto& from = static_cast<const RecurNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojure.rt.protobuf.bytecode.RecurNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.exprs_.MergeFrom(from._impl_.exprs_);
  if (!from._internal_loopid().empty()) {
    _this->_internal_set_loopid(from._internal_loopid());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RecurNode::CopyFrom(const RecurNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojure.rt.protobuf.bytecode.RecurNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RecurNode::IsInitialized() const {
  return true;
}

void RecurNode::InternalSwap(RecurNode* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.exprs_.InternalSwap(&other->_impl_.exprs_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.loopid_, lhs_arena,
      &other->_impl_.loopid_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata RecurNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[33]);
}

// ===================================================================

class ReifyNode::_Internal {
 public:
};

ReifyNode::ReifyNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojure.rt.protobuf.bytecode.ReifyNode)
}
ReifyNode::ReifyNode(const ReifyNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReifyNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.interfaces_){from._impl_.interfaces_}
    , decltype(_impl_.methods_){from._impl_.methods_}
    , decltype(_impl_.classname_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.classname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.classname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_classname().empty()) {
    _this->_impl_.classname_.Set(from._internal_classname(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:clojure.rt.protobuf.bytecode.ReifyNode)
}

inline void ReifyNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.interfaces_){arena}
    , decltype(_impl_.methods_){arena}
    , decltype(_impl_.classname_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.classname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.classname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ReifyNode::~ReifyNode() {
  // @@protoc_insertion_point(destructor:clojure.rt.protobuf.bytecode.ReifyNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReifyNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.interfaces_.~RepeatedPtrField();
  _impl_.methods_.~RepeatedPtrField();
  _impl_.classname_.Destroy();
}

void ReifyNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReifyNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojure.rt.protobuf.bytecode.ReifyNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.interfaces_.Clear();
  _impl_.methods_.Clear();
  _impl_.classname_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReifyNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string className = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_classname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojure.rt.protobuf.bytecode.ReifyNode.className"));
        } else
          goto handle_unusual;
        continue;
      // repeated string interfaces = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_interfaces();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "clojure.rt.protobuf.bytecode.ReifyNode.interfaces"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .clojure.rt.protobuf.bytecode.Node methods = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_methods(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReifyNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojure.rt.protobuf.bytecode.ReifyNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string className = 1;
  if (!this->_internal_classname().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_classname().data(), static_cast<int>(this->_internal_classname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojure.rt.protobuf.bytecode.ReifyNode.className");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_classname(), target);
  }

  // repeated string interfaces = 2;
  for (int i = 0, n = this->_internal_interfaces_size(); i < n; i++) {
    const auto& s = this->_internal_interfaces(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojure.rt.protobuf.bytecode.ReifyNode.interfaces");
    target = stream->WriteString(2, s, target);
  }

  // repeated .clojure.rt.protobuf.bytecode.Node methods = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_methods_size()); i < n; i++) {
    const auto& repfield = this->_internal_methods(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojure.rt.protobuf.bytecode.ReifyNode)
  return target;
}

size_t ReifyNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojure.rt.protobuf.bytecode.ReifyNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string interfaces = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.interfaces_.size());
  for (int i = 0, n = _impl_.interfaces_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.interfaces_.Get(i));
  }

  // repeated .clojure.rt.protobuf.bytecode.Node methods = 3;
  total_size += 1UL * this->_internal_methods_size();
  for (const auto& msg : this->_impl_.methods_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string className = 1;
  if (!this->_internal_classname().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_classname());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReifyNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReifyNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReifyNode::GetClassData() const { return &_class_data_; }


void ReifyNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReifyNode*>(&to_msg);
  auto& from = static_cast<const ReifyNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojure.rt.protobuf.bytecode.ReifyNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.interfaces_.MergeFrom(from._impl_.interfaces_);
  _this->_impl_.methods_.MergeFrom(from._impl_.methods_);
  if (!from._internal_classname().empty()) {
    _this->_internal_set_classname(from._internal_classname());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReifyNode::CopyFrom(const ReifyNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojure.rt.protobuf.bytecode.ReifyNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReifyNode::IsInitialized() const {
  return true;
}

void ReifyNode::InternalSwap(ReifyNode* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.interfaces_.InternalSwap(&other->_impl_.interfaces_);
  _impl_.methods_.InternalSwap(&other->_impl_.methods_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.classname_, lhs_arena,
      &other->_impl_.classname_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ReifyNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[34]);
}

// ===================================================================

class SetNode::_Internal {
 public:
};

SetNode::SetNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojure.rt.protobuf.bytecode.SetNode)
}
SetNode::SetNode(const SetNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SetNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.items_){from._impl_.items_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:clojure.rt.protobuf.bytecode.SetNode)
}

inline void SetNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.items_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SetNode::~SetNode() {
  // @@protoc_insertion_point(destructor:clojure.rt.protobuf.bytecode.SetNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SetNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.items_.~RepeatedPtrField();
}

void SetNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SetNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojure.rt.protobuf.bytecode.SetNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.items_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SetNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .clojure.rt.protobuf.bytecode.Node items = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_items(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SetNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojure.rt.protobuf.bytecode.SetNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .clojure.rt.protobuf.bytecode.Node items = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_items_size()); i < n; i++) {
    const auto& repfield = this->_internal_items(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojure.rt.protobuf.bytecode.SetNode)
  return target;
}

size_t SetNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojure.rt.protobuf.bytecode.SetNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .clojure.rt.protobuf.bytecode.Node items = 1;
  total_size += 1UL * this->_internal_items_size();
  for (const auto& msg : this->_impl_.items_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SetNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SetNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SetNode::GetClassData() const { return &_class_data_; }


void SetNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SetNode*>(&to_msg);
  auto& from = static_cast<const SetNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojure.rt.protobuf.bytecode.SetNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.items_.MergeFrom(from._impl_.items_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SetNode::CopyFrom(const SetNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojure.rt.protobuf.bytecode.SetNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetNode::IsInitialized() const {
  return true;
}

void SetNode::InternalSwap(SetNode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.items_.InternalSwap(&other->_impl_.items_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SetNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[35]);
}

// ===================================================================

class MutateSetNode::_Internal {
 public:
  static const ::clojure::rt::protobuf::bytecode::Node& target(const MutateSetNode* msg);
  static const ::clojure::rt::protobuf::bytecode::Node& val(const MutateSetNode* msg);
};

const ::clojure::rt::protobuf::bytecode::Node&
MutateSetNode::_Internal::target(const MutateSetNode* msg) {
  return *msg->_impl_.target_;
}
const ::clojure::rt::protobuf::bytecode::Node&
MutateSetNode::_Internal::val(const MutateSetNode* msg) {
  return *msg->_impl_.val_;
}
MutateSetNode::MutateSetNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojure.rt.protobuf.bytecode.MutateSetNode)
}
MutateSetNode::MutateSetNode(const MutateSetNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MutateSetNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.target_){nullptr}
    , decltype(_impl_.val_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_target()) {
    _this->_impl_.target_ = new ::clojure::rt::protobuf::bytecode::Node(*from._impl_.target_);
  }
  if (from._internal_has_val()) {
    _this->_impl_.val_ = new ::clojure::rt::protobuf::bytecode::Node(*from._impl_.val_);
  }
  // @@protoc_insertion_point(copy_constructor:clojure.rt.protobuf.bytecode.MutateSetNode)
}

inline void MutateSetNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.target_){nullptr}
    , decltype(_impl_.val_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

MutateSetNode::~MutateSetNode() {
  // @@protoc_insertion_point(destructor:clojure.rt.protobuf.bytecode.MutateSetNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MutateSetNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.target_;
  if (this != internal_default_instance()) delete _impl_.val_;
}

void MutateSetNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MutateSetNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojure.rt.protobuf.bytecode.MutateSetNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.target_ != nullptr) {
    delete _impl_.target_;
  }
  _impl_.target_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.val_ != nullptr) {
    delete _impl_.val_;
  }
  _impl_.val_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MutateSetNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .clojure.rt.protobuf.bytecode.Node target = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_target(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.Node val = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_val(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MutateSetNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojure.rt.protobuf.bytecode.MutateSetNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .clojure.rt.protobuf.bytecode.Node target = 1;
  if (this->_internal_has_target()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::target(this),
        _Internal::target(this).GetCachedSize(), target, stream);
  }

  // .clojure.rt.protobuf.bytecode.Node val = 2;
  if (this->_internal_has_val()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::val(this),
        _Internal::val(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojure.rt.protobuf.bytecode.MutateSetNode)
  return target;
}

size_t MutateSetNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojure.rt.protobuf.bytecode.MutateSetNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .clojure.rt.protobuf.bytecode.Node target = 1;
  if (this->_internal_has_target()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.target_);
  }

  // .clojure.rt.protobuf.bytecode.Node val = 2;
  if (this->_internal_has_val()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.val_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MutateSetNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MutateSetNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MutateSetNode::GetClassData() const { return &_class_data_; }


void MutateSetNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MutateSetNode*>(&to_msg);
  auto& from = static_cast<const MutateSetNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojure.rt.protobuf.bytecode.MutateSetNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_target()) {
    _this->_internal_mutable_target()->::clojure::rt::protobuf::bytecode::Node::MergeFrom(
        from._internal_target());
  }
  if (from._internal_has_val()) {
    _this->_internal_mutable_val()->::clojure::rt::protobuf::bytecode::Node::MergeFrom(
        from._internal_val());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MutateSetNode::CopyFrom(const MutateSetNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojure.rt.protobuf.bytecode.MutateSetNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MutateSetNode::IsInitialized() const {
  return true;
}

void MutateSetNode::InternalSwap(MutateSetNode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MutateSetNode, _impl_.val_)
      + sizeof(MutateSetNode::_impl_.val_)
      - PROTOBUF_FIELD_OFFSET(MutateSetNode, _impl_.target_)>(
          reinterpret_cast<char*>(&_impl_.target_),
          reinterpret_cast<char*>(&other->_impl_.target_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MutateSetNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[36]);
}

// ===================================================================

class StaticCallNode::_Internal {
 public:
};

StaticCallNode::StaticCallNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojure.rt.protobuf.bytecode.StaticCallNode)
}
StaticCallNode::StaticCallNode(const StaticCallNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StaticCallNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.args_){from._impl_.args_}
    , decltype(_impl_.class__){}
    , decltype(_impl_.method_){}
    , decltype(_impl_.isvalidated_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.class__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.class__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_class_().empty()) {
    _this->_impl_.class__.Set(from._internal_class_(), 
      _this->GetArenaForAllocation());
  }
  _impl_.method_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.method_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_method().empty()) {
    _this->_impl_.method_.Set(from._internal_method(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.isvalidated_ = from._impl_.isvalidated_;
  // @@protoc_insertion_point(copy_constructor:clojure.rt.protobuf.bytecode.StaticCallNode)
}

inline void StaticCallNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.args_){arena}
    , decltype(_impl_.class__){}
    , decltype(_impl_.method_){}
    , decltype(_impl_.isvalidated_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.class__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.class__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.method_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.method_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

StaticCallNode::~StaticCallNode() {
  // @@protoc_insertion_point(destructor:clojure.rt.protobuf.bytecode.StaticCallNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StaticCallNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.args_.~RepeatedPtrField();
  _impl_.class__.Destroy();
  _impl_.method_.Destroy();
}

void StaticCallNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StaticCallNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojure.rt.protobuf.bytecode.StaticCallNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.args_.Clear();
  _impl_.class__.ClearToEmpty();
  _impl_.method_.ClearToEmpty();
  _impl_.isvalidated_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StaticCallNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .clojure.rt.protobuf.bytecode.Node args = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_args(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string class = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_class_();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojure.rt.protobuf.bytecode.StaticCallNode.class"));
        } else
          goto handle_unusual;
        continue;
      // string method = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_method();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojure.rt.protobuf.bytecode.StaticCallNode.method"));
        } else
          goto handle_unusual;
        continue;
      // bool isValidated = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.isvalidated_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StaticCallNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojure.rt.protobuf.bytecode.StaticCallNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .clojure.rt.protobuf.bytecode.Node args = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_args_size()); i < n; i++) {
    const auto& repfield = this->_internal_args(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // string class = 2;
  if (!this->_internal_class_().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_class_().data(), static_cast<int>(this->_internal_class_().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojure.rt.protobuf.bytecode.StaticCallNode.class");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_class_(), target);
  }

  // string method = 3;
  if (!this->_internal_method().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_method().data(), static_cast<int>(this->_internal_method().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojure.rt.protobuf.bytecode.StaticCallNode.method");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_method(), target);
  }

  // bool isValidated = 4;
  if (this->_internal_isvalidated() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_isvalidated(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojure.rt.protobuf.bytecode.StaticCallNode)
  return target;
}

size_t StaticCallNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojure.rt.protobuf.bytecode.StaticCallNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .clojure.rt.protobuf.bytecode.Node args = 1;
  total_size += 1UL * this->_internal_args_size();
  for (const auto& msg : this->_impl_.args_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string class = 2;
  if (!this->_internal_class_().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_class_());
  }

  // string method = 3;
  if (!this->_internal_method().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_method());
  }

  // bool isValidated = 4;
  if (this->_internal_isvalidated() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StaticCallNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StaticCallNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StaticCallNode::GetClassData() const { return &_class_data_; }


void StaticCallNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StaticCallNode*>(&to_msg);
  auto& from = static_cast<const StaticCallNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojure.rt.protobuf.bytecode.StaticCallNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.args_.MergeFrom(from._impl_.args_);
  if (!from._internal_class_().empty()) {
    _this->_internal_set_class_(from._internal_class_());
  }
  if (!from._internal_method().empty()) {
    _this->_internal_set_method(from._internal_method());
  }
  if (from._internal_isvalidated() != 0) {
    _this->_internal_set_isvalidated(from._internal_isvalidated());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StaticCallNode::CopyFrom(const StaticCallNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojure.rt.protobuf.bytecode.StaticCallNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StaticCallNode::IsInitialized() const {
  return true;
}

void StaticCallNode::InternalSwap(StaticCallNode* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.args_.InternalSwap(&other->_impl_.args_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.class__, lhs_arena,
      &other->_impl_.class__, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.method_, lhs_arena,
      &other->_impl_.method_, rhs_arena
  );
  swap(_impl_.isvalidated_, other->_impl_.isvalidated_);
}

::PROTOBUF_NAMESPACE_ID::Metadata StaticCallNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[37]);
}

// ===================================================================

class StaticFieldNode::_Internal {
 public:
};

StaticFieldNode::StaticFieldNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojure.rt.protobuf.bytecode.StaticFieldNode)
}
StaticFieldNode::StaticFieldNode(const StaticFieldNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StaticFieldNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.class__){}
    , decltype(_impl_.field_){}
    , decltype(_impl_.isassignable_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.class__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.class__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_class_().empty()) {
    _this->_impl_.class__.Set(from._internal_class_(), 
      _this->GetArenaForAllocation());
  }
  _impl_.field_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.field_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_field().empty()) {
    _this->_impl_.field_.Set(from._internal_field(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.isassignable_ = from._impl_.isassignable_;
  // @@protoc_insertion_point(copy_constructor:clojure.rt.protobuf.bytecode.StaticFieldNode)
}

inline void StaticFieldNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.class__){}
    , decltype(_impl_.field_){}
    , decltype(_impl_.isassignable_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.class__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.class__.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.field_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.field_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

StaticFieldNode::~StaticFieldNode() {
  // @@protoc_insertion_point(destructor:clojure.rt.protobuf.bytecode.StaticFieldNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StaticFieldNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.class__.Destroy();
  _impl_.field_.Destroy();
}

void StaticFieldNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StaticFieldNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojure.rt.protobuf.bytecode.StaticFieldNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.class__.ClearToEmpty();
  _impl_.field_.ClearToEmpty();
  _impl_.isassignable_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StaticFieldNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool isAssignable = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.isassignable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string class = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_class_();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojure.rt.protobuf.bytecode.StaticFieldNode.class"));
        } else
          goto handle_unusual;
        continue;
      // string field = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_field();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojure.rt.protobuf.bytecode.StaticFieldNode.field"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StaticFieldNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojure.rt.protobuf.bytecode.StaticFieldNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool isAssignable = 1;
  if (this->_internal_isassignable() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_isassignable(), target);
  }

  // string class = 2;
  if (!this->_internal_class_().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_class_().data(), static_cast<int>(this->_internal_class_().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojure.rt.protobuf.bytecode.StaticFieldNode.class");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_class_(), target);
  }

  // string field = 3;
  if (!this->_internal_field().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_field().data(), static_cast<int>(this->_internal_field().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojure.rt.protobuf.bytecode.StaticFieldNode.field");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_field(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojure.rt.protobuf.bytecode.StaticFieldNode)
  return target;
}

size_t StaticFieldNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojure.rt.protobuf.bytecode.StaticFieldNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string class = 2;
  if (!this->_internal_class_().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_class_());
  }

  // string field = 3;
  if (!this->_internal_field().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_field());
  }

  // bool isAssignable = 1;
  if (this->_internal_isassignable() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StaticFieldNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StaticFieldNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StaticFieldNode::GetClassData() const { return &_class_data_; }


void StaticFieldNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StaticFieldNode*>(&to_msg);
  auto& from = static_cast<const StaticFieldNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojure.rt.protobuf.bytecode.StaticFieldNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_class_().empty()) {
    _this->_internal_set_class_(from._internal_class_());
  }
  if (!from._internal_field().empty()) {
    _this->_internal_set_field(from._internal_field());
  }
  if (from._internal_isassignable() != 0) {
    _this->_internal_set_isassignable(from._internal_isassignable());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StaticFieldNode::CopyFrom(const StaticFieldNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojure.rt.protobuf.bytecode.StaticFieldNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StaticFieldNode::IsInitialized() const {
  return true;
}

void StaticFieldNode::InternalSwap(StaticFieldNode* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.class__, lhs_arena,
      &other->_impl_.class__, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.field_, lhs_arena,
      &other->_impl_.field_, rhs_arena
  );
  swap(_impl_.isassignable_, other->_impl_.isassignable_);
}

::PROTOBUF_NAMESPACE_ID::Metadata StaticFieldNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[38]);
}

// ===================================================================

class TheVarNode::_Internal {
 public:
};

TheVarNode::TheVarNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojure.rt.protobuf.bytecode.TheVarNode)
}
TheVarNode::TheVarNode(const TheVarNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TheVarNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.var_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.var_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.var_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_var().empty()) {
    _this->_impl_.var_.Set(from._internal_var(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:clojure.rt.protobuf.bytecode.TheVarNode)
}

inline void TheVarNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.var_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.var_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.var_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TheVarNode::~TheVarNode() {
  // @@protoc_insertion_point(destructor:clojure.rt.protobuf.bytecode.TheVarNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TheVarNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.var_.Destroy();
}

void TheVarNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TheVarNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojure.rt.protobuf.bytecode.TheVarNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.var_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TheVarNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string var = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_var();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojure.rt.protobuf.bytecode.TheVarNode.var"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TheVarNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojure.rt.protobuf.bytecode.TheVarNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string var = 1;
  if (!this->_internal_var().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_var().data(), static_cast<int>(this->_internal_var().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojure.rt.protobuf.bytecode.TheVarNode.var");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_var(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojure.rt.protobuf.bytecode.TheVarNode)
  return target;
}

size_t TheVarNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojure.rt.protobuf.bytecode.TheVarNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string var = 1;
  if (!this->_internal_var().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_var());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TheVarNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TheVarNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TheVarNode::GetClassData() const { return &_class_data_; }


void TheVarNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TheVarNode*>(&to_msg);
  auto& from = static_cast<const TheVarNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojure.rt.protobuf.bytecode.TheVarNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_var().empty()) {
    _this->_internal_set_var(from._internal_var());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TheVarNode::CopyFrom(const TheVarNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojure.rt.protobuf.bytecode.TheVarNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TheVarNode::IsInitialized() const {
  return true;
}

void TheVarNode::InternalSwap(TheVarNode* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.var_, lhs_arena,
      &other->_impl_.var_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata TheVarNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[39]);
}

// ===================================================================

class ThrowNode::_Internal {
 public:
  static const ::clojure::rt::protobuf::bytecode::Node& exception(const ThrowNode* msg);
};

const ::clojure::rt::protobuf::bytecode::Node&
ThrowNode::_Internal::exception(const ThrowNode* msg) {
  return *msg->_impl_.exception_;
}
ThrowNode::ThrowNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojure.rt.protobuf.bytecode.ThrowNode)
}
ThrowNode::ThrowNode(const ThrowNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ThrowNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.exception_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_exception()) {
    _this->_impl_.exception_ = new ::clojure::rt::protobuf::bytecode::Node(*from._impl_.exception_);
  }
  // @@protoc_insertion_point(copy_constructor:clojure.rt.protobuf.bytecode.ThrowNode)
}

inline void ThrowNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.exception_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ThrowNode::~ThrowNode() {
  // @@protoc_insertion_point(destructor:clojure.rt.protobuf.bytecode.ThrowNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ThrowNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.exception_;
}

void ThrowNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ThrowNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojure.rt.protobuf.bytecode.ThrowNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.exception_ != nullptr) {
    delete _impl_.exception_;
  }
  _impl_.exception_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ThrowNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .clojure.rt.protobuf.bytecode.Node exception = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_exception(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ThrowNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojure.rt.protobuf.bytecode.ThrowNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .clojure.rt.protobuf.bytecode.Node exception = 1;
  if (this->_internal_has_exception()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::exception(this),
        _Internal::exception(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojure.rt.protobuf.bytecode.ThrowNode)
  return target;
}

size_t ThrowNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojure.rt.protobuf.bytecode.ThrowNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .clojure.rt.protobuf.bytecode.Node exception = 1;
  if (this->_internal_has_exception()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.exception_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ThrowNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ThrowNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ThrowNode::GetClassData() const { return &_class_data_; }


void ThrowNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ThrowNode*>(&to_msg);
  auto& from = static_cast<const ThrowNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojure.rt.protobuf.bytecode.ThrowNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_exception()) {
    _this->_internal_mutable_exception()->::clojure::rt::protobuf::bytecode::Node::MergeFrom(
        from._internal_exception());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ThrowNode::CopyFrom(const ThrowNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojure.rt.protobuf.bytecode.ThrowNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ThrowNode::IsInitialized() const {
  return true;
}

void ThrowNode::InternalSwap(ThrowNode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.exception_, other->_impl_.exception_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ThrowNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[40]);
}

// ===================================================================

class TryNode::_Internal {
 public:
  static const ::clojure::rt::protobuf::bytecode::Node& body(const TryNode* msg);
  static const ::clojure::rt::protobuf::bytecode::Node& finally(const TryNode* msg);
};

const ::clojure::rt::protobuf::bytecode::Node&
TryNode::_Internal::body(const TryNode* msg) {
  return *msg->_impl_.body_;
}
const ::clojure::rt::protobuf::bytecode::Node&
TryNode::_Internal::finally(const TryNode* msg) {
  return *msg->_impl_.finally_;
}
TryNode::TryNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojure.rt.protobuf.bytecode.TryNode)
}
TryNode::TryNode(const TryNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TryNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.catches_){from._impl_.catches_}
    , decltype(_impl_.body_){nullptr}
    , decltype(_impl_.finally_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_body()) {
    _this->_impl_.body_ = new ::clojure::rt::protobuf::bytecode::Node(*from._impl_.body_);
  }
  if (from._internal_has_finally()) {
    _this->_impl_.finally_ = new ::clojure::rt::protobuf::bytecode::Node(*from._impl_.finally_);
  }
  // @@protoc_insertion_point(copy_constructor:clojure.rt.protobuf.bytecode.TryNode)
}

inline void TryNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.catches_){arena}
    , decltype(_impl_.body_){nullptr}
    , decltype(_impl_.finally_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TryNode::~TryNode() {
  // @@protoc_insertion_point(destructor:clojure.rt.protobuf.bytecode.TryNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TryNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.catches_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.body_;
  if (this != internal_default_instance()) delete _impl_.finally_;
}

void TryNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TryNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojure.rt.protobuf.bytecode.TryNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.catches_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.body_ != nullptr) {
    delete _impl_.body_;
  }
  _impl_.body_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.finally_ != nullptr) {
    delete _impl_.finally_;
  }
  _impl_.finally_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TryNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .clojure.rt.protobuf.bytecode.Node body = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_body(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .clojure.rt.protobuf.bytecode.Node catches = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_catches(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.Node finally = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_finally(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TryNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojure.rt.protobuf.bytecode.TryNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .clojure.rt.protobuf.bytecode.Node body = 1;
  if (this->_internal_has_body()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::body(this),
        _Internal::body(this).GetCachedSize(), target, stream);
  }

  // repeated .clojure.rt.protobuf.bytecode.Node catches = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_catches_size()); i < n; i++) {
    const auto& repfield = this->_internal_catches(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .clojure.rt.protobuf.bytecode.Node finally = 3;
  if (this->_internal_has_finally()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::finally(this),
        _Internal::finally(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojure.rt.protobuf.bytecode.TryNode)
  return target;
}

size_t TryNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojure.rt.protobuf.bytecode.TryNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .clojure.rt.protobuf.bytecode.Node catches = 2;
  total_size += 1UL * this->_internal_catches_size();
  for (const auto& msg : this->_impl_.catches_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .clojure.rt.protobuf.bytecode.Node body = 1;
  if (this->_internal_has_body()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.body_);
  }

  // .clojure.rt.protobuf.bytecode.Node finally = 3;
  if (this->_internal_has_finally()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.finally_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TryNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TryNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TryNode::GetClassData() const { return &_class_data_; }


void TryNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TryNode*>(&to_msg);
  auto& from = static_cast<const TryNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojure.rt.protobuf.bytecode.TryNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.catches_.MergeFrom(from._impl_.catches_);
  if (from._internal_has_body()) {
    _this->_internal_mutable_body()->::clojure::rt::protobuf::bytecode::Node::MergeFrom(
        from._internal_body());
  }
  if (from._internal_has_finally()) {
    _this->_internal_mutable_finally()->::clojure::rt::protobuf::bytecode::Node::MergeFrom(
        from._internal_finally());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TryNode::CopyFrom(const TryNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojure.rt.protobuf.bytecode.TryNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TryNode::IsInitialized() const {
  return true;
}

void TryNode::InternalSwap(TryNode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.catches_.InternalSwap(&other->_impl_.catches_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TryNode, _impl_.finally_)
      + sizeof(TryNode::_impl_.finally_)
      - PROTOBUF_FIELD_OFFSET(TryNode, _impl_.body_)>(
          reinterpret_cast<char*>(&_impl_.body_),
          reinterpret_cast<char*>(&other->_impl_.body_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TryNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[41]);
}

// ===================================================================

class VarNode::_Internal {
 public:
};

VarNode::VarNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojure.rt.protobuf.bytecode.VarNode)
}
VarNode::VarNode(const VarNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VarNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.var_){}
    , decltype(_impl_.isassignable_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.var_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.var_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_var().empty()) {
    _this->_impl_.var_.Set(from._internal_var(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.isassignable_ = from._impl_.isassignable_;
  // @@protoc_insertion_point(copy_constructor:clojure.rt.protobuf.bytecode.VarNode)
}

inline void VarNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.var_){}
    , decltype(_impl_.isassignable_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.var_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.var_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

VarNode::~VarNode() {
  // @@protoc_insertion_point(destructor:clojure.rt.protobuf.bytecode.VarNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VarNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.var_.Destroy();
}

void VarNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VarNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojure.rt.protobuf.bytecode.VarNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.var_.ClearToEmpty();
  _impl_.isassignable_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VarNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool isAssignable = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.isassignable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string var = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_var();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojure.rt.protobuf.bytecode.VarNode.var"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VarNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojure.rt.protobuf.bytecode.VarNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool isAssignable = 1;
  if (this->_internal_isassignable() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_isassignable(), target);
  }

  // string var = 2;
  if (!this->_internal_var().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_var().data(), static_cast<int>(this->_internal_var().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojure.rt.protobuf.bytecode.VarNode.var");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_var(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojure.rt.protobuf.bytecode.VarNode)
  return target;
}

size_t VarNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojure.rt.protobuf.bytecode.VarNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string var = 2;
  if (!this->_internal_var().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_var());
  }

  // bool isAssignable = 1;
  if (this->_internal_isassignable() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VarNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VarNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VarNode::GetClassData() const { return &_class_data_; }


void VarNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VarNode*>(&to_msg);
  auto& from = static_cast<const VarNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojure.rt.protobuf.bytecode.VarNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_var().empty()) {
    _this->_internal_set_var(from._internal_var());
  }
  if (from._internal_isassignable() != 0) {
    _this->_internal_set_isassignable(from._internal_isassignable());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VarNode::CopyFrom(const VarNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojure.rt.protobuf.bytecode.VarNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VarNode::IsInitialized() const {
  return true;
}

void VarNode::InternalSwap(VarNode* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.var_, lhs_arena,
      &other->_impl_.var_, rhs_arena
  );
  swap(_impl_.isassignable_, other->_impl_.isassignable_);
}

::PROTOBUF_NAMESPACE_ID::Metadata VarNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[42]);
}

// ===================================================================

class VectorNode::_Internal {
 public:
};

VectorNode::VectorNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojure.rt.protobuf.bytecode.VectorNode)
}
VectorNode::VectorNode(const VectorNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VectorNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.items_){from._impl_.items_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:clojure.rt.protobuf.bytecode.VectorNode)
}

inline void VectorNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.items_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

VectorNode::~VectorNode() {
  // @@protoc_insertion_point(destructor:clojure.rt.protobuf.bytecode.VectorNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VectorNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.items_.~RepeatedPtrField();
}

void VectorNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VectorNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojure.rt.protobuf.bytecode.VectorNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.items_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VectorNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .clojure.rt.protobuf.bytecode.Node items = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_items(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VectorNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojure.rt.protobuf.bytecode.VectorNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .clojure.rt.protobuf.bytecode.Node items = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_items_size()); i < n; i++) {
    const auto& repfield = this->_internal_items(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojure.rt.protobuf.bytecode.VectorNode)
  return target;
}

size_t VectorNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojure.rt.protobuf.bytecode.VectorNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .clojure.rt.protobuf.bytecode.Node items = 1;
  total_size += 1UL * this->_internal_items_size();
  for (const auto& msg : this->_impl_.items_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VectorNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VectorNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VectorNode::GetClassData() const { return &_class_data_; }


void VectorNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VectorNode*>(&to_msg);
  auto& from = static_cast<const VectorNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojure.rt.protobuf.bytecode.VectorNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.items_.MergeFrom(from._impl_.items_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VectorNode::CopyFrom(const VectorNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojure.rt.protobuf.bytecode.VectorNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VectorNode::IsInitialized() const {
  return true;
}

void VectorNode::InternalSwap(VectorNode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.items_.InternalSwap(&other->_impl_.items_);
}

::PROTOBUF_NAMESPACE_ID::Metadata VectorNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[43]);
}

// ===================================================================

class WithMetaNode::_Internal {
 public:
  static const ::clojure::rt::protobuf::bytecode::Node& expr(const WithMetaNode* msg);
  static const ::clojure::rt::protobuf::bytecode::Node& meta(const WithMetaNode* msg);
};

const ::clojure::rt::protobuf::bytecode::Node&
WithMetaNode::_Internal::expr(const WithMetaNode* msg) {
  return *msg->_impl_.expr_;
}
const ::clojure::rt::protobuf::bytecode::Node&
WithMetaNode::_Internal::meta(const WithMetaNode* msg) {
  return *msg->_impl_.meta_;
}
WithMetaNode::WithMetaNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojure.rt.protobuf.bytecode.WithMetaNode)
}
WithMetaNode::WithMetaNode(const WithMetaNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  WithMetaNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.expr_){nullptr}
    , decltype(_impl_.meta_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_expr()) {
    _this->_impl_.expr_ = new ::clojure::rt::protobuf::bytecode::Node(*from._impl_.expr_);
  }
  if (from._internal_has_meta()) {
    _this->_impl_.meta_ = new ::clojure::rt::protobuf::bytecode::Node(*from._impl_.meta_);
  }
  // @@protoc_insertion_point(copy_constructor:clojure.rt.protobuf.bytecode.WithMetaNode)
}

inline void WithMetaNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.expr_){nullptr}
    , decltype(_impl_.meta_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

WithMetaNode::~WithMetaNode() {
  // @@protoc_insertion_point(destructor:clojure.rt.protobuf.bytecode.WithMetaNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void WithMetaNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.expr_;
  if (this != internal_default_instance()) delete _impl_.meta_;
}

void WithMetaNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void WithMetaNode::Clear() {
// @@protoc_insertion_point(message_clear_start:clojure.rt.protobuf.bytecode.WithMetaNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.expr_ != nullptr) {
    delete _impl_.expr_;
  }
  _impl_.expr_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.meta_ != nullptr) {
    delete _impl_.meta_;
  }
  _impl_.meta_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* WithMetaNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .clojure.rt.protobuf.bytecode.Node expr = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_expr(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.Node meta = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_meta(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* WithMetaNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojure.rt.protobuf.bytecode.WithMetaNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .clojure.rt.protobuf.bytecode.Node expr = 1;
  if (this->_internal_has_expr()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::expr(this),
        _Internal::expr(this).GetCachedSize(), target, stream);
  }

  // .clojure.rt.protobuf.bytecode.Node meta = 2;
  if (this->_internal_has_meta()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::meta(this),
        _Internal::meta(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojure.rt.protobuf.bytecode.WithMetaNode)
  return target;
}

size_t WithMetaNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojure.rt.protobuf.bytecode.WithMetaNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .clojure.rt.protobuf.bytecode.Node expr = 1;
  if (this->_internal_has_expr()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.expr_);
  }

  // .clojure.rt.protobuf.bytecode.Node meta = 2;
  if (this->_internal_has_meta()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.meta_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData WithMetaNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    WithMetaNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*WithMetaNode::GetClassData() const { return &_class_data_; }


void WithMetaNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<WithMetaNode*>(&to_msg);
  auto& from = static_cast<const WithMetaNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojure.rt.protobuf.bytecode.WithMetaNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_expr()) {
    _this->_internal_mutable_expr()->::clojure::rt::protobuf::bytecode::Node::MergeFrom(
        from._internal_expr());
  }
  if (from._internal_has_meta()) {
    _this->_internal_mutable_meta()->::clojure::rt::protobuf::bytecode::Node::MergeFrom(
        from._internal_meta());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void WithMetaNode::CopyFrom(const WithMetaNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojure.rt.protobuf.bytecode.WithMetaNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WithMetaNode::IsInitialized() const {
  return true;
}

void WithMetaNode::InternalSwap(WithMetaNode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(WithMetaNode, _impl_.meta_)
      + sizeof(WithMetaNode::_impl_.meta_)
      - PROTOBUF_FIELD_OFFSET(WithMetaNode, _impl_.expr_)>(
          reinterpret_cast<char*>(&_impl_.expr_),
          reinterpret_cast<char*>(&other->_impl_.expr_));
}

::PROTOBUF_NAMESPACE_ID::Metadata WithMetaNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[44]);
}

// ===================================================================

class Node::_Internal {
 public:
  static const ::clojure::rt::protobuf::bytecode::Environment& env(const Node* msg);
  static const ::clojure::rt::protobuf::bytecode::Subnode& subnode(const Node* msg);
};

const ::clojure::rt::protobuf::bytecode::Environment&
Node::_Internal::env(const Node* msg) {
  return *msg->_impl_.env_;
}
const ::clojure::rt::protobuf::bytecode::Subnode&
Node::_Internal::subnode(const Node* msg) {
  return *msg->_impl_.subnode_;
}
Node::Node(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojure.rt.protobuf.bytecode.Node)
}
Node::Node(const Node& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Node* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.loops_){from._impl_.loops_}
    , decltype(_impl_.rawforms_){from._impl_.rawforms_}
    , decltype(_impl_.form_){}
    , decltype(_impl_.otag_){}
    , decltype(_impl_.tag_){}
    , decltype(_impl_.env_){nullptr}
    , decltype(_impl_.subnode_){nullptr}
    , decltype(_impl_.op_){}
    , decltype(_impl_.ignoretag_){}
    , decltype(_impl_.toplevel_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.form_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.form_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_form().empty()) {
    _this->_impl_.form_.Set(from._internal_form(), 
      _this->GetArenaForAllocation());
  }
  _impl_.otag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.otag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_otag().empty()) {
    _this->_impl_.otag_.Set(from._internal_otag(), 
      _this->GetArenaForAllocation());
  }
  _impl_.tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_tag().empty()) {
    _this->_impl_.tag_.Set(from._internal_tag(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_env()) {
    _this->_impl_.env_ = new ::clojure::rt::protobuf::bytecode::Environment(*from._impl_.env_);
  }
  if (from._internal_has_subnode()) {
    _this->_impl_.subnode_ = new ::clojure::rt::protobuf::bytecode::Subnode(*from._impl_.subnode_);
  }
  ::memcpy(&_impl_.op_, &from._impl_.op_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.toplevel_) -
    reinterpret_cast<char*>(&_impl_.op_)) + sizeof(_impl_.toplevel_));
  // @@protoc_insertion_point(copy_constructor:clojure.rt.protobuf.bytecode.Node)
}

inline void Node::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.loops_){arena}
    , decltype(_impl_.rawforms_){arena}
    , decltype(_impl_.form_){}
    , decltype(_impl_.otag_){}
    , decltype(_impl_.tag_){}
    , decltype(_impl_.env_){nullptr}
    , decltype(_impl_.subnode_){nullptr}
    , decltype(_impl_.op_){0}
    , decltype(_impl_.ignoretag_){false}
    , decltype(_impl_.toplevel_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.form_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.form_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.otag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.otag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Node::~Node() {
  // @@protoc_insertion_point(destructor:clojure.rt.protobuf.bytecode.Node)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Node::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.loops_.~RepeatedPtrField();
  _impl_.rawforms_.~RepeatedPtrField();
  _impl_.form_.Destroy();
  _impl_.otag_.Destroy();
  _impl_.tag_.Destroy();
  if (this != internal_default_instance()) delete _impl_.env_;
  if (this != internal_default_instance()) delete _impl_.subnode_;
}

void Node::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Node::Clear() {
// @@protoc_insertion_point(message_clear_start:clojure.rt.protobuf.bytecode.Node)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.loops_.Clear();
  _impl_.rawforms_.Clear();
  _impl_.form_.ClearToEmpty();
  _impl_.otag_.ClearToEmpty();
  _impl_.tag_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.env_ != nullptr) {
    delete _impl_.env_;
  }
  _impl_.env_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.subnode_ != nullptr) {
    delete _impl_.subnode_;
  }
  _impl_.subnode_ = nullptr;
  ::memset(&_impl_.op_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.toplevel_) -
      reinterpret_cast<char*>(&_impl_.op_)) + sizeof(_impl_.toplevel_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Node::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .clojure.rt.protobuf.bytecode.Environment env = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_env(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string form = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_form();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojure.rt.protobuf.bytecode.Node.form"));
        } else
          goto handle_unusual;
        continue;
      // bool ignoreTag = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.ignoretag_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string loops = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_loops();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "clojure.rt.protobuf.bytecode.Node.loops"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string oTag = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_otag();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojure.rt.protobuf.bytecode.Node.oTag"));
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.Op op = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_op(static_cast<::clojure::rt::protobuf::bytecode::Op>(val));
        } else
          goto handle_unusual;
        continue;
      // repeated string rawForms = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_rawforms();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "clojure.rt.protobuf.bytecode.Node.rawForms"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .clojure.rt.protobuf.bytecode.Subnode subnode = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_subnode(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string tag = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_tag();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "clojure.rt.protobuf.bytecode.Node.tag"));
        } else
          goto handle_unusual;
        continue;
      // bool topLevel = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _impl_.toplevel_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Node::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojure.rt.protobuf.bytecode.Node)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .clojure.rt.protobuf.bytecode.Environment env = 1;
  if (this->_internal_has_env()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::env(this),
        _Internal::env(this).GetCachedSize(), target, stream);
  }

  // string form = 2;
  if (!this->_internal_form().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_form().data(), static_cast<int>(this->_internal_form().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojure.rt.protobuf.bytecode.Node.form");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_form(), target);
  }

  // bool ignoreTag = 3;
  if (this->_internal_ignoretag() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_ignoretag(), target);
  }

  // repeated string loops = 4;
  for (int i = 0, n = this->_internal_loops_size(); i < n; i++) {
    const auto& s = this->_internal_loops(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojure.rt.protobuf.bytecode.Node.loops");
    target = stream->WriteString(4, s, target);
  }

  // string oTag = 5;
  if (!this->_internal_otag().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_otag().data(), static_cast<int>(this->_internal_otag().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojure.rt.protobuf.bytecode.Node.oTag");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_otag(), target);
  }

  // .clojure.rt.protobuf.bytecode.Op op = 6;
  if (this->_internal_op() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      6, this->_internal_op(), target);
  }

  // repeated string rawForms = 7;
  for (int i = 0, n = this->_internal_rawforms_size(); i < n; i++) {
    const auto& s = this->_internal_rawforms(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojure.rt.protobuf.bytecode.Node.rawForms");
    target = stream->WriteString(7, s, target);
  }

  // .clojure.rt.protobuf.bytecode.Subnode subnode = 8;
  if (this->_internal_has_subnode()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::subnode(this),
        _Internal::subnode(this).GetCachedSize(), target, stream);
  }

  // string tag = 9;
  if (!this->_internal_tag().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_tag().data(), static_cast<int>(this->_internal_tag().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "clojure.rt.protobuf.bytecode.Node.tag");
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_tag(), target);
  }

  // bool topLevel = 10;
  if (this->_internal_toplevel() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_toplevel(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojure.rt.protobuf.bytecode.Node)
  return target;
}

size_t Node::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojure.rt.protobuf.bytecode.Node)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string loops = 4;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.loops_.size());
  for (int i = 0, n = _impl_.loops_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.loops_.Get(i));
  }

  // repeated string rawForms = 7;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.rawforms_.size());
  for (int i = 0, n = _impl_.rawforms_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.rawforms_.Get(i));
  }

  // string form = 2;
  if (!this->_internal_form().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_form());
  }

  // string oTag = 5;
  if (!this->_internal_otag().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_otag());
  }

  // string tag = 9;
  if (!this->_internal_tag().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_tag());
  }

  // .clojure.rt.protobuf.bytecode.Environment env = 1;
  if (this->_internal_has_env()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.env_);
  }

  // .clojure.rt.protobuf.bytecode.Subnode subnode = 8;
  if (this->_internal_has_subnode()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.subnode_);
  }

  // .clojure.rt.protobuf.bytecode.Op op = 6;
  if (this->_internal_op() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_op());
  }

  // bool ignoreTag = 3;
  if (this->_internal_ignoretag() != 0) {
    total_size += 1 + 1;
  }

  // bool topLevel = 10;
  if (this->_internal_toplevel() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Node::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Node::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Node::GetClassData() const { return &_class_data_; }


void Node::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Node*>(&to_msg);
  auto& from = static_cast<const Node&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojure.rt.protobuf.bytecode.Node)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.loops_.MergeFrom(from._impl_.loops_);
  _this->_impl_.rawforms_.MergeFrom(from._impl_.rawforms_);
  if (!from._internal_form().empty()) {
    _this->_internal_set_form(from._internal_form());
  }
  if (!from._internal_otag().empty()) {
    _this->_internal_set_otag(from._internal_otag());
  }
  if (!from._internal_tag().empty()) {
    _this->_internal_set_tag(from._internal_tag());
  }
  if (from._internal_has_env()) {
    _this->_internal_mutable_env()->::clojure::rt::protobuf::bytecode::Environment::MergeFrom(
        from._internal_env());
  }
  if (from._internal_has_subnode()) {
    _this->_internal_mutable_subnode()->::clojure::rt::protobuf::bytecode::Subnode::MergeFrom(
        from._internal_subnode());
  }
  if (from._internal_op() != 0) {
    _this->_internal_set_op(from._internal_op());
  }
  if (from._internal_ignoretag() != 0) {
    _this->_internal_set_ignoretag(from._internal_ignoretag());
  }
  if (from._internal_toplevel() != 0) {
    _this->_internal_set_toplevel(from._internal_toplevel());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Node::CopyFrom(const Node& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojure.rt.protobuf.bytecode.Node)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Node::IsInitialized() const {
  return true;
}

void Node::InternalSwap(Node* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.loops_.InternalSwap(&other->_impl_.loops_);
  _impl_.rawforms_.InternalSwap(&other->_impl_.rawforms_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.form_, lhs_arena,
      &other->_impl_.form_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.otag_, lhs_arena,
      &other->_impl_.otag_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.tag_, lhs_arena,
      &other->_impl_.tag_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Node, _impl_.toplevel_)
      + sizeof(Node::_impl_.toplevel_)
      - PROTOBUF_FIELD_OFFSET(Node, _impl_.env_)>(
          reinterpret_cast<char*>(&_impl_.env_),
          reinterpret_cast<char*>(&other->_impl_.env_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Node::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[45]);
}

// ===================================================================

class Programme::_Internal {
 public:
};

Programme::Programme(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:clojure.rt.protobuf.bytecode.Programme)
}
Programme::Programme(const Programme& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Programme* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.nodes_){from._impl_.nodes_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:clojure.rt.protobuf.bytecode.Programme)
}

inline void Programme::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.nodes_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Programme::~Programme() {
  // @@protoc_insertion_point(destructor:clojure.rt.protobuf.bytecode.Programme)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Programme::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.nodes_.~RepeatedPtrField();
}

void Programme::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Programme::Clear() {
// @@protoc_insertion_point(message_clear_start:clojure.rt.protobuf.bytecode.Programme)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.nodes_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Programme::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .clojure.rt.protobuf.bytecode.Node nodes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_nodes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Programme::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:clojure.rt.protobuf.bytecode.Programme)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .clojure.rt.protobuf.bytecode.Node nodes = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_nodes_size()); i < n; i++) {
    const auto& repfield = this->_internal_nodes(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:clojure.rt.protobuf.bytecode.Programme)
  return target;
}

size_t Programme::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:clojure.rt.protobuf.bytecode.Programme)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .clojure.rt.protobuf.bytecode.Node nodes = 1;
  total_size += 1UL * this->_internal_nodes_size();
  for (const auto& msg : this->_impl_.nodes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Programme::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Programme::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Programme::GetClassData() const { return &_class_data_; }


void Programme::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Programme*>(&to_msg);
  auto& from = static_cast<const Programme&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:clojure.rt.protobuf.bytecode.Programme)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.nodes_.MergeFrom(from._impl_.nodes_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Programme::CopyFrom(const Programme& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:clojure.rt.protobuf.bytecode.Programme)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Programme::IsInitialized() const {
  return true;
}

void Programme::InternalSwap(Programme* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.nodes_.InternalSwap(&other->_impl_.nodes_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Programme::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_bytecode_2eproto_getter, &descriptor_table_bytecode_2eproto_once,
      file_level_metadata_bytecode_2eproto[46]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace bytecode
}  // namespace protobuf
}  // namespace rt
}  // namespace clojure
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::clojure::rt::protobuf::bytecode::Environment*
Arena::CreateMaybeMessage< ::clojure::rt::protobuf::bytecode::Environment >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojure::rt::protobuf::bytecode::Environment >(arena);
}
template<> PROTOBUF_NOINLINE ::clojure::rt::protobuf::bytecode::Subnode*
Arena::CreateMaybeMessage< ::clojure::rt::protobuf::bytecode::Subnode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojure::rt::protobuf::bytecode::Subnode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojure::rt::protobuf::bytecode::BindingNode*
Arena::CreateMaybeMessage< ::clojure::rt::protobuf::bytecode::BindingNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojure::rt::protobuf::bytecode::BindingNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojure::rt::protobuf::bytecode::CaseNode*
Arena::CreateMaybeMessage< ::clojure::rt::protobuf::bytecode::CaseNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojure::rt::protobuf::bytecode::CaseNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojure::rt::protobuf::bytecode::CaseTestNode*
Arena::CreateMaybeMessage< ::clojure::rt::protobuf::bytecode::CaseTestNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojure::rt::protobuf::bytecode::CaseTestNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojure::rt::protobuf::bytecode::CaseThenNode*
Arena::CreateMaybeMessage< ::clojure::rt::protobuf::bytecode::CaseThenNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojure::rt::protobuf::bytecode::CaseThenNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojure::rt::protobuf::bytecode::CatchNode*
Arena::CreateMaybeMessage< ::clojure::rt::protobuf::bytecode::CatchNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojure::rt::protobuf::bytecode::CatchNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojure::rt::protobuf::bytecode::ConstNode*
Arena::CreateMaybeMessage< ::clojure::rt::protobuf::bytecode::ConstNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojure::rt::protobuf::bytecode::ConstNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojure::rt::protobuf::bytecode::DefNode*
Arena::CreateMaybeMessage< ::clojure::rt::protobuf::bytecode::DefNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojure::rt::protobuf::bytecode::DefNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojure::rt::protobuf::bytecode::DeftypeNode*
Arena::CreateMaybeMessage< ::clojure::rt::protobuf::bytecode::DeftypeNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojure::rt::protobuf::bytecode::DeftypeNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojure::rt::protobuf::bytecode::DoNode*
Arena::CreateMaybeMessage< ::clojure::rt::protobuf::bytecode::DoNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojure::rt::protobuf::bytecode::DoNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojure::rt::protobuf::bytecode::FnNode*
Arena::CreateMaybeMessage< ::clojure::rt::protobuf::bytecode::FnNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojure::rt::protobuf::bytecode::FnNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojure::rt::protobuf::bytecode::FnMethodNode*
Arena::CreateMaybeMessage< ::clojure::rt::protobuf::bytecode::FnMethodNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojure::rt::protobuf::bytecode::FnMethodNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojure::rt::protobuf::bytecode::HostInteropNode*
Arena::CreateMaybeMessage< ::clojure::rt::protobuf::bytecode::HostInteropNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojure::rt::protobuf::bytecode::HostInteropNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojure::rt::protobuf::bytecode::IfNode*
Arena::CreateMaybeMessage< ::clojure::rt::protobuf::bytecode::IfNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojure::rt::protobuf::bytecode::IfNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojure::rt::protobuf::bytecode::ImportNode*
Arena::CreateMaybeMessage< ::clojure::rt::protobuf::bytecode::ImportNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojure::rt::protobuf::bytecode::ImportNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojure::rt::protobuf::bytecode::InstanceCallNode*
Arena::CreateMaybeMessage< ::clojure::rt::protobuf::bytecode::InstanceCallNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojure::rt::protobuf::bytecode::InstanceCallNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojure::rt::protobuf::bytecode::InstanceFieldNode*
Arena::CreateMaybeMessage< ::clojure::rt::protobuf::bytecode::InstanceFieldNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojure::rt::protobuf::bytecode::InstanceFieldNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojure::rt::protobuf::bytecode::IsInstanceNode*
Arena::CreateMaybeMessage< ::clojure::rt::protobuf::bytecode::IsInstanceNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojure::rt::protobuf::bytecode::IsInstanceNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojure::rt::protobuf::bytecode::InvokeNode*
Arena::CreateMaybeMessage< ::clojure::rt::protobuf::bytecode::InvokeNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojure::rt::protobuf::bytecode::InvokeNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojure::rt::protobuf::bytecode::KeywordInvokeNode*
Arena::CreateMaybeMessage< ::clojure::rt::protobuf::bytecode::KeywordInvokeNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojure::rt::protobuf::bytecode::KeywordInvokeNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojure::rt::protobuf::bytecode::LetNode*
Arena::CreateMaybeMessage< ::clojure::rt::protobuf::bytecode::LetNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojure::rt::protobuf::bytecode::LetNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojure::rt::protobuf::bytecode::LetfnNode*
Arena::CreateMaybeMessage< ::clojure::rt::protobuf::bytecode::LetfnNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojure::rt::protobuf::bytecode::LetfnNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojure::rt::protobuf::bytecode::LocalNode*
Arena::CreateMaybeMessage< ::clojure::rt::protobuf::bytecode::LocalNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojure::rt::protobuf::bytecode::LocalNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojure::rt::protobuf::bytecode::LoopNode*
Arena::CreateMaybeMessage< ::clojure::rt::protobuf::bytecode::LoopNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojure::rt::protobuf::bytecode::LoopNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojure::rt::protobuf::bytecode::MapNode*
Arena::CreateMaybeMessage< ::clojure::rt::protobuf::bytecode::MapNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojure::rt::protobuf::bytecode::MapNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojure::rt::protobuf::bytecode::MethodNode*
Arena::CreateMaybeMessage< ::clojure::rt::protobuf::bytecode::MethodNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojure::rt::protobuf::bytecode::MethodNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojure::rt::protobuf::bytecode::MonitorEnterNode*
Arena::CreateMaybeMessage< ::clojure::rt::protobuf::bytecode::MonitorEnterNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojure::rt::protobuf::bytecode::MonitorEnterNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojure::rt::protobuf::bytecode::MonitorExitNode*
Arena::CreateMaybeMessage< ::clojure::rt::protobuf::bytecode::MonitorExitNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojure::rt::protobuf::bytecode::MonitorExitNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojure::rt::protobuf::bytecode::NewNode*
Arena::CreateMaybeMessage< ::clojure::rt::protobuf::bytecode::NewNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojure::rt::protobuf::bytecode::NewNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojure::rt::protobuf::bytecode::PrimInvokeNode*
Arena::CreateMaybeMessage< ::clojure::rt::protobuf::bytecode::PrimInvokeNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojure::rt::protobuf::bytecode::PrimInvokeNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojure::rt::protobuf::bytecode::ProtocolInvokeNode*
Arena::CreateMaybeMessage< ::clojure::rt::protobuf::bytecode::ProtocolInvokeNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojure::rt::protobuf::bytecode::ProtocolInvokeNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojure::rt::protobuf::bytecode::QuoteNode*
Arena::CreateMaybeMessage< ::clojure::rt::protobuf::bytecode::QuoteNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojure::rt::protobuf::bytecode::QuoteNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojure::rt::protobuf::bytecode::RecurNode*
Arena::CreateMaybeMessage< ::clojure::rt::protobuf::bytecode::RecurNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojure::rt::protobuf::bytecode::RecurNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojure::rt::protobuf::bytecode::ReifyNode*
Arena::CreateMaybeMessage< ::clojure::rt::protobuf::bytecode::ReifyNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojure::rt::protobuf::bytecode::ReifyNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojure::rt::protobuf::bytecode::SetNode*
Arena::CreateMaybeMessage< ::clojure::rt::protobuf::bytecode::SetNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojure::rt::protobuf::bytecode::SetNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojure::rt::protobuf::bytecode::MutateSetNode*
Arena::CreateMaybeMessage< ::clojure::rt::protobuf::bytecode::MutateSetNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojure::rt::protobuf::bytecode::MutateSetNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojure::rt::protobuf::bytecode::StaticCallNode*
Arena::CreateMaybeMessage< ::clojure::rt::protobuf::bytecode::StaticCallNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojure::rt::protobuf::bytecode::StaticCallNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojure::rt::protobuf::bytecode::StaticFieldNode*
Arena::CreateMaybeMessage< ::clojure::rt::protobuf::bytecode::StaticFieldNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojure::rt::protobuf::bytecode::StaticFieldNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojure::rt::protobuf::bytecode::TheVarNode*
Arena::CreateMaybeMessage< ::clojure::rt::protobuf::bytecode::TheVarNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojure::rt::protobuf::bytecode::TheVarNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojure::rt::protobuf::bytecode::ThrowNode*
Arena::CreateMaybeMessage< ::clojure::rt::protobuf::bytecode::ThrowNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojure::rt::protobuf::bytecode::ThrowNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojure::rt::protobuf::bytecode::TryNode*
Arena::CreateMaybeMessage< ::clojure::rt::protobuf::bytecode::TryNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojure::rt::protobuf::bytecode::TryNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojure::rt::protobuf::bytecode::VarNode*
Arena::CreateMaybeMessage< ::clojure::rt::protobuf::bytecode::VarNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojure::rt::protobuf::bytecode::VarNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojure::rt::protobuf::bytecode::VectorNode*
Arena::CreateMaybeMessage< ::clojure::rt::protobuf::bytecode::VectorNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojure::rt::protobuf::bytecode::VectorNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojure::rt::protobuf::bytecode::WithMetaNode*
Arena::CreateMaybeMessage< ::clojure::rt::protobuf::bytecode::WithMetaNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojure::rt::protobuf::bytecode::WithMetaNode >(arena);
}
template<> PROTOBUF_NOINLINE ::clojure::rt::protobuf::bytecode::Node*
Arena::CreateMaybeMessage< ::clojure::rt::protobuf::bytecode::Node >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojure::rt::protobuf::bytecode::Node >(arena);
}
template<> PROTOBUF_NOINLINE ::clojure::rt::protobuf::bytecode::Programme*
Arena::CreateMaybeMessage< ::clojure::rt::protobuf::bytecode::Programme >(Arena* arena) {
  return Arena::CreateMessageInternal< ::clojure::rt::protobuf::bytecode::Programme >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
