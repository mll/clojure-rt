
* - not done
v - done
<-- - in progress


Dynamic dispatch:

1. Wszystkie argumenty sa znane na poziomie kompilacji - wywolujemy bezposrednio funkcje,
   sygnatura jest w nazwie. Sygnatura:

Z - boolean, unpacked
C - uft8 char (uint32_t), unpacked
J - int64_t, unpacked
D - double, unpacked
 
Lx - packed value, for example:

LJ int64_t, packed
LC uint32_t, utf8 char, packed
LD double, packed
LZ boolean, packed

Typy ktore zawsze pozostaja spakowane:

LS - String
LV - Vector
LL - List
LM - Map
LY - Symbol
LK - Keyword
LR - Ratio
LH - Big Integer
LN - Nil

LO - Object - moze byc czymkolwiek spakowanym, trzeba dokonac runtime introspection aby sprawdzic

Uwaga! Zalozenie jest takie, ze nigdy nie bedzie typem podawanym do funkcji 
  (niestety tak sie chyba nie da, beda generyczne funkcje...)

LO

Dynamic dispatch powinien to zawsze wyrugowac. Za to jesli chodzi o wartosc zwracana, funkcje moga zwracac object. Przyklad takiej funkcji: 

(defn dyn-ret [x] (if x 1 2.0))

Ta funkcja bedzie zwracala Object z argumentem typu bool i jej dokladna wartosc zwracana nie bedzie znana w trakcie jej kompilacji. Zatem sygnatura bedzie albo:

Z_LO

albo:

LZ_LO

Ale juz w przypadku nil bedzie:

LN_D

Funkcje zawsze preferuja zwracanie typow rozpakowanych, to znaczy ze nie moga zwrocic LD tylko zawsze albo LO albo D.
 

Przyklad zlozonej sygnatury:

ZJD_D

funkcja ktora przyjmuje trzy rozpakowane argumenty - Bool, int, double i produkuje double. 



Runtime:

* Make decision about integer types (64 bit or 32 bit or compiler/options-dependent?)
* Double / float / quad - the same

* UTF8 strings (library from Julia is already there)
* 

v String
v PersistentList
v PersistentVector
v Integer
v Double
v Boolean   
v nil 
v Symbol 
v Keyword 
v ConcurrentHashMap (TODO resizing) 
* Var
* Function (generic)
* FunctionMethod (generic)

v Keyword uniquing
* Symbol uniquing 
* Character
* Ratio
* BigInteger
* PersistentArrayMap
* PersistentHashMap
* PersistentSet

* Implement all java methods for runtime functions (horrible)

Compiler:

* JIT infrastructure + arg type deduction

* Const 
  v Integer
  v Double
  v Boolean 
  v Nil 
  v String 
  v Symbol 
  v Keyword
  * Keyword uniquing
  * Symbol uniquing 

  * Map
  * Vector
  * List
  * Ratio
  * BigInteger

v StaticCall (works for simple math, framework prepared to add more functionality)
v WithMeta (for now just ignores meta)
v If 
v Def and vars system
v Dynamic Def and vars system
* Binding  
* Fn
* FnMethod
* Loop (+ recur for loop)
* Invoke
* Recur (for Fn)
* Vector
* Case (CaseTest CaseThen)
* Memory management (let us start with string)

....




// Hashers:

// from code.google.com/p/smhasher/wiki/MurmurHash3

