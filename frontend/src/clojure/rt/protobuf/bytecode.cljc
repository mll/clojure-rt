;;;----------------------------------------------------------------------------------
;;; Generated by protoc-gen-clojure.  DO NOT EDIT
;;;
;;; Message Implementation of package clojure.rt.protobuf.bytecode
;;;----------------------------------------------------------------------------------
(ns clojure.rt.protobuf.bytecode
  (:require [protojure.protobuf.protocol :as pb]
            [protojure.protobuf.serdes.core :as serdes.core]
            [protojure.protobuf.serdes.complex :as serdes.complex]
            [protojure.protobuf.serdes.utils :refer [tag-map]]
            [protojure.protobuf.serdes.stream :as serdes.stream]
            [clojure.set :as set]
            [clojure.spec.alpha :as s]))

;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Forward declarations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

(declare cis->CaseThenNode)
(declare ecis->CaseThenNode)
(declare new-CaseThenNode)
(declare cis->PrimInvokeNode)
(declare ecis->PrimInvokeNode)
(declare new-PrimInvokeNode)
(declare cis->VectorNode)
(declare ecis->VectorNode)
(declare new-VectorNode)
(declare cis->CatchNode)
(declare ecis->CatchNode)
(declare new-CatchNode)
(declare cis->InstanceFieldNode)
(declare ecis->InstanceFieldNode)
(declare new-InstanceFieldNode)
(declare cis->FnMethodNode)
(declare ecis->FnMethodNode)
(declare new-FnMethodNode)
(declare cis->InstanceCallNode)
(declare ecis->InstanceCallNode)
(declare new-InstanceCallNode)
(declare cis->DefNode)
(declare ecis->DefNode)
(declare new-DefNode)
(declare cis->TheVarNode)
(declare ecis->TheVarNode)
(declare new-TheVarNode)
(declare cis->ThrowNode)
(declare ecis->ThrowNode)
(declare new-ThrowNode)
(declare cis->ProtocolInvokeNode)
(declare ecis->ProtocolInvokeNode)
(declare new-ProtocolInvokeNode)
(declare cis->MutateSetNode)
(declare ecis->MutateSetNode)
(declare new-MutateSetNode)
(declare cis->MonitorEnterNode)
(declare ecis->MonitorEnterNode)
(declare new-MonitorEnterNode)
(declare cis->ImportNode)
(declare ecis->ImportNode)
(declare new-ImportNode)
(declare cis->NewNode)
(declare ecis->NewNode)
(declare new-NewNode)
(declare cis->RecurNode)
(declare ecis->RecurNode)
(declare new-RecurNode)
(declare cis->IsInstanceNode)
(declare ecis->IsInstanceNode)
(declare new-IsInstanceNode)
(declare cis->MonitorExitNode)
(declare ecis->MonitorExitNode)
(declare new-MonitorExitNode)
(declare cis->CaseNode)
(declare ecis->CaseNode)
(declare new-CaseNode)
(declare cis->CaseTestNode)
(declare ecis->CaseTestNode)
(declare new-CaseTestNode)
(declare cis->IfNode)
(declare ecis->IfNode)
(declare new-IfNode)
(declare cis->ConstNode)
(declare ecis->ConstNode)
(declare new-ConstNode)
(declare cis->QuoteNode)
(declare ecis->QuoteNode)
(declare new-QuoteNode)
(declare cis->LetNode)
(declare ecis->LetNode)
(declare new-LetNode)
(declare cis->Environment)
(declare ecis->Environment)
(declare new-Environment)
(declare cis->StaticFieldNode)
(declare ecis->StaticFieldNode)
(declare new-StaticFieldNode)
(declare cis->InvokeNode)
(declare ecis->InvokeNode)
(declare new-InvokeNode)
(declare cis->MemoryManagementGuidance)
(declare ecis->MemoryManagementGuidance)
(declare new-MemoryManagementGuidance)
(declare cis->TryNode)
(declare ecis->TryNode)
(declare new-TryNode)
(declare cis->KeywordInvokeNode)
(declare ecis->KeywordInvokeNode)
(declare new-KeywordInvokeNode)
(declare cis->DeftypeNode)
(declare ecis->DeftypeNode)
(declare new-DeftypeNode)
(declare cis->MapNode)
(declare ecis->MapNode)
(declare new-MapNode)
(declare cis->HostInteropNode)
(declare ecis->HostInteropNode)
(declare new-HostInteropNode)
(declare cis->WithMetaNode)
(declare ecis->WithMetaNode)
(declare new-WithMetaNode)
(declare cis->Programme)
(declare ecis->Programme)
(declare new-Programme)
(declare cis->StaticCallNode)
(declare ecis->StaticCallNode)
(declare new-StaticCallNode)
(declare cis->LoopNode)
(declare ecis->LoopNode)
(declare new-LoopNode)
(declare cis->ReifyNode)
(declare ecis->ReifyNode)
(declare new-ReifyNode)
(declare cis->MethodNode)
(declare ecis->MethodNode)
(declare new-MethodNode)
(declare cis->LetfnNode)
(declare ecis->LetfnNode)
(declare new-LetfnNode)
(declare cis->BindingNode)
(declare ecis->BindingNode)
(declare new-BindingNode)
(declare cis->VarNode)
(declare ecis->VarNode)
(declare new-VarNode)
(declare cis->SetNode)
(declare ecis->SetNode)
(declare new-SetNode)
(declare cis->Node)
(declare ecis->Node)
(declare new-Node)
(declare cis->FnNode)
(declare ecis->FnNode)
(declare new-FnNode)
(declare cis->LocalNode)
(declare ecis->LocalNode)
(declare new-LocalNode)
(declare cis->DoNode)
(declare ecis->DoNode)
(declare new-DoNode)
(declare cis->Subnode)
(declare ecis->Subnode)
(declare new-Subnode)

;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Enumerations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

;-----------------------------------------------------------------------------
; Op
;-----------------------------------------------------------------------------
(def Op-default :opfn)

(def Op-val2label {
  9 :opfn
  3 :opcasethen
  34 :opmutateset
  22 :oploop
  26 :opmonitorexit
  4 :opcatch
  8 :opdo
  28 :oppriminvoke
  14 :opinstancecall
  30 :opquote
  21 :oplocal
  33 :opset
  20 :opletfn
  19 :oplet
  17 :opinvoke
  25 :opmonitorenter
  15 :opinstancefield
  42 :opwithmeta
  7 :opdeftype
  5 :opconst
  18 :opkeywordinvoke
  36 :opstaticfield
  12 :opif
  13 :opimport
  27 :opnew
  24 :opmethod
  35 :opstaticcall
  6 :opdef
  38 :opthrow
  39 :optry
  1 :opcase
  0 :opbinding
  37 :opthevar
  11 :ophostinterop
  32 :opreify
  2 :opcasetest
  16 :opisinstance
  41 :opvector
  10 :opfnmethod
  40 :opvar
  31 :oprecur
  23 :opmap
  29 :opprotocolinvoke})

(def Op-label2val (set/map-invert Op-val2label))

(defn cis->Op [is]
  (let [val (serdes.core/cis->Enum is)]
    (get Op-val2label val val)))

(defn- get-Op [value]
  {:pre [(or (int? value) (contains? Op-label2val value))]}
  (get Op-label2val value value))

(defn write-Op
  ([tag value os] (write-Op tag {:optimize false} value os))
  ([tag options value os]
   (serdes.core/write-Enum tag options (get-Op value) os)))

;-----------------------------------------------------------------------------
; LocalType
;-----------------------------------------------------------------------------
(def LocalType-default :localtypearg)

(def LocalType-val2label {
  0 :localtypearg
  1 :localtypecatch
  2 :localtypefn
  3 :localtypelet
  4 :localtypeletfn
  5 :localtypeloop
  6 :localtypefield
  7 :localtypethis})

(def LocalType-label2val (set/map-invert LocalType-val2label))

(defn cis->LocalType [is]
  (let [val (serdes.core/cis->Enum is)]
    (get LocalType-val2label val val)))

(defn- get-LocalType [value]
  {:pre [(or (int? value) (contains? LocalType-label2val value))]}
  (get LocalType-label2val value value))

(defn write-LocalType
  ([tag value os] (write-LocalType tag {:optimize false} value os))
  ([tag options value os]
   (serdes.core/write-Enum tag options (get-LocalType value) os)))

;-----------------------------------------------------------------------------
; CaseNode-SwitchType
;-----------------------------------------------------------------------------
(def CaseNode-SwitchType-default :switchtypesparse)

(def CaseNode-SwitchType-val2label {
  0 :switchtypesparse
  1 :switchtypecompact})

(def CaseNode-SwitchType-label2val (set/map-invert CaseNode-SwitchType-val2label))

(defn cis->CaseNode-SwitchType [is]
  (let [val (serdes.core/cis->Enum is)]
    (get CaseNode-SwitchType-val2label val val)))

(defn- get-CaseNode-SwitchType [value]
  {:pre [(or (int? value) (contains? CaseNode-SwitchType-label2val value))]}
  (get CaseNode-SwitchType-label2val value value))

(defn write-CaseNode-SwitchType
  ([tag value os] (write-CaseNode-SwitchType tag {:optimize false} value os))
  ([tag options value os]
   (serdes.core/write-Enum tag options (get-CaseNode-SwitchType value) os)))

;-----------------------------------------------------------------------------
; CaseNode-TestType
;-----------------------------------------------------------------------------
(def CaseNode-TestType-default :testtypeint)

(def CaseNode-TestType-val2label {
  0 :testtypeint
  1 :testtypehashequiv
  2 :testtypehashidentity})

(def CaseNode-TestType-label2val (set/map-invert CaseNode-TestType-val2label))

(defn cis->CaseNode-TestType [is]
  (let [val (serdes.core/cis->Enum is)]
    (get CaseNode-TestType-val2label val val)))

(defn- get-CaseNode-TestType [value]
  {:pre [(or (int? value) (contains? CaseNode-TestType-label2val value))]}
  (get CaseNode-TestType-label2val value value))

(defn write-CaseNode-TestType
  ([tag value os] (write-CaseNode-TestType tag {:optimize false} value os))
  ([tag options value os]
   (serdes.core/write-Enum tag options (get-CaseNode-TestType value) os)))

;-----------------------------------------------------------------------------
; ConstNode-ConstType
;-----------------------------------------------------------------------------
(def ConstNode-ConstType-default :consttypevector)

(def ConstNode-ConstType-val2label {
  9 :consttypevector
  3 :consttypesymbol
  4 :consttypestring
  8 :consttypemap
  14 :consttypeclass
  15 :consttypevar
  7 :consttyperecord
  5 :consttypenumber
  12 :consttypechar
  13 :consttyperegex
  6 :consttypetype
  1 :consttypebool
  0 :consttypenil
  11 :consttypeseq
  2 :consttypekeyword
  16 :consttypeunknown
  10 :consttypeset})

(def ConstNode-ConstType-label2val (set/map-invert ConstNode-ConstType-val2label))

(defn cis->ConstNode-ConstType [is]
  (let [val (serdes.core/cis->Enum is)]
    (get ConstNode-ConstType-val2label val val)))

(defn- get-ConstNode-ConstType [value]
  {:pre [(or (int? value) (contains? ConstNode-ConstType-label2val value))]}
  (get ConstNode-ConstType-label2val value value))

(defn write-ConstNode-ConstType
  ([tag value os] (write-ConstNode-ConstType tag {:optimize false} value os))
  ([tag options value os]
   (serdes.core/write-Enum tag options (get-ConstNode-ConstType value) os)))


;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Subnode-types's oneof Implementations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

(defn convert-Subnode-types [origkeyval]
  (cond
     (get-in origkeyval [:types :invoke]) (update-in origkeyval [:types :invoke] new-InvokeNode)
     (get-in origkeyval [:types :map]) (update-in origkeyval [:types :map] new-MapNode)
     (get-in origkeyval [:types :binding]) (update-in origkeyval [:types :binding] new-BindingNode)
     (get-in origkeyval [:types :loop]) (update-in origkeyval [:types :loop] new-LoopNode)
     (get-in origkeyval [:types :instanceCall]) (update-in origkeyval [:types :instanceCall] new-InstanceCallNode)
     (get-in origkeyval [:types :mutateSet]) (update-in origkeyval [:types :mutateSet] new-MutateSetNode)
     (get-in origkeyval [:types :staticCall]) (update-in origkeyval [:types :staticCall] new-StaticCallNode)
     (get-in origkeyval [:types :fnMethod]) (update-in origkeyval [:types :fnMethod] new-FnMethodNode)
     (get-in origkeyval [:types :var]) (update-in origkeyval [:types :var] new-VarNode)
     (get-in origkeyval [:types :instanceField]) (update-in origkeyval [:types :instanceField] new-InstanceFieldNode)
     (get-in origkeyval [:types :try]) (update-in origkeyval [:types :try] new-TryNode)
     (get-in origkeyval [:types :method]) (update-in origkeyval [:types :method] new-MethodNode)
     (get-in origkeyval [:types :keywordInvoke]) (update-in origkeyval [:types :keywordInvoke] new-KeywordInvokeNode)
     (get-in origkeyval [:types :new]) (update-in origkeyval [:types :new] new-NewNode)
     (get-in origkeyval [:types :fn]) (update-in origkeyval [:types :fn] new-FnNode)
     (get-in origkeyval [:types :monitorEnter]) (update-in origkeyval [:types :monitorEnter] new-MonitorEnterNode)
     (get-in origkeyval [:types :monitorExit]) (update-in origkeyval [:types :monitorExit] new-MonitorExitNode)
     (get-in origkeyval [:types :catch]) (update-in origkeyval [:types :catch] new-CatchNode)
     (get-in origkeyval [:types :staticField]) (update-in origkeyval [:types :staticField] new-StaticFieldNode)
     (get-in origkeyval [:types :if]) (update-in origkeyval [:types :if] new-IfNode)
     (get-in origkeyval [:types :let]) (update-in origkeyval [:types :let] new-LetNode)
     (get-in origkeyval [:types :reify]) (update-in origkeyval [:types :reify] new-ReifyNode)
     (get-in origkeyval [:types :import]) (update-in origkeyval [:types :import] new-ImportNode)
     (get-in origkeyval [:types :vector]) (update-in origkeyval [:types :vector] new-VectorNode)
     (get-in origkeyval [:types :const]) (update-in origkeyval [:types :const] new-ConstNode)
     (get-in origkeyval [:types :case]) (update-in origkeyval [:types :case] new-CaseNode)
     (get-in origkeyval [:types :isInstance]) (update-in origkeyval [:types :isInstance] new-IsInstanceNode)
     (get-in origkeyval [:types :primInvoke]) (update-in origkeyval [:types :primInvoke] new-PrimInvokeNode)
     (get-in origkeyval [:types :theVar]) (update-in origkeyval [:types :theVar] new-TheVarNode)
     (get-in origkeyval [:types :do]) (update-in origkeyval [:types :do] new-DoNode)
     (get-in origkeyval [:types :caseTest]) (update-in origkeyval [:types :caseTest] new-CaseTestNode)
     (get-in origkeyval [:types :caseThen]) (update-in origkeyval [:types :caseThen] new-CaseThenNode)
     (get-in origkeyval [:types :hostInterop]) (update-in origkeyval [:types :hostInterop] new-HostInteropNode)
     (get-in origkeyval [:types :withMeta]) (update-in origkeyval [:types :withMeta] new-WithMetaNode)
     (get-in origkeyval [:types :quote]) (update-in origkeyval [:types :quote] new-QuoteNode)
     (get-in origkeyval [:types :local]) (update-in origkeyval [:types :local] new-LocalNode)
     (get-in origkeyval [:types :set]) (update-in origkeyval [:types :set] new-SetNode)
     (get-in origkeyval [:types :def]) (update-in origkeyval [:types :def] new-DefNode)
     (get-in origkeyval [:types :recur]) (update-in origkeyval [:types :recur] new-RecurNode)
     (get-in origkeyval [:types :throw]) (update-in origkeyval [:types :throw] new-ThrowNode)
     (get-in origkeyval [:types :letfn]) (update-in origkeyval [:types :letfn] new-LetfnNode)
     (get-in origkeyval [:types :protocolInvoke]) (update-in origkeyval [:types :protocolInvoke] new-ProtocolInvokeNode)
     (get-in origkeyval [:types :deftype]) (update-in origkeyval [:types :deftype] new-DeftypeNode)
     :default origkeyval))

(defn write-Subnode-types [types os]
  (let [field (first types)
        k (when-not (nil? field) (key field))
        v (when-not (nil? field) (val field))]
     (case k
         :invoke (serdes.core/write-embedded 18 v os)
         :map (serdes.core/write-embedded 24 v os)
         :binding (serdes.core/write-embedded 1 v os)
         :loop (serdes.core/write-embedded 23 v os)
         :instanceCall (serdes.core/write-embedded 15 v os)
         :mutateSet (serdes.core/write-embedded 35 v os)
         :staticCall (serdes.core/write-embedded 36 v os)
         :fnMethod (serdes.core/write-embedded 11 v os)
         :var (serdes.core/write-embedded 41 v os)
         :instanceField (serdes.core/write-embedded 16 v os)
         :try (serdes.core/write-embedded 40 v os)
         :method (serdes.core/write-embedded 25 v os)
         :keywordInvoke (serdes.core/write-embedded 19 v os)
         :new (serdes.core/write-embedded 28 v os)
         :fn (serdes.core/write-embedded 10 v os)
         :monitorEnter (serdes.core/write-embedded 26 v os)
         :monitorExit (serdes.core/write-embedded 27 v os)
         :catch (serdes.core/write-embedded 5 v os)
         :staticField (serdes.core/write-embedded 37 v os)
         :if (serdes.core/write-embedded 13 v os)
         :let (serdes.core/write-embedded 20 v os)
         :reify (serdes.core/write-embedded 33 v os)
         :import (serdes.core/write-embedded 14 v os)
         :vector (serdes.core/write-embedded 42 v os)
         :const (serdes.core/write-embedded 6 v os)
         :case (serdes.core/write-embedded 2 v os)
         :isInstance (serdes.core/write-embedded 17 v os)
         :primInvoke (serdes.core/write-embedded 29 v os)
         :theVar (serdes.core/write-embedded 38 v os)
         :do (serdes.core/write-embedded 9 v os)
         :caseTest (serdes.core/write-embedded 3 v os)
         :caseThen (serdes.core/write-embedded 4 v os)
         :hostInterop (serdes.core/write-embedded 12 v os)
         :withMeta (serdes.core/write-embedded 43 v os)
         :quote (serdes.core/write-embedded 31 v os)
         :local (serdes.core/write-embedded 22 v os)
         :set (serdes.core/write-embedded 34 v os)
         :def (serdes.core/write-embedded 7 v os)
         :recur (serdes.core/write-embedded 32 v os)
         :throw (serdes.core/write-embedded 39 v os)
         :letfn (serdes.core/write-embedded 21 v os)
         :protocolInvoke (serdes.core/write-embedded 30 v os)
         :deftype (serdes.core/write-embedded 8 v os)
         nil)))



;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Message Implementations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

;-----------------------------------------------------------------------------
; CaseThenNode
;-----------------------------------------------------------------------------
(defrecord CaseThenNode-record [hash then]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-Int32 1  {:optimize true} (:hash this) os)
    (serdes.core/write-embedded 2 (:then this) os))
  pb/TypeReflection
  (gettype [this]
    "clojure.rt.protobuf.bytecode.CaseThenNode"))

(s/def :clojure.rt.protobuf.bytecode.CaseThenNode/hash int?)

(s/def ::CaseThenNode-spec (s/keys :opt-un [:clojure.rt.protobuf.bytecode.CaseThenNode/hash ]))
(def CaseThenNode-defaults {:hash 0 })

(defn cis->CaseThenNode
  "CodedInputStream to CaseThenNode"
  [is]
  (->> (tag-map CaseThenNode-defaults
         (fn [tag index]
             (case index
               1 [:hash (serdes.core/cis->Int32 is)]
               2 [:then (ecis->Node is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->CaseThenNode-record)))

(defn ecis->CaseThenNode
  "Embedded CodedInputStream to CaseThenNode"
  [is]
  (serdes.core/cis->embedded cis->CaseThenNode is))

(defn new-CaseThenNode
  "Creates a new instance from a map, similar to map->CaseThenNode except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::CaseThenNode-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::CaseThenNode-spec init))))]}
  (-> (merge CaseThenNode-defaults init)
      (cond-> (some? (get init :then)) (update :then new-Node))
      (map->CaseThenNode-record)))

(defn pb->CaseThenNode
  "Protobuf to CaseThenNode"
  [input]
  (cis->CaseThenNode (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record CaseThenNode-meta {:type "clojure.rt.protobuf.bytecode.CaseThenNode" :decoder pb->CaseThenNode})

;-----------------------------------------------------------------------------
; PrimInvokeNode
;-----------------------------------------------------------------------------
(defrecord PrimInvokeNode-record [args fn meta primInterface]
  pb/Writer
  (serialize [this os]
    (serdes.complex/write-repeated serdes.core/write-embedded 1 (:args this) os)
    (serdes.core/write-embedded 2 (:fn this) os)
    (serdes.core/write-String 3  {:optimize true} (:meta this) os)
    (serdes.core/write-String 4  {:optimize true} (:primInterface this) os))
  pb/TypeReflection
  (gettype [this]
    "clojure.rt.protobuf.bytecode.PrimInvokeNode"))

(s/def :clojure.rt.protobuf.bytecode.PrimInvokeNode/meta string?)
(s/def :clojure.rt.protobuf.bytecode.PrimInvokeNode/primInterface string?)
(s/def ::PrimInvokeNode-spec (s/keys :opt-un [:clojure.rt.protobuf.bytecode.PrimInvokeNode/meta :clojure.rt.protobuf.bytecode.PrimInvokeNode/primInterface ]))
(def PrimInvokeNode-defaults {:args [] :meta "" :primInterface "" })

(defn cis->PrimInvokeNode
  "CodedInputStream to PrimInvokeNode"
  [is]
  (->> (tag-map PrimInvokeNode-defaults
         (fn [tag index]
             (case index
               1 [:args (serdes.complex/cis->repeated ecis->Node is)]
               2 [:fn (ecis->Node is)]
               3 [:meta (serdes.core/cis->String is)]
               4 [:primInterface (serdes.core/cis->String is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->PrimInvokeNode-record)))

(defn ecis->PrimInvokeNode
  "Embedded CodedInputStream to PrimInvokeNode"
  [is]
  (serdes.core/cis->embedded cis->PrimInvokeNode is))

(defn new-PrimInvokeNode
  "Creates a new instance from a map, similar to map->PrimInvokeNode except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::PrimInvokeNode-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::PrimInvokeNode-spec init))))]}
  (-> (merge PrimInvokeNode-defaults init)
      (cond-> (some? (get init :args)) (update :args #(map new-Node %)))
      (cond-> (some? (get init :fn)) (update :fn new-Node))
      (map->PrimInvokeNode-record)))

(defn pb->PrimInvokeNode
  "Protobuf to PrimInvokeNode"
  [input]
  (cis->PrimInvokeNode (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record PrimInvokeNode-meta {:type "clojure.rt.protobuf.bytecode.PrimInvokeNode" :decoder pb->PrimInvokeNode})

;-----------------------------------------------------------------------------
; VectorNode
;-----------------------------------------------------------------------------
(defrecord VectorNode-record [items]
  pb/Writer
  (serialize [this os]
    (serdes.complex/write-repeated serdes.core/write-embedded 1 (:items this) os))
  pb/TypeReflection
  (gettype [this]
    "clojure.rt.protobuf.bytecode.VectorNode"))

(s/def ::VectorNode-spec (s/keys :opt-un []))
(def VectorNode-defaults {:items [] })

(defn cis->VectorNode
  "CodedInputStream to VectorNode"
  [is]
  (->> (tag-map VectorNode-defaults
         (fn [tag index]
             (case index
               1 [:items (serdes.complex/cis->repeated ecis->Node is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->VectorNode-record)))

(defn ecis->VectorNode
  "Embedded CodedInputStream to VectorNode"
  [is]
  (serdes.core/cis->embedded cis->VectorNode is))

(defn new-VectorNode
  "Creates a new instance from a map, similar to map->VectorNode except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::VectorNode-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::VectorNode-spec init))))]}
  (-> (merge VectorNode-defaults init)
      (cond-> (some? (get init :items)) (update :items #(map new-Node %)))
      (map->VectorNode-record)))

(defn pb->VectorNode
  "Protobuf to VectorNode"
  [input]
  (cis->VectorNode (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record VectorNode-meta {:type "clojure.rt.protobuf.bytecode.VectorNode" :decoder pb->VectorNode})

;-----------------------------------------------------------------------------
; CatchNode
;-----------------------------------------------------------------------------
(defrecord CatchNode-record [body class local]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-embedded 1 (:body this) os)
    (serdes.core/write-embedded 2 (:class this) os)
    (serdes.core/write-embedded 3 (:local this) os))
  pb/TypeReflection
  (gettype [this]
    "clojure.rt.protobuf.bytecode.CatchNode"))

(s/def ::CatchNode-spec (s/keys :opt-un []))
(def CatchNode-defaults {})

(defn cis->CatchNode
  "CodedInputStream to CatchNode"
  [is]
  (->> (tag-map CatchNode-defaults
         (fn [tag index]
             (case index
               1 [:body (ecis->Node is)]
               2 [:class (ecis->Node is)]
               3 [:local (ecis->Node is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->CatchNode-record)))

(defn ecis->CatchNode
  "Embedded CodedInputStream to CatchNode"
  [is]
  (serdes.core/cis->embedded cis->CatchNode is))

(defn new-CatchNode
  "Creates a new instance from a map, similar to map->CatchNode except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::CatchNode-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::CatchNode-spec init))))]}
  (-> (merge CatchNode-defaults init)
      (cond-> (some? (get init :body)) (update :body new-Node))
      (cond-> (some? (get init :class)) (update :class new-Node))
      (cond-> (some? (get init :local)) (update :local new-Node))
      (map->CatchNode-record)))

(defn pb->CatchNode
  "Protobuf to CatchNode"
  [input]
  (cis->CatchNode (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record CatchNode-meta {:type "clojure.rt.protobuf.bytecode.CatchNode" :decoder pb->CatchNode})

;-----------------------------------------------------------------------------
; InstanceFieldNode
;-----------------------------------------------------------------------------
(defrecord InstanceFieldNode-record [isAssignable class field instance]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-Bool 1  {:optimize true} (:isAssignable this) os)
    (serdes.core/write-String 2  {:optimize true} (:class this) os)
    (serdes.core/write-String 3  {:optimize true} (:field this) os)
    (serdes.core/write-embedded 4 (:instance this) os))
  pb/TypeReflection
  (gettype [this]
    "clojure.rt.protobuf.bytecode.InstanceFieldNode"))

(s/def :clojure.rt.protobuf.bytecode.InstanceFieldNode/isAssignable boolean?)
(s/def :clojure.rt.protobuf.bytecode.InstanceFieldNode/class string?)
(s/def :clojure.rt.protobuf.bytecode.InstanceFieldNode/field string?)

(s/def ::InstanceFieldNode-spec (s/keys :opt-un [:clojure.rt.protobuf.bytecode.InstanceFieldNode/isAssignable :clojure.rt.protobuf.bytecode.InstanceFieldNode/class :clojure.rt.protobuf.bytecode.InstanceFieldNode/field ]))
(def InstanceFieldNode-defaults {:isAssignable false :class "" :field "" })

(defn cis->InstanceFieldNode
  "CodedInputStream to InstanceFieldNode"
  [is]
  (->> (tag-map InstanceFieldNode-defaults
         (fn [tag index]
             (case index
               1 [:isAssignable (serdes.core/cis->Bool is)]
               2 [:class (serdes.core/cis->String is)]
               3 [:field (serdes.core/cis->String is)]
               4 [:instance (ecis->Node is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->InstanceFieldNode-record)))

(defn ecis->InstanceFieldNode
  "Embedded CodedInputStream to InstanceFieldNode"
  [is]
  (serdes.core/cis->embedded cis->InstanceFieldNode is))

(defn new-InstanceFieldNode
  "Creates a new instance from a map, similar to map->InstanceFieldNode except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::InstanceFieldNode-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::InstanceFieldNode-spec init))))]}
  (-> (merge InstanceFieldNode-defaults init)
      (cond-> (some? (get init :instance)) (update :instance new-Node))
      (map->InstanceFieldNode-record)))

(defn pb->InstanceFieldNode
  "Protobuf to InstanceFieldNode"
  [input]
  (cis->InstanceFieldNode (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record InstanceFieldNode-meta {:type "clojure.rt.protobuf.bytecode.InstanceFieldNode" :decoder pb->InstanceFieldNode})

;-----------------------------------------------------------------------------
; FnMethodNode
;-----------------------------------------------------------------------------
(defrecord FnMethodNode-record [body fixedArity loopId params isVariadic]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-embedded 1 (:body this) os)
    (serdes.core/write-Int32 2  {:optimize true} (:fixedArity this) os)
    (serdes.core/write-String 3  {:optimize true} (:loopId this) os)
    (serdes.complex/write-repeated serdes.core/write-embedded 4 (:params this) os)
    (serdes.core/write-Bool 5  {:optimize true} (:isVariadic this) os))
  pb/TypeReflection
  (gettype [this]
    "clojure.rt.protobuf.bytecode.FnMethodNode"))

(s/def :clojure.rt.protobuf.bytecode.FnMethodNode/fixedArity int?)
(s/def :clojure.rt.protobuf.bytecode.FnMethodNode/loopId string?)

(s/def :clojure.rt.protobuf.bytecode.FnMethodNode/isVariadic boolean?)
(s/def ::FnMethodNode-spec (s/keys :opt-un [:clojure.rt.protobuf.bytecode.FnMethodNode/fixedArity :clojure.rt.protobuf.bytecode.FnMethodNode/loopId :clojure.rt.protobuf.bytecode.FnMethodNode/isVariadic ]))
(def FnMethodNode-defaults {:fixedArity 0 :loopId "" :params [] :isVariadic false })

(defn cis->FnMethodNode
  "CodedInputStream to FnMethodNode"
  [is]
  (->> (tag-map FnMethodNode-defaults
         (fn [tag index]
             (case index
               1 [:body (ecis->Node is)]
               2 [:fixedArity (serdes.core/cis->Int32 is)]
               3 [:loopId (serdes.core/cis->String is)]
               4 [:params (serdes.complex/cis->repeated ecis->Node is)]
               5 [:isVariadic (serdes.core/cis->Bool is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->FnMethodNode-record)))

(defn ecis->FnMethodNode
  "Embedded CodedInputStream to FnMethodNode"
  [is]
  (serdes.core/cis->embedded cis->FnMethodNode is))

(defn new-FnMethodNode
  "Creates a new instance from a map, similar to map->FnMethodNode except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::FnMethodNode-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::FnMethodNode-spec init))))]}
  (-> (merge FnMethodNode-defaults init)
      (cond-> (some? (get init :body)) (update :body new-Node))
      (cond-> (some? (get init :params)) (update :params #(map new-Node %)))
      (map->FnMethodNode-record)))

(defn pb->FnMethodNode
  "Protobuf to FnMethodNode"
  [input]
  (cis->FnMethodNode (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record FnMethodNode-meta {:type "clojure.rt.protobuf.bytecode.FnMethodNode" :decoder pb->FnMethodNode})

;-----------------------------------------------------------------------------
; InstanceCallNode
;-----------------------------------------------------------------------------
(defrecord InstanceCallNode-record [args class instance method isValidated]
  pb/Writer
  (serialize [this os]
    (serdes.complex/write-repeated serdes.core/write-embedded 1 (:args this) os)
    (serdes.core/write-String 2  {:optimize true} (:class this) os)
    (serdes.core/write-embedded 3 (:instance this) os)
    (serdes.core/write-String 4  {:optimize true} (:method this) os)
    (serdes.core/write-Bool 5  {:optimize true} (:isValidated this) os))
  pb/TypeReflection
  (gettype [this]
    "clojure.rt.protobuf.bytecode.InstanceCallNode"))

(s/def :clojure.rt.protobuf.bytecode.InstanceCallNode/class string?)

(s/def :clojure.rt.protobuf.bytecode.InstanceCallNode/method string?)
(s/def :clojure.rt.protobuf.bytecode.InstanceCallNode/isValidated boolean?)
(s/def ::InstanceCallNode-spec (s/keys :opt-un [:clojure.rt.protobuf.bytecode.InstanceCallNode/class :clojure.rt.protobuf.bytecode.InstanceCallNode/method :clojure.rt.protobuf.bytecode.InstanceCallNode/isValidated ]))
(def InstanceCallNode-defaults {:args [] :class "" :method "" :isValidated false })

(defn cis->InstanceCallNode
  "CodedInputStream to InstanceCallNode"
  [is]
  (->> (tag-map InstanceCallNode-defaults
         (fn [tag index]
             (case index
               1 [:args (serdes.complex/cis->repeated ecis->Node is)]
               2 [:class (serdes.core/cis->String is)]
               3 [:instance (ecis->Node is)]
               4 [:method (serdes.core/cis->String is)]
               5 [:isValidated (serdes.core/cis->Bool is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->InstanceCallNode-record)))

(defn ecis->InstanceCallNode
  "Embedded CodedInputStream to InstanceCallNode"
  [is]
  (serdes.core/cis->embedded cis->InstanceCallNode is))

(defn new-InstanceCallNode
  "Creates a new instance from a map, similar to map->InstanceCallNode except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::InstanceCallNode-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::InstanceCallNode-spec init))))]}
  (-> (merge InstanceCallNode-defaults init)
      (cond-> (some? (get init :args)) (update :args #(map new-Node %)))
      (cond-> (some? (get init :instance)) (update :instance new-Node))
      (map->InstanceCallNode-record)))

(defn pb->InstanceCallNode
  "Protobuf to InstanceCallNode"
  [input]
  (cis->InstanceCallNode (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record InstanceCallNode-meta {:type "clojure.rt.protobuf.bytecode.InstanceCallNode" :decoder pb->InstanceCallNode})

;-----------------------------------------------------------------------------
; DefNode
;-----------------------------------------------------------------------------
(defrecord DefNode-record [doc init meta name var]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:doc this) os)
    (serdes.core/write-embedded 2 (:init this) os)
    (serdes.core/write-embedded 3 (:meta this) os)
    (serdes.core/write-String 4  {:optimize true} (:name this) os)
    (serdes.core/write-String 5  {:optimize true} (:var this) os))
  pb/TypeReflection
  (gettype [this]
    "clojure.rt.protobuf.bytecode.DefNode"))

(s/def :clojure.rt.protobuf.bytecode.DefNode/doc string?)


(s/def :clojure.rt.protobuf.bytecode.DefNode/name string?)
(s/def :clojure.rt.protobuf.bytecode.DefNode/var string?)
(s/def ::DefNode-spec (s/keys :opt-un [:clojure.rt.protobuf.bytecode.DefNode/doc :clojure.rt.protobuf.bytecode.DefNode/name :clojure.rt.protobuf.bytecode.DefNode/var ]))
(def DefNode-defaults {:doc "" :name "" :var "" })

(defn cis->DefNode
  "CodedInputStream to DefNode"
  [is]
  (->> (tag-map DefNode-defaults
         (fn [tag index]
             (case index
               1 [:doc (serdes.core/cis->String is)]
               2 [:init (ecis->Node is)]
               3 [:meta (ecis->Node is)]
               4 [:name (serdes.core/cis->String is)]
               5 [:var (serdes.core/cis->String is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->DefNode-record)))

(defn ecis->DefNode
  "Embedded CodedInputStream to DefNode"
  [is]
  (serdes.core/cis->embedded cis->DefNode is))

(defn new-DefNode
  "Creates a new instance from a map, similar to map->DefNode except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::DefNode-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::DefNode-spec init))))]}
  (-> (merge DefNode-defaults init)
      (cond-> (some? (get init :init)) (update :init new-Node))
      (cond-> (some? (get init :meta)) (update :meta new-Node))
      (map->DefNode-record)))

(defn pb->DefNode
  "Protobuf to DefNode"
  [input]
  (cis->DefNode (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record DefNode-meta {:type "clojure.rt.protobuf.bytecode.DefNode" :decoder pb->DefNode})

;-----------------------------------------------------------------------------
; TheVarNode
;-----------------------------------------------------------------------------
(defrecord TheVarNode-record [var]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:var this) os))
  pb/TypeReflection
  (gettype [this]
    "clojure.rt.protobuf.bytecode.TheVarNode"))

(s/def :clojure.rt.protobuf.bytecode.TheVarNode/var string?)
(s/def ::TheVarNode-spec (s/keys :opt-un [:clojure.rt.protobuf.bytecode.TheVarNode/var ]))
(def TheVarNode-defaults {:var "" })

(defn cis->TheVarNode
  "CodedInputStream to TheVarNode"
  [is]
  (->> (tag-map TheVarNode-defaults
         (fn [tag index]
             (case index
               1 [:var (serdes.core/cis->String is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->TheVarNode-record)))

(defn ecis->TheVarNode
  "Embedded CodedInputStream to TheVarNode"
  [is]
  (serdes.core/cis->embedded cis->TheVarNode is))

(defn new-TheVarNode
  "Creates a new instance from a map, similar to map->TheVarNode except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::TheVarNode-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::TheVarNode-spec init))))]}
  (-> (merge TheVarNode-defaults init)
      (map->TheVarNode-record)))

(defn pb->TheVarNode
  "Protobuf to TheVarNode"
  [input]
  (cis->TheVarNode (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record TheVarNode-meta {:type "clojure.rt.protobuf.bytecode.TheVarNode" :decoder pb->TheVarNode})

;-----------------------------------------------------------------------------
; ThrowNode
;-----------------------------------------------------------------------------
(defrecord ThrowNode-record [exception]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-embedded 1 (:exception this) os))
  pb/TypeReflection
  (gettype [this]
    "clojure.rt.protobuf.bytecode.ThrowNode"))

(s/def ::ThrowNode-spec (s/keys :opt-un []))
(def ThrowNode-defaults {})

(defn cis->ThrowNode
  "CodedInputStream to ThrowNode"
  [is]
  (->> (tag-map ThrowNode-defaults
         (fn [tag index]
             (case index
               1 [:exception (ecis->Node is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->ThrowNode-record)))

(defn ecis->ThrowNode
  "Embedded CodedInputStream to ThrowNode"
  [is]
  (serdes.core/cis->embedded cis->ThrowNode is))

(defn new-ThrowNode
  "Creates a new instance from a map, similar to map->ThrowNode except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::ThrowNode-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::ThrowNode-spec init))))]}
  (-> (merge ThrowNode-defaults init)
      (cond-> (some? (get init :exception)) (update :exception new-Node))
      (map->ThrowNode-record)))

(defn pb->ThrowNode
  "Protobuf to ThrowNode"
  [input]
  (cis->ThrowNode (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record ThrowNode-meta {:type "clojure.rt.protobuf.bytecode.ThrowNode" :decoder pb->ThrowNode})

;-----------------------------------------------------------------------------
; ProtocolInvokeNode
;-----------------------------------------------------------------------------
(defrecord ProtocolInvokeNode-record [args protocolFn target]
  pb/Writer
  (serialize [this os]
    (serdes.complex/write-repeated serdes.core/write-embedded 1 (:args this) os)
    (serdes.core/write-embedded 2 (:protocolFn this) os)
    (serdes.core/write-embedded 3 (:target this) os))
  pb/TypeReflection
  (gettype [this]
    "clojure.rt.protobuf.bytecode.ProtocolInvokeNode"))

(s/def ::ProtocolInvokeNode-spec (s/keys :opt-un []))
(def ProtocolInvokeNode-defaults {:args [] })

(defn cis->ProtocolInvokeNode
  "CodedInputStream to ProtocolInvokeNode"
  [is]
  (->> (tag-map ProtocolInvokeNode-defaults
         (fn [tag index]
             (case index
               1 [:args (serdes.complex/cis->repeated ecis->Node is)]
               2 [:protocolFn (ecis->Node is)]
               3 [:target (ecis->Node is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->ProtocolInvokeNode-record)))

(defn ecis->ProtocolInvokeNode
  "Embedded CodedInputStream to ProtocolInvokeNode"
  [is]
  (serdes.core/cis->embedded cis->ProtocolInvokeNode is))

(defn new-ProtocolInvokeNode
  "Creates a new instance from a map, similar to map->ProtocolInvokeNode except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::ProtocolInvokeNode-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::ProtocolInvokeNode-spec init))))]}
  (-> (merge ProtocolInvokeNode-defaults init)
      (cond-> (some? (get init :args)) (update :args #(map new-Node %)))
      (cond-> (some? (get init :protocolFn)) (update :protocolFn new-Node))
      (cond-> (some? (get init :target)) (update :target new-Node))
      (map->ProtocolInvokeNode-record)))

(defn pb->ProtocolInvokeNode
  "Protobuf to ProtocolInvokeNode"
  [input]
  (cis->ProtocolInvokeNode (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record ProtocolInvokeNode-meta {:type "clojure.rt.protobuf.bytecode.ProtocolInvokeNode" :decoder pb->ProtocolInvokeNode})

;-----------------------------------------------------------------------------
; MutateSetNode
;-----------------------------------------------------------------------------
(defrecord MutateSetNode-record [target val]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-embedded 1 (:target this) os)
    (serdes.core/write-embedded 2 (:val this) os))
  pb/TypeReflection
  (gettype [this]
    "clojure.rt.protobuf.bytecode.MutateSetNode"))

(s/def ::MutateSetNode-spec (s/keys :opt-un []))
(def MutateSetNode-defaults {})

(defn cis->MutateSetNode
  "CodedInputStream to MutateSetNode"
  [is]
  (->> (tag-map MutateSetNode-defaults
         (fn [tag index]
             (case index
               1 [:target (ecis->Node is)]
               2 [:val (ecis->Node is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->MutateSetNode-record)))

(defn ecis->MutateSetNode
  "Embedded CodedInputStream to MutateSetNode"
  [is]
  (serdes.core/cis->embedded cis->MutateSetNode is))

(defn new-MutateSetNode
  "Creates a new instance from a map, similar to map->MutateSetNode except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::MutateSetNode-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::MutateSetNode-spec init))))]}
  (-> (merge MutateSetNode-defaults init)
      (cond-> (some? (get init :target)) (update :target new-Node))
      (cond-> (some? (get init :val)) (update :val new-Node))
      (map->MutateSetNode-record)))

(defn pb->MutateSetNode
  "Protobuf to MutateSetNode"
  [input]
  (cis->MutateSetNode (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record MutateSetNode-meta {:type "clojure.rt.protobuf.bytecode.MutateSetNode" :decoder pb->MutateSetNode})

;-----------------------------------------------------------------------------
; MonitorEnterNode
;-----------------------------------------------------------------------------
(defrecord MonitorEnterNode-record [target]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-embedded 1 (:target this) os))
  pb/TypeReflection
  (gettype [this]
    "clojure.rt.protobuf.bytecode.MonitorEnterNode"))

(s/def ::MonitorEnterNode-spec (s/keys :opt-un []))
(def MonitorEnterNode-defaults {})

(defn cis->MonitorEnterNode
  "CodedInputStream to MonitorEnterNode"
  [is]
  (->> (tag-map MonitorEnterNode-defaults
         (fn [tag index]
             (case index
               1 [:target (ecis->Node is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->MonitorEnterNode-record)))

(defn ecis->MonitorEnterNode
  "Embedded CodedInputStream to MonitorEnterNode"
  [is]
  (serdes.core/cis->embedded cis->MonitorEnterNode is))

(defn new-MonitorEnterNode
  "Creates a new instance from a map, similar to map->MonitorEnterNode except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::MonitorEnterNode-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::MonitorEnterNode-spec init))))]}
  (-> (merge MonitorEnterNode-defaults init)
      (cond-> (some? (get init :target)) (update :target new-Node))
      (map->MonitorEnterNode-record)))

(defn pb->MonitorEnterNode
  "Protobuf to MonitorEnterNode"
  [input]
  (cis->MonitorEnterNode (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record MonitorEnterNode-meta {:type "clojure.rt.protobuf.bytecode.MonitorEnterNode" :decoder pb->MonitorEnterNode})

;-----------------------------------------------------------------------------
; ImportNode
;-----------------------------------------------------------------------------
(defrecord ImportNode-record [class]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:class this) os))
  pb/TypeReflection
  (gettype [this]
    "clojure.rt.protobuf.bytecode.ImportNode"))

(s/def :clojure.rt.protobuf.bytecode.ImportNode/class string?)
(s/def ::ImportNode-spec (s/keys :opt-un [:clojure.rt.protobuf.bytecode.ImportNode/class ]))
(def ImportNode-defaults {:class "" })

(defn cis->ImportNode
  "CodedInputStream to ImportNode"
  [is]
  (->> (tag-map ImportNode-defaults
         (fn [tag index]
             (case index
               1 [:class (serdes.core/cis->String is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->ImportNode-record)))

(defn ecis->ImportNode
  "Embedded CodedInputStream to ImportNode"
  [is]
  (serdes.core/cis->embedded cis->ImportNode is))

(defn new-ImportNode
  "Creates a new instance from a map, similar to map->ImportNode except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::ImportNode-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::ImportNode-spec init))))]}
  (-> (merge ImportNode-defaults init)
      (map->ImportNode-record)))

(defn pb->ImportNode
  "Protobuf to ImportNode"
  [input]
  (cis->ImportNode (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record ImportNode-meta {:type "clojure.rt.protobuf.bytecode.ImportNode" :decoder pb->ImportNode})

;-----------------------------------------------------------------------------
; NewNode
;-----------------------------------------------------------------------------
(defrecord NewNode-record [args class isValidated]
  pb/Writer
  (serialize [this os]
    (serdes.complex/write-repeated serdes.core/write-embedded 1 (:args this) os)
    (serdes.core/write-embedded 2 (:class this) os)
    (serdes.core/write-Bool 3  {:optimize true} (:isValidated this) os))
  pb/TypeReflection
  (gettype [this]
    "clojure.rt.protobuf.bytecode.NewNode"))

(s/def :clojure.rt.protobuf.bytecode.NewNode/isValidated boolean?)
(s/def ::NewNode-spec (s/keys :opt-un [:clojure.rt.protobuf.bytecode.NewNode/isValidated ]))
(def NewNode-defaults {:args [] :isValidated false })

(defn cis->NewNode
  "CodedInputStream to NewNode"
  [is]
  (->> (tag-map NewNode-defaults
         (fn [tag index]
             (case index
               1 [:args (serdes.complex/cis->repeated ecis->Node is)]
               2 [:class (ecis->Node is)]
               3 [:isValidated (serdes.core/cis->Bool is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->NewNode-record)))

(defn ecis->NewNode
  "Embedded CodedInputStream to NewNode"
  [is]
  (serdes.core/cis->embedded cis->NewNode is))

(defn new-NewNode
  "Creates a new instance from a map, similar to map->NewNode except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::NewNode-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::NewNode-spec init))))]}
  (-> (merge NewNode-defaults init)
      (cond-> (some? (get init :args)) (update :args #(map new-Node %)))
      (cond-> (some? (get init :class)) (update :class new-Node))
      (map->NewNode-record)))

(defn pb->NewNode
  "Protobuf to NewNode"
  [input]
  (cis->NewNode (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record NewNode-meta {:type "clojure.rt.protobuf.bytecode.NewNode" :decoder pb->NewNode})

;-----------------------------------------------------------------------------
; RecurNode
;-----------------------------------------------------------------------------
(defrecord RecurNode-record [exprs loopId]
  pb/Writer
  (serialize [this os]
    (serdes.complex/write-repeated serdes.core/write-embedded 1 (:exprs this) os)
    (serdes.core/write-String 2  {:optimize true} (:loopId this) os))
  pb/TypeReflection
  (gettype [this]
    "clojure.rt.protobuf.bytecode.RecurNode"))

(s/def :clojure.rt.protobuf.bytecode.RecurNode/loopId string?)
(s/def ::RecurNode-spec (s/keys :opt-un [:clojure.rt.protobuf.bytecode.RecurNode/loopId ]))
(def RecurNode-defaults {:exprs [] :loopId "" })

(defn cis->RecurNode
  "CodedInputStream to RecurNode"
  [is]
  (->> (tag-map RecurNode-defaults
         (fn [tag index]
             (case index
               1 [:exprs (serdes.complex/cis->repeated ecis->Node is)]
               2 [:loopId (serdes.core/cis->String is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->RecurNode-record)))

(defn ecis->RecurNode
  "Embedded CodedInputStream to RecurNode"
  [is]
  (serdes.core/cis->embedded cis->RecurNode is))

(defn new-RecurNode
  "Creates a new instance from a map, similar to map->RecurNode except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::RecurNode-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::RecurNode-spec init))))]}
  (-> (merge RecurNode-defaults init)
      (cond-> (some? (get init :exprs)) (update :exprs #(map new-Node %)))
      (map->RecurNode-record)))

(defn pb->RecurNode
  "Protobuf to RecurNode"
  [input]
  (cis->RecurNode (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record RecurNode-meta {:type "clojure.rt.protobuf.bytecode.RecurNode" :decoder pb->RecurNode})

;-----------------------------------------------------------------------------
; IsInstanceNode
;-----------------------------------------------------------------------------
(defrecord IsInstanceNode-record [class target]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:class this) os)
    (serdes.core/write-embedded 2 (:target this) os))
  pb/TypeReflection
  (gettype [this]
    "clojure.rt.protobuf.bytecode.IsInstanceNode"))

(s/def :clojure.rt.protobuf.bytecode.IsInstanceNode/class string?)

(s/def ::IsInstanceNode-spec (s/keys :opt-un [:clojure.rt.protobuf.bytecode.IsInstanceNode/class ]))
(def IsInstanceNode-defaults {:class "" })

(defn cis->IsInstanceNode
  "CodedInputStream to IsInstanceNode"
  [is]
  (->> (tag-map IsInstanceNode-defaults
         (fn [tag index]
             (case index
               1 [:class (serdes.core/cis->String is)]
               2 [:target (ecis->Node is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->IsInstanceNode-record)))

(defn ecis->IsInstanceNode
  "Embedded CodedInputStream to IsInstanceNode"
  [is]
  (serdes.core/cis->embedded cis->IsInstanceNode is))

(defn new-IsInstanceNode
  "Creates a new instance from a map, similar to map->IsInstanceNode except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::IsInstanceNode-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::IsInstanceNode-spec init))))]}
  (-> (merge IsInstanceNode-defaults init)
      (cond-> (some? (get init :target)) (update :target new-Node))
      (map->IsInstanceNode-record)))

(defn pb->IsInstanceNode
  "Protobuf to IsInstanceNode"
  [input]
  (cis->IsInstanceNode (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record IsInstanceNode-meta {:type "clojure.rt.protobuf.bytecode.IsInstanceNode" :decoder pb->IsInstanceNode})

;-----------------------------------------------------------------------------
; MonitorExitNode
;-----------------------------------------------------------------------------
(defrecord MonitorExitNode-record [target]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-embedded 1 (:target this) os))
  pb/TypeReflection
  (gettype [this]
    "clojure.rt.protobuf.bytecode.MonitorExitNode"))

(s/def ::MonitorExitNode-spec (s/keys :opt-un []))
(def MonitorExitNode-defaults {})

(defn cis->MonitorExitNode
  "CodedInputStream to MonitorExitNode"
  [is]
  (->> (tag-map MonitorExitNode-defaults
         (fn [tag index]
             (case index
               1 [:target (ecis->Node is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->MonitorExitNode-record)))

(defn ecis->MonitorExitNode
  "Embedded CodedInputStream to MonitorExitNode"
  [is]
  (serdes.core/cis->embedded cis->MonitorExitNode is))

(defn new-MonitorExitNode
  "Creates a new instance from a map, similar to map->MonitorExitNode except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::MonitorExitNode-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::MonitorExitNode-spec init))))]}
  (-> (merge MonitorExitNode-defaults init)
      (cond-> (some? (get init :target)) (update :target new-Node))
      (map->MonitorExitNode-record)))

(defn pb->MonitorExitNode
  "Protobuf to MonitorExitNode"
  [input]
  (cis->MonitorExitNode (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record MonitorExitNode-meta {:type "clojure.rt.protobuf.bytecode.MonitorExitNode" :decoder pb->MonitorExitNode})

;-----------------------------------------------------------------------------
; CaseNode
;-----------------------------------------------------------------------------
(defrecord CaseNode-record [low testType high shift switchType isSkipCheck tests default thens mask test]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 3  {:optimize true} (:low this) os)
    (write-CaseNode-TestType 9  {:optimize true} (:testType this) os)
    (serdes.core/write-String 2  {:optimize true} (:high this) os)
    (serdes.core/write-Int32 5  {:optimize true} (:shift this) os)
    (write-CaseNode-SwitchType 7  {:optimize true} (:switchType this) os)
    (serdes.core/write-String 6  {:optimize true} (:isSkipCheck this) os)
    (serdes.complex/write-repeated serdes.core/write-embedded 10 (:tests this) os)
    (serdes.core/write-embedded 1 (:default this) os)
    (serdes.complex/write-repeated serdes.core/write-embedded 11 (:thens this) os)
    (serdes.core/write-Int32 4  {:optimize true} (:mask this) os)
    (serdes.core/write-embedded 8 (:test this) os))
  pb/TypeReflection
  (gettype [this]
    "clojure.rt.protobuf.bytecode.CaseNode"))

(s/def :clojure.rt.protobuf.bytecode.CaseNode/low string?)
(s/def :clojure.rt.protobuf.bytecode.CaseNode/testType (s/or :keyword keyword? :int int?))
(s/def :clojure.rt.protobuf.bytecode.CaseNode/high string?)
(s/def :clojure.rt.protobuf.bytecode.CaseNode/shift int?)
(s/def :clojure.rt.protobuf.bytecode.CaseNode/switchType (s/or :keyword keyword? :int int?))
(s/def :clojure.rt.protobuf.bytecode.CaseNode/isSkipCheck string?)



(s/def :clojure.rt.protobuf.bytecode.CaseNode/mask int?)

(s/def ::CaseNode-spec (s/keys :opt-un [:clojure.rt.protobuf.bytecode.CaseNode/low :clojure.rt.protobuf.bytecode.CaseNode/testType :clojure.rt.protobuf.bytecode.CaseNode/high :clojure.rt.protobuf.bytecode.CaseNode/shift :clojure.rt.protobuf.bytecode.CaseNode/switchType :clojure.rt.protobuf.bytecode.CaseNode/isSkipCheck :clojure.rt.protobuf.bytecode.CaseNode/mask ]))
(def CaseNode-defaults {:low "" :testType CaseNode-TestType-default :high "" :shift 0 :switchType CaseNode-SwitchType-default :isSkipCheck "" :tests [] :thens [] :mask 0 })

(defn cis->CaseNode
  "CodedInputStream to CaseNode"
  [is]
  (->> (tag-map CaseNode-defaults
         (fn [tag index]
             (case index
               3 [:low (serdes.core/cis->String is)]
               9 [:testType (cis->CaseNode-TestType is)]
               2 [:high (serdes.core/cis->String is)]
               5 [:shift (serdes.core/cis->Int32 is)]
               7 [:switchType (cis->CaseNode-SwitchType is)]
               6 [:isSkipCheck (serdes.core/cis->String is)]
               10 [:tests (serdes.complex/cis->repeated ecis->Node is)]
               1 [:default (ecis->Node is)]
               11 [:thens (serdes.complex/cis->repeated ecis->Node is)]
               4 [:mask (serdes.core/cis->Int32 is)]
               8 [:test (ecis->Node is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->CaseNode-record)))

(defn ecis->CaseNode
  "Embedded CodedInputStream to CaseNode"
  [is]
  (serdes.core/cis->embedded cis->CaseNode is))

(defn new-CaseNode
  "Creates a new instance from a map, similar to map->CaseNode except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::CaseNode-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::CaseNode-spec init))))]}
  (-> (merge CaseNode-defaults init)
      (cond-> (some? (get init :default)) (update :default new-Node))
      (cond-> (some? (get init :test)) (update :test new-Node))
      (cond-> (some? (get init :tests)) (update :tests #(map new-Node %)))
      (cond-> (some? (get init :thens)) (update :thens #(map new-Node %)))
      (map->CaseNode-record)))

(defn pb->CaseNode
  "Protobuf to CaseNode"
  [input]
  (cis->CaseNode (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record CaseNode-meta {:type "clojure.rt.protobuf.bytecode.CaseNode" :decoder pb->CaseNode})

;-----------------------------------------------------------------------------
; CaseTestNode
;-----------------------------------------------------------------------------
(defrecord CaseTestNode-record [hash test]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-Int32 1  {:optimize true} (:hash this) os)
    (serdes.core/write-embedded 2 (:test this) os))
  pb/TypeReflection
  (gettype [this]
    "clojure.rt.protobuf.bytecode.CaseTestNode"))

(s/def :clojure.rt.protobuf.bytecode.CaseTestNode/hash int?)

(s/def ::CaseTestNode-spec (s/keys :opt-un [:clojure.rt.protobuf.bytecode.CaseTestNode/hash ]))
(def CaseTestNode-defaults {:hash 0 })

(defn cis->CaseTestNode
  "CodedInputStream to CaseTestNode"
  [is]
  (->> (tag-map CaseTestNode-defaults
         (fn [tag index]
             (case index
               1 [:hash (serdes.core/cis->Int32 is)]
               2 [:test (ecis->Node is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->CaseTestNode-record)))

(defn ecis->CaseTestNode
  "Embedded CodedInputStream to CaseTestNode"
  [is]
  (serdes.core/cis->embedded cis->CaseTestNode is))

(defn new-CaseTestNode
  "Creates a new instance from a map, similar to map->CaseTestNode except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::CaseTestNode-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::CaseTestNode-spec init))))]}
  (-> (merge CaseTestNode-defaults init)
      (cond-> (some? (get init :test)) (update :test new-Node))
      (map->CaseTestNode-record)))

(defn pb->CaseTestNode
  "Protobuf to CaseTestNode"
  [input]
  (cis->CaseTestNode (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record CaseTestNode-meta {:type "clojure.rt.protobuf.bytecode.CaseTestNode" :decoder pb->CaseTestNode})

;-----------------------------------------------------------------------------
; IfNode
;-----------------------------------------------------------------------------
(defrecord IfNode-record [else test then]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-embedded 1 (:else this) os)
    (serdes.core/write-embedded 2 (:test this) os)
    (serdes.core/write-embedded 3 (:then this) os))
  pb/TypeReflection
  (gettype [this]
    "clojure.rt.protobuf.bytecode.IfNode"))

(s/def ::IfNode-spec (s/keys :opt-un []))
(def IfNode-defaults {})

(defn cis->IfNode
  "CodedInputStream to IfNode"
  [is]
  (->> (tag-map IfNode-defaults
         (fn [tag index]
             (case index
               1 [:else (ecis->Node is)]
               2 [:test (ecis->Node is)]
               3 [:then (ecis->Node is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->IfNode-record)))

(defn ecis->IfNode
  "Embedded CodedInputStream to IfNode"
  [is]
  (serdes.core/cis->embedded cis->IfNode is))

(defn new-IfNode
  "Creates a new instance from a map, similar to map->IfNode except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::IfNode-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::IfNode-spec init))))]}
  (-> (merge IfNode-defaults init)
      (cond-> (some? (get init :else)) (update :else new-Node))
      (cond-> (some? (get init :test)) (update :test new-Node))
      (cond-> (some? (get init :then)) (update :then new-Node))
      (map->IfNode-record)))

(defn pb->IfNode
  "Protobuf to IfNode"
  [input]
  (cis->IfNode (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record IfNode-meta {:type "clojure.rt.protobuf.bytecode.IfNode" :decoder pb->IfNode})

;-----------------------------------------------------------------------------
; ConstNode
;-----------------------------------------------------------------------------
(defrecord ConstNode-record [isLiteral meta type val]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-Bool 1  {:optimize true} (:isLiteral this) os)
    (serdes.core/write-embedded 2 (:meta this) os)
    (write-ConstNode-ConstType 3  {:optimize true} (:type this) os)
    (serdes.core/write-String 4  {:optimize true} (:val this) os))
  pb/TypeReflection
  (gettype [this]
    "clojure.rt.protobuf.bytecode.ConstNode"))

(s/def :clojure.rt.protobuf.bytecode.ConstNode/isLiteral boolean?)

(s/def :clojure.rt.protobuf.bytecode.ConstNode/type (s/or :keyword keyword? :int int?))
(s/def :clojure.rt.protobuf.bytecode.ConstNode/val string?)
(s/def ::ConstNode-spec (s/keys :opt-un [:clojure.rt.protobuf.bytecode.ConstNode/isLiteral :clojure.rt.protobuf.bytecode.ConstNode/type :clojure.rt.protobuf.bytecode.ConstNode/val ]))
(def ConstNode-defaults {:isLiteral false :type ConstNode-ConstType-default :val "" })

(defn cis->ConstNode
  "CodedInputStream to ConstNode"
  [is]
  (->> (tag-map ConstNode-defaults
         (fn [tag index]
             (case index
               1 [:isLiteral (serdes.core/cis->Bool is)]
               2 [:meta (ecis->Node is)]
               3 [:type (cis->ConstNode-ConstType is)]
               4 [:val (serdes.core/cis->String is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->ConstNode-record)))

(defn ecis->ConstNode
  "Embedded CodedInputStream to ConstNode"
  [is]
  (serdes.core/cis->embedded cis->ConstNode is))

(defn new-ConstNode
  "Creates a new instance from a map, similar to map->ConstNode except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::ConstNode-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::ConstNode-spec init))))]}
  (-> (merge ConstNode-defaults init)
      (cond-> (some? (get init :meta)) (update :meta new-Node))
      (map->ConstNode-record)))

(defn pb->ConstNode
  "Protobuf to ConstNode"
  [input]
  (cis->ConstNode (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record ConstNode-meta {:type "clojure.rt.protobuf.bytecode.ConstNode" :decoder pb->ConstNode})

;-----------------------------------------------------------------------------
; QuoteNode
;-----------------------------------------------------------------------------
(defrecord QuoteNode-record [expr isLiteral]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-embedded 1 (:expr this) os)
    (serdes.core/write-Bool 2  {:optimize true} (:isLiteral this) os))
  pb/TypeReflection
  (gettype [this]
    "clojure.rt.protobuf.bytecode.QuoteNode"))

(s/def :clojure.rt.protobuf.bytecode.QuoteNode/isLiteral boolean?)
(s/def ::QuoteNode-spec (s/keys :opt-un [:clojure.rt.protobuf.bytecode.QuoteNode/isLiteral ]))
(def QuoteNode-defaults {:isLiteral false })

(defn cis->QuoteNode
  "CodedInputStream to QuoteNode"
  [is]
  (->> (tag-map QuoteNode-defaults
         (fn [tag index]
             (case index
               1 [:expr (ecis->Node is)]
               2 [:isLiteral (serdes.core/cis->Bool is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->QuoteNode-record)))

(defn ecis->QuoteNode
  "Embedded CodedInputStream to QuoteNode"
  [is]
  (serdes.core/cis->embedded cis->QuoteNode is))

(defn new-QuoteNode
  "Creates a new instance from a map, similar to map->QuoteNode except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::QuoteNode-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::QuoteNode-spec init))))]}
  (-> (merge QuoteNode-defaults init)
      (cond-> (some? (get init :expr)) (update :expr new-Node))
      (map->QuoteNode-record)))

(defn pb->QuoteNode
  "Protobuf to QuoteNode"
  [input]
  (cis->QuoteNode (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record QuoteNode-meta {:type "clojure.rt.protobuf.bytecode.QuoteNode" :decoder pb->QuoteNode})

;-----------------------------------------------------------------------------
; LetNode
;-----------------------------------------------------------------------------
(defrecord LetNode-record [bindings body]
  pb/Writer
  (serialize [this os]
    (serdes.complex/write-repeated serdes.core/write-embedded 1 (:bindings this) os)
    (serdes.core/write-embedded 2 (:body this) os))
  pb/TypeReflection
  (gettype [this]
    "clojure.rt.protobuf.bytecode.LetNode"))

(s/def ::LetNode-spec (s/keys :opt-un []))
(def LetNode-defaults {:bindings [] })

(defn cis->LetNode
  "CodedInputStream to LetNode"
  [is]
  (->> (tag-map LetNode-defaults
         (fn [tag index]
             (case index
               1 [:bindings (serdes.complex/cis->repeated ecis->Node is)]
               2 [:body (ecis->Node is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->LetNode-record)))

(defn ecis->LetNode
  "Embedded CodedInputStream to LetNode"
  [is]
  (serdes.core/cis->embedded cis->LetNode is))

(defn new-LetNode
  "Creates a new instance from a map, similar to map->LetNode except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::LetNode-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::LetNode-spec init))))]}
  (-> (merge LetNode-defaults init)
      (cond-> (some? (get init :bindings)) (update :bindings #(map new-Node %)))
      (cond-> (some? (get init :body)) (update :body new-Node))
      (map->LetNode-record)))

(defn pb->LetNode
  "Protobuf to LetNode"
  [input]
  (cis->LetNode (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record LetNode-meta {:type "clojure.rt.protobuf.bytecode.LetNode" :decoder pb->LetNode})

;-----------------------------------------------------------------------------
; Environment
;-----------------------------------------------------------------------------
(defrecord Environment-record [context locals ns column line endColumn endLine file]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:context this) os)
    (serdes.complex/write-repeated serdes.core/write-String 2 (:locals this) os)
    (serdes.core/write-String 3  {:optimize true} (:ns this) os)
    (serdes.core/write-Int32 4  {:optimize true} (:column this) os)
    (serdes.core/write-Int32 5  {:optimize true} (:line this) os)
    (serdes.core/write-Int32 6  {:optimize true} (:endColumn this) os)
    (serdes.core/write-Int32 7  {:optimize true} (:endLine this) os)
    (serdes.core/write-String 8  {:optimize true} (:file this) os))
  pb/TypeReflection
  (gettype [this]
    "clojure.rt.protobuf.bytecode.Environment"))

(s/def :clojure.rt.protobuf.bytecode.Environment/context string?)
(s/def :clojure.rt.protobuf.bytecode.Environment/locals (s/every string?))
(s/def :clojure.rt.protobuf.bytecode.Environment/ns string?)
(s/def :clojure.rt.protobuf.bytecode.Environment/column int?)
(s/def :clojure.rt.protobuf.bytecode.Environment/line int?)
(s/def :clojure.rt.protobuf.bytecode.Environment/endColumn int?)
(s/def :clojure.rt.protobuf.bytecode.Environment/endLine int?)
(s/def :clojure.rt.protobuf.bytecode.Environment/file string?)
(s/def ::Environment-spec (s/keys :opt-un [:clojure.rt.protobuf.bytecode.Environment/context :clojure.rt.protobuf.bytecode.Environment/locals :clojure.rt.protobuf.bytecode.Environment/ns :clojure.rt.protobuf.bytecode.Environment/column :clojure.rt.protobuf.bytecode.Environment/line :clojure.rt.protobuf.bytecode.Environment/endColumn :clojure.rt.protobuf.bytecode.Environment/endLine :clojure.rt.protobuf.bytecode.Environment/file ]))
(def Environment-defaults {:context "" :locals [] :ns "" :column 0 :line 0 :endColumn 0 :endLine 0 :file "" })

(defn cis->Environment
  "CodedInputStream to Environment"
  [is]
  (->> (tag-map Environment-defaults
         (fn [tag index]
             (case index
               1 [:context (serdes.core/cis->String is)]
               2 [:locals (serdes.complex/cis->repeated serdes.core/cis->String is)]
               3 [:ns (serdes.core/cis->String is)]
               4 [:column (serdes.core/cis->Int32 is)]
               5 [:line (serdes.core/cis->Int32 is)]
               6 [:endColumn (serdes.core/cis->Int32 is)]
               7 [:endLine (serdes.core/cis->Int32 is)]
               8 [:file (serdes.core/cis->String is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->Environment-record)))

(defn ecis->Environment
  "Embedded CodedInputStream to Environment"
  [is]
  (serdes.core/cis->embedded cis->Environment is))

(defn new-Environment
  "Creates a new instance from a map, similar to map->Environment except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Environment-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Environment-spec init))))]}
  (-> (merge Environment-defaults init)
      (map->Environment-record)))

(defn pb->Environment
  "Protobuf to Environment"
  [input]
  (cis->Environment (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Environment-meta {:type "clojure.rt.protobuf.bytecode.Environment" :decoder pb->Environment})

;-----------------------------------------------------------------------------
; StaticFieldNode
;-----------------------------------------------------------------------------
(defrecord StaticFieldNode-record [isAssignable class field]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-Bool 1  {:optimize true} (:isAssignable this) os)
    (serdes.core/write-String 2  {:optimize true} (:class this) os)
    (serdes.core/write-String 3  {:optimize true} (:field this) os))
  pb/TypeReflection
  (gettype [this]
    "clojure.rt.protobuf.bytecode.StaticFieldNode"))

(s/def :clojure.rt.protobuf.bytecode.StaticFieldNode/isAssignable boolean?)
(s/def :clojure.rt.protobuf.bytecode.StaticFieldNode/class string?)
(s/def :clojure.rt.protobuf.bytecode.StaticFieldNode/field string?)
(s/def ::StaticFieldNode-spec (s/keys :opt-un [:clojure.rt.protobuf.bytecode.StaticFieldNode/isAssignable :clojure.rt.protobuf.bytecode.StaticFieldNode/class :clojure.rt.protobuf.bytecode.StaticFieldNode/field ]))
(def StaticFieldNode-defaults {:isAssignable false :class "" :field "" })

(defn cis->StaticFieldNode
  "CodedInputStream to StaticFieldNode"
  [is]
  (->> (tag-map StaticFieldNode-defaults
         (fn [tag index]
             (case index
               1 [:isAssignable (serdes.core/cis->Bool is)]
               2 [:class (serdes.core/cis->String is)]
               3 [:field (serdes.core/cis->String is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->StaticFieldNode-record)))

(defn ecis->StaticFieldNode
  "Embedded CodedInputStream to StaticFieldNode"
  [is]
  (serdes.core/cis->embedded cis->StaticFieldNode is))

(defn new-StaticFieldNode
  "Creates a new instance from a map, similar to map->StaticFieldNode except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::StaticFieldNode-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::StaticFieldNode-spec init))))]}
  (-> (merge StaticFieldNode-defaults init)
      (map->StaticFieldNode-record)))

(defn pb->StaticFieldNode
  "Protobuf to StaticFieldNode"
  [input]
  (cis->StaticFieldNode (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record StaticFieldNode-meta {:type "clojure.rt.protobuf.bytecode.StaticFieldNode" :decoder pb->StaticFieldNode})

;-----------------------------------------------------------------------------
; InvokeNode
;-----------------------------------------------------------------------------
(defrecord InvokeNode-record [args fn meta]
  pb/Writer
  (serialize [this os]
    (serdes.complex/write-repeated serdes.core/write-embedded 1 (:args this) os)
    (serdes.core/write-embedded 2 (:fn this) os)
    (serdes.core/write-String 3  {:optimize true} (:meta this) os))
  pb/TypeReflection
  (gettype [this]
    "clojure.rt.protobuf.bytecode.InvokeNode"))

(s/def :clojure.rt.protobuf.bytecode.InvokeNode/meta string?)
(s/def ::InvokeNode-spec (s/keys :opt-un [:clojure.rt.protobuf.bytecode.InvokeNode/meta ]))
(def InvokeNode-defaults {:args [] :meta "" })

(defn cis->InvokeNode
  "CodedInputStream to InvokeNode"
  [is]
  (->> (tag-map InvokeNode-defaults
         (fn [tag index]
             (case index
               1 [:args (serdes.complex/cis->repeated ecis->Node is)]
               2 [:fn (ecis->Node is)]
               3 [:meta (serdes.core/cis->String is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->InvokeNode-record)))

(defn ecis->InvokeNode
  "Embedded CodedInputStream to InvokeNode"
  [is]
  (serdes.core/cis->embedded cis->InvokeNode is))

(defn new-InvokeNode
  "Creates a new instance from a map, similar to map->InvokeNode except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::InvokeNode-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::InvokeNode-spec init))))]}
  (-> (merge InvokeNode-defaults init)
      (cond-> (some? (get init :args)) (update :args #(map new-Node %)))
      (cond-> (some? (get init :fn)) (update :fn new-Node))
      (map->InvokeNode-record)))

(defn pb->InvokeNode
  "Protobuf to InvokeNode"
  [input]
  (cis->InvokeNode (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record InvokeNode-meta {:type "clojure.rt.protobuf.bytecode.InvokeNode" :decoder pb->InvokeNode})

;-----------------------------------------------------------------------------
; MemoryManagementGuidance
;-----------------------------------------------------------------------------
(defrecord MemoryManagementGuidance-record [variableName requiredRefCountChange]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:variableName this) os)
    (serdes.core/write-Int32 2  {:optimize true} (:requiredRefCountChange this) os))
  pb/TypeReflection
  (gettype [this]
    "clojure.rt.protobuf.bytecode.MemoryManagementGuidance"))

(s/def :clojure.rt.protobuf.bytecode.MemoryManagementGuidance/variableName string?)
(s/def :clojure.rt.protobuf.bytecode.MemoryManagementGuidance/requiredRefCountChange int?)
(s/def ::MemoryManagementGuidance-spec (s/keys :opt-un [:clojure.rt.protobuf.bytecode.MemoryManagementGuidance/variableName :clojure.rt.protobuf.bytecode.MemoryManagementGuidance/requiredRefCountChange ]))
(def MemoryManagementGuidance-defaults {:variableName "" :requiredRefCountChange 0 })

(defn cis->MemoryManagementGuidance
  "CodedInputStream to MemoryManagementGuidance"
  [is]
  (->> (tag-map MemoryManagementGuidance-defaults
         (fn [tag index]
             (case index
               1 [:variableName (serdes.core/cis->String is)]
               2 [:requiredRefCountChange (serdes.core/cis->Int32 is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->MemoryManagementGuidance-record)))

(defn ecis->MemoryManagementGuidance
  "Embedded CodedInputStream to MemoryManagementGuidance"
  [is]
  (serdes.core/cis->embedded cis->MemoryManagementGuidance is))

(defn new-MemoryManagementGuidance
  "Creates a new instance from a map, similar to map->MemoryManagementGuidance except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::MemoryManagementGuidance-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::MemoryManagementGuidance-spec init))))]}
  (-> (merge MemoryManagementGuidance-defaults init)
      (map->MemoryManagementGuidance-record)))

(defn pb->MemoryManagementGuidance
  "Protobuf to MemoryManagementGuidance"
  [input]
  (cis->MemoryManagementGuidance (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record MemoryManagementGuidance-meta {:type "clojure.rt.protobuf.bytecode.MemoryManagementGuidance" :decoder pb->MemoryManagementGuidance})

;-----------------------------------------------------------------------------
; TryNode
;-----------------------------------------------------------------------------
(defrecord TryNode-record [body catches finally]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-embedded 1 (:body this) os)
    (serdes.complex/write-repeated serdes.core/write-embedded 2 (:catches this) os)
    (serdes.core/write-embedded 3 (:finally this) os))
  pb/TypeReflection
  (gettype [this]
    "clojure.rt.protobuf.bytecode.TryNode"))

(s/def ::TryNode-spec (s/keys :opt-un []))
(def TryNode-defaults {:catches [] })

(defn cis->TryNode
  "CodedInputStream to TryNode"
  [is]
  (->> (tag-map TryNode-defaults
         (fn [tag index]
             (case index
               1 [:body (ecis->Node is)]
               2 [:catches (serdes.complex/cis->repeated ecis->Node is)]
               3 [:finally (ecis->Node is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->TryNode-record)))

(defn ecis->TryNode
  "Embedded CodedInputStream to TryNode"
  [is]
  (serdes.core/cis->embedded cis->TryNode is))

(defn new-TryNode
  "Creates a new instance from a map, similar to map->TryNode except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::TryNode-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::TryNode-spec init))))]}
  (-> (merge TryNode-defaults init)
      (cond-> (some? (get init :body)) (update :body new-Node))
      (cond-> (some? (get init :catches)) (update :catches #(map new-Node %)))
      (cond-> (some? (get init :finally)) (update :finally new-Node))
      (map->TryNode-record)))

(defn pb->TryNode
  "Protobuf to TryNode"
  [input]
  (cis->TryNode (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record TryNode-meta {:type "clojure.rt.protobuf.bytecode.TryNode" :decoder pb->TryNode})

;-----------------------------------------------------------------------------
; KeywordInvokeNode
;-----------------------------------------------------------------------------
(defrecord KeywordInvokeNode-record [keyword target]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-embedded 1 (:keyword this) os)
    (serdes.core/write-embedded 2 (:target this) os))
  pb/TypeReflection
  (gettype [this]
    "clojure.rt.protobuf.bytecode.KeywordInvokeNode"))

(s/def ::KeywordInvokeNode-spec (s/keys :opt-un []))
(def KeywordInvokeNode-defaults {})

(defn cis->KeywordInvokeNode
  "CodedInputStream to KeywordInvokeNode"
  [is]
  (->> (tag-map KeywordInvokeNode-defaults
         (fn [tag index]
             (case index
               1 [:keyword (ecis->Node is)]
               2 [:target (ecis->Node is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->KeywordInvokeNode-record)))

(defn ecis->KeywordInvokeNode
  "Embedded CodedInputStream to KeywordInvokeNode"
  [is]
  (serdes.core/cis->embedded cis->KeywordInvokeNode is))

(defn new-KeywordInvokeNode
  "Creates a new instance from a map, similar to map->KeywordInvokeNode except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::KeywordInvokeNode-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::KeywordInvokeNode-spec init))))]}
  (-> (merge KeywordInvokeNode-defaults init)
      (cond-> (some? (get init :keyword)) (update :keyword new-Node))
      (cond-> (some? (get init :target)) (update :target new-Node))
      (map->KeywordInvokeNode-record)))

(defn pb->KeywordInvokeNode
  "Protobuf to KeywordInvokeNode"
  [input]
  (cis->KeywordInvokeNode (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record KeywordInvokeNode-meta {:type "clojure.rt.protobuf.bytecode.KeywordInvokeNode" :decoder pb->KeywordInvokeNode})

;-----------------------------------------------------------------------------
; DeftypeNode
;-----------------------------------------------------------------------------
(defrecord DeftypeNode-record [className fields interfaces methods name]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:className this) os)
    (serdes.complex/write-repeated serdes.core/write-embedded 2 (:fields this) os)
    (serdes.complex/write-repeated serdes.core/write-String 3 (:interfaces this) os)
    (serdes.complex/write-repeated serdes.core/write-embedded 4 (:methods this) os)
    (serdes.core/write-String 5  {:optimize true} (:name this) os))
  pb/TypeReflection
  (gettype [this]
    "clojure.rt.protobuf.bytecode.DeftypeNode"))

(s/def :clojure.rt.protobuf.bytecode.DeftypeNode/className string?)

(s/def :clojure.rt.protobuf.bytecode.DeftypeNode/interfaces (s/every string?))

(s/def :clojure.rt.protobuf.bytecode.DeftypeNode/name string?)
(s/def ::DeftypeNode-spec (s/keys :opt-un [:clojure.rt.protobuf.bytecode.DeftypeNode/className :clojure.rt.protobuf.bytecode.DeftypeNode/interfaces :clojure.rt.protobuf.bytecode.DeftypeNode/name ]))
(def DeftypeNode-defaults {:className "" :fields [] :interfaces [] :methods [] :name "" })

(defn cis->DeftypeNode
  "CodedInputStream to DeftypeNode"
  [is]
  (->> (tag-map DeftypeNode-defaults
         (fn [tag index]
             (case index
               1 [:className (serdes.core/cis->String is)]
               2 [:fields (serdes.complex/cis->repeated ecis->Node is)]
               3 [:interfaces (serdes.complex/cis->repeated serdes.core/cis->String is)]
               4 [:methods (serdes.complex/cis->repeated ecis->Node is)]
               5 [:name (serdes.core/cis->String is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->DeftypeNode-record)))

(defn ecis->DeftypeNode
  "Embedded CodedInputStream to DeftypeNode"
  [is]
  (serdes.core/cis->embedded cis->DeftypeNode is))

(defn new-DeftypeNode
  "Creates a new instance from a map, similar to map->DeftypeNode except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::DeftypeNode-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::DeftypeNode-spec init))))]}
  (-> (merge DeftypeNode-defaults init)
      (cond-> (some? (get init :fields)) (update :fields #(map new-Node %)))
      (cond-> (some? (get init :methods)) (update :methods #(map new-Node %)))
      (map->DeftypeNode-record)))

(defn pb->DeftypeNode
  "Protobuf to DeftypeNode"
  [input]
  (cis->DeftypeNode (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record DeftypeNode-meta {:type "clojure.rt.protobuf.bytecode.DeftypeNode" :decoder pb->DeftypeNode})

;-----------------------------------------------------------------------------
; MapNode
;-----------------------------------------------------------------------------
(defrecord MapNode-record [keys vals]
  pb/Writer
  (serialize [this os]
    (serdes.complex/write-repeated serdes.core/write-embedded 1 (:keys this) os)
    (serdes.complex/write-repeated serdes.core/write-embedded 2 (:vals this) os))
  pb/TypeReflection
  (gettype [this]
    "clojure.rt.protobuf.bytecode.MapNode"))

(s/def ::MapNode-spec (s/keys :opt-un []))
(def MapNode-defaults {:keys [] :vals [] })

(defn cis->MapNode
  "CodedInputStream to MapNode"
  [is]
  (->> (tag-map MapNode-defaults
         (fn [tag index]
             (case index
               1 [:keys (serdes.complex/cis->repeated ecis->Node is)]
               2 [:vals (serdes.complex/cis->repeated ecis->Node is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->MapNode-record)))

(defn ecis->MapNode
  "Embedded CodedInputStream to MapNode"
  [is]
  (serdes.core/cis->embedded cis->MapNode is))

(defn new-MapNode
  "Creates a new instance from a map, similar to map->MapNode except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::MapNode-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::MapNode-spec init))))]}
  (-> (merge MapNode-defaults init)
      (cond-> (some? (get init :keys)) (update :keys #(map new-Node %)))
      (cond-> (some? (get init :vals)) (update :vals #(map new-Node %)))
      (map->MapNode-record)))

(defn pb->MapNode
  "Protobuf to MapNode"
  [input]
  (cis->MapNode (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record MapNode-meta {:type "clojure.rt.protobuf.bytecode.MapNode" :decoder pb->MapNode})

;-----------------------------------------------------------------------------
; HostInteropNode
;-----------------------------------------------------------------------------
(defrecord HostInteropNode-record [isAssignable mOrF target]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-Bool 1  {:optimize true} (:isAssignable this) os)
    (serdes.core/write-String 2  {:optimize true} (:mOrF this) os)
    (serdes.core/write-embedded 3 (:target this) os))
  pb/TypeReflection
  (gettype [this]
    "clojure.rt.protobuf.bytecode.HostInteropNode"))

(s/def :clojure.rt.protobuf.bytecode.HostInteropNode/isAssignable boolean?)
(s/def :clojure.rt.protobuf.bytecode.HostInteropNode/mOrF string?)

(s/def ::HostInteropNode-spec (s/keys :opt-un [:clojure.rt.protobuf.bytecode.HostInteropNode/isAssignable :clojure.rt.protobuf.bytecode.HostInteropNode/mOrF ]))
(def HostInteropNode-defaults {:isAssignable false :mOrF "" })

(defn cis->HostInteropNode
  "CodedInputStream to HostInteropNode"
  [is]
  (->> (tag-map HostInteropNode-defaults
         (fn [tag index]
             (case index
               1 [:isAssignable (serdes.core/cis->Bool is)]
               2 [:mOrF (serdes.core/cis->String is)]
               3 [:target (ecis->Node is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->HostInteropNode-record)))

(defn ecis->HostInteropNode
  "Embedded CodedInputStream to HostInteropNode"
  [is]
  (serdes.core/cis->embedded cis->HostInteropNode is))

(defn new-HostInteropNode
  "Creates a new instance from a map, similar to map->HostInteropNode except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::HostInteropNode-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::HostInteropNode-spec init))))]}
  (-> (merge HostInteropNode-defaults init)
      (cond-> (some? (get init :target)) (update :target new-Node))
      (map->HostInteropNode-record)))

(defn pb->HostInteropNode
  "Protobuf to HostInteropNode"
  [input]
  (cis->HostInteropNode (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record HostInteropNode-meta {:type "clojure.rt.protobuf.bytecode.HostInteropNode" :decoder pb->HostInteropNode})

;-----------------------------------------------------------------------------
; WithMetaNode
;-----------------------------------------------------------------------------
(defrecord WithMetaNode-record [expr meta]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-embedded 1 (:expr this) os)
    (serdes.core/write-embedded 2 (:meta this) os))
  pb/TypeReflection
  (gettype [this]
    "clojure.rt.protobuf.bytecode.WithMetaNode"))

(s/def ::WithMetaNode-spec (s/keys :opt-un []))
(def WithMetaNode-defaults {})

(defn cis->WithMetaNode
  "CodedInputStream to WithMetaNode"
  [is]
  (->> (tag-map WithMetaNode-defaults
         (fn [tag index]
             (case index
               1 [:expr (ecis->Node is)]
               2 [:meta (ecis->Node is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->WithMetaNode-record)))

(defn ecis->WithMetaNode
  "Embedded CodedInputStream to WithMetaNode"
  [is]
  (serdes.core/cis->embedded cis->WithMetaNode is))

(defn new-WithMetaNode
  "Creates a new instance from a map, similar to map->WithMetaNode except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::WithMetaNode-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::WithMetaNode-spec init))))]}
  (-> (merge WithMetaNode-defaults init)
      (cond-> (some? (get init :expr)) (update :expr new-Node))
      (cond-> (some? (get init :meta)) (update :meta new-Node))
      (map->WithMetaNode-record)))

(defn pb->WithMetaNode
  "Protobuf to WithMetaNode"
  [input]
  (cis->WithMetaNode (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record WithMetaNode-meta {:type "clojure.rt.protobuf.bytecode.WithMetaNode" :decoder pb->WithMetaNode})

;-----------------------------------------------------------------------------
; Programme
;-----------------------------------------------------------------------------
(defrecord Programme-record [nodes]
  pb/Writer
  (serialize [this os]
    (serdes.complex/write-repeated serdes.core/write-embedded 1 (:nodes this) os))
  pb/TypeReflection
  (gettype [this]
    "clojure.rt.protobuf.bytecode.Programme"))

(s/def ::Programme-spec (s/keys :opt-un []))
(def Programme-defaults {:nodes [] })

(defn cis->Programme
  "CodedInputStream to Programme"
  [is]
  (->> (tag-map Programme-defaults
         (fn [tag index]
             (case index
               1 [:nodes (serdes.complex/cis->repeated ecis->Node is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->Programme-record)))

(defn ecis->Programme
  "Embedded CodedInputStream to Programme"
  [is]
  (serdes.core/cis->embedded cis->Programme is))

(defn new-Programme
  "Creates a new instance from a map, similar to map->Programme except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Programme-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Programme-spec init))))]}
  (-> (merge Programme-defaults init)
      (cond-> (some? (get init :nodes)) (update :nodes #(map new-Node %)))
      (map->Programme-record)))

(defn pb->Programme
  "Protobuf to Programme"
  [input]
  (cis->Programme (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Programme-meta {:type "clojure.rt.protobuf.bytecode.Programme" :decoder pb->Programme})

;-----------------------------------------------------------------------------
; StaticCallNode
;-----------------------------------------------------------------------------
(defrecord StaticCallNode-record [args class method isValidated]
  pb/Writer
  (serialize [this os]
    (serdes.complex/write-repeated serdes.core/write-embedded 1 (:args this) os)
    (serdes.core/write-String 2  {:optimize true} (:class this) os)
    (serdes.core/write-String 3  {:optimize true} (:method this) os)
    (serdes.core/write-Bool 4  {:optimize true} (:isValidated this) os))
  pb/TypeReflection
  (gettype [this]
    "clojure.rt.protobuf.bytecode.StaticCallNode"))

(s/def :clojure.rt.protobuf.bytecode.StaticCallNode/class string?)
(s/def :clojure.rt.protobuf.bytecode.StaticCallNode/method string?)
(s/def :clojure.rt.protobuf.bytecode.StaticCallNode/isValidated boolean?)
(s/def ::StaticCallNode-spec (s/keys :opt-un [:clojure.rt.protobuf.bytecode.StaticCallNode/class :clojure.rt.protobuf.bytecode.StaticCallNode/method :clojure.rt.protobuf.bytecode.StaticCallNode/isValidated ]))
(def StaticCallNode-defaults {:args [] :class "" :method "" :isValidated false })

(defn cis->StaticCallNode
  "CodedInputStream to StaticCallNode"
  [is]
  (->> (tag-map StaticCallNode-defaults
         (fn [tag index]
             (case index
               1 [:args (serdes.complex/cis->repeated ecis->Node is)]
               2 [:class (serdes.core/cis->String is)]
               3 [:method (serdes.core/cis->String is)]
               4 [:isValidated (serdes.core/cis->Bool is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->StaticCallNode-record)))

(defn ecis->StaticCallNode
  "Embedded CodedInputStream to StaticCallNode"
  [is]
  (serdes.core/cis->embedded cis->StaticCallNode is))

(defn new-StaticCallNode
  "Creates a new instance from a map, similar to map->StaticCallNode except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::StaticCallNode-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::StaticCallNode-spec init))))]}
  (-> (merge StaticCallNode-defaults init)
      (cond-> (some? (get init :args)) (update :args #(map new-Node %)))
      (map->StaticCallNode-record)))

(defn pb->StaticCallNode
  "Protobuf to StaticCallNode"
  [input]
  (cis->StaticCallNode (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record StaticCallNode-meta {:type "clojure.rt.protobuf.bytecode.StaticCallNode" :decoder pb->StaticCallNode})

;-----------------------------------------------------------------------------
; LoopNode
;-----------------------------------------------------------------------------
(defrecord LoopNode-record [bindings body loopId]
  pb/Writer
  (serialize [this os]
    (serdes.complex/write-repeated serdes.core/write-embedded 1 (:bindings this) os)
    (serdes.core/write-embedded 2 (:body this) os)
    (serdes.core/write-String 3  {:optimize true} (:loopId this) os))
  pb/TypeReflection
  (gettype [this]
    "clojure.rt.protobuf.bytecode.LoopNode"))

(s/def :clojure.rt.protobuf.bytecode.LoopNode/loopId string?)
(s/def ::LoopNode-spec (s/keys :opt-un [:clojure.rt.protobuf.bytecode.LoopNode/loopId ]))
(def LoopNode-defaults {:bindings [] :loopId "" })

(defn cis->LoopNode
  "CodedInputStream to LoopNode"
  [is]
  (->> (tag-map LoopNode-defaults
         (fn [tag index]
             (case index
               1 [:bindings (serdes.complex/cis->repeated ecis->Node is)]
               2 [:body (ecis->Node is)]
               3 [:loopId (serdes.core/cis->String is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->LoopNode-record)))

(defn ecis->LoopNode
  "Embedded CodedInputStream to LoopNode"
  [is]
  (serdes.core/cis->embedded cis->LoopNode is))

(defn new-LoopNode
  "Creates a new instance from a map, similar to map->LoopNode except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::LoopNode-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::LoopNode-spec init))))]}
  (-> (merge LoopNode-defaults init)
      (cond-> (some? (get init :bindings)) (update :bindings #(map new-Node %)))
      (cond-> (some? (get init :body)) (update :body new-Node))
      (map->LoopNode-record)))

(defn pb->LoopNode
  "Protobuf to LoopNode"
  [input]
  (cis->LoopNode (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record LoopNode-meta {:type "clojure.rt.protobuf.bytecode.LoopNode" :decoder pb->LoopNode})

;-----------------------------------------------------------------------------
; ReifyNode
;-----------------------------------------------------------------------------
(defrecord ReifyNode-record [className interfaces methods]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:className this) os)
    (serdes.complex/write-repeated serdes.core/write-String 2 (:interfaces this) os)
    (serdes.complex/write-repeated serdes.core/write-embedded 3 (:methods this) os))
  pb/TypeReflection
  (gettype [this]
    "clojure.rt.protobuf.bytecode.ReifyNode"))

(s/def :clojure.rt.protobuf.bytecode.ReifyNode/className string?)
(s/def :clojure.rt.protobuf.bytecode.ReifyNode/interfaces (s/every string?))

(s/def ::ReifyNode-spec (s/keys :opt-un [:clojure.rt.protobuf.bytecode.ReifyNode/className :clojure.rt.protobuf.bytecode.ReifyNode/interfaces ]))
(def ReifyNode-defaults {:className "" :interfaces [] :methods [] })

(defn cis->ReifyNode
  "CodedInputStream to ReifyNode"
  [is]
  (->> (tag-map ReifyNode-defaults
         (fn [tag index]
             (case index
               1 [:className (serdes.core/cis->String is)]
               2 [:interfaces (serdes.complex/cis->repeated serdes.core/cis->String is)]
               3 [:methods (serdes.complex/cis->repeated ecis->Node is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->ReifyNode-record)))

(defn ecis->ReifyNode
  "Embedded CodedInputStream to ReifyNode"
  [is]
  (serdes.core/cis->embedded cis->ReifyNode is))

(defn new-ReifyNode
  "Creates a new instance from a map, similar to map->ReifyNode except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::ReifyNode-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::ReifyNode-spec init))))]}
  (-> (merge ReifyNode-defaults init)
      (cond-> (some? (get init :methods)) (update :methods #(map new-Node %)))
      (map->ReifyNode-record)))

(defn pb->ReifyNode
  "Protobuf to ReifyNode"
  [input]
  (cis->ReifyNode (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record ReifyNode-meta {:type "clojure.rt.protobuf.bytecode.ReifyNode" :decoder pb->ReifyNode})

;-----------------------------------------------------------------------------
; MethodNode
;-----------------------------------------------------------------------------
(defrecord MethodNode-record [body bridges fixedArity interface loopId name params this]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-embedded 1 (:body this) os)
    (serdes.complex/write-repeated serdes.core/write-String 2 (:bridges this) os)
    (serdes.core/write-Int32 3  {:optimize true} (:fixedArity this) os)
    (serdes.core/write-String 4  {:optimize true} (:interface this) os)
    (serdes.core/write-String 5  {:optimize true} (:loopId this) os)
    (serdes.core/write-String 6  {:optimize true} (:name this) os)
    (serdes.complex/write-repeated serdes.core/write-embedded 7 (:params this) os)
    (serdes.core/write-embedded 8 (:this this) os))
  pb/TypeReflection
  (gettype [this]
    "clojure.rt.protobuf.bytecode.MethodNode"))

(s/def :clojure.rt.protobuf.bytecode.MethodNode/bridges (s/every string?))
(s/def :clojure.rt.protobuf.bytecode.MethodNode/fixedArity int?)
(s/def :clojure.rt.protobuf.bytecode.MethodNode/interface string?)
(s/def :clojure.rt.protobuf.bytecode.MethodNode/loopId string?)
(s/def :clojure.rt.protobuf.bytecode.MethodNode/name string?)


(s/def ::MethodNode-spec (s/keys :opt-un [:clojure.rt.protobuf.bytecode.MethodNode/bridges :clojure.rt.protobuf.bytecode.MethodNode/fixedArity :clojure.rt.protobuf.bytecode.MethodNode/interface :clojure.rt.protobuf.bytecode.MethodNode/loopId :clojure.rt.protobuf.bytecode.MethodNode/name ]))
(def MethodNode-defaults {:bridges [] :fixedArity 0 :interface "" :loopId "" :name "" :params [] })

(defn cis->MethodNode
  "CodedInputStream to MethodNode"
  [is]
  (->> (tag-map MethodNode-defaults
         (fn [tag index]
             (case index
               1 [:body (ecis->Node is)]
               2 [:bridges (serdes.complex/cis->repeated serdes.core/cis->String is)]
               3 [:fixedArity (serdes.core/cis->Int32 is)]
               4 [:interface (serdes.core/cis->String is)]
               5 [:loopId (serdes.core/cis->String is)]
               6 [:name (serdes.core/cis->String is)]
               7 [:params (serdes.complex/cis->repeated ecis->Node is)]
               8 [:this (ecis->Node is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->MethodNode-record)))

(defn ecis->MethodNode
  "Embedded CodedInputStream to MethodNode"
  [is]
  (serdes.core/cis->embedded cis->MethodNode is))

(defn new-MethodNode
  "Creates a new instance from a map, similar to map->MethodNode except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::MethodNode-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::MethodNode-spec init))))]}
  (-> (merge MethodNode-defaults init)
      (cond-> (some? (get init :body)) (update :body new-Node))
      (cond-> (some? (get init :params)) (update :params #(map new-Node %)))
      (cond-> (some? (get init :this)) (update :this new-Node))
      (map->MethodNode-record)))

(defn pb->MethodNode
  "Protobuf to MethodNode"
  [input]
  (cis->MethodNode (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record MethodNode-meta {:type "clojure.rt.protobuf.bytecode.MethodNode" :decoder pb->MethodNode})

;-----------------------------------------------------------------------------
; LetfnNode
;-----------------------------------------------------------------------------
(defrecord LetfnNode-record [bindings body]
  pb/Writer
  (serialize [this os]
    (serdes.complex/write-repeated serdes.core/write-embedded 1 (:bindings this) os)
    (serdes.core/write-embedded 2 (:body this) os))
  pb/TypeReflection
  (gettype [this]
    "clojure.rt.protobuf.bytecode.LetfnNode"))

(s/def ::LetfnNode-spec (s/keys :opt-un []))
(def LetfnNode-defaults {:bindings [] })

(defn cis->LetfnNode
  "CodedInputStream to LetfnNode"
  [is]
  (->> (tag-map LetfnNode-defaults
         (fn [tag index]
             (case index
               1 [:bindings (serdes.complex/cis->repeated ecis->Node is)]
               2 [:body (ecis->Node is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->LetfnNode-record)))

(defn ecis->LetfnNode
  "Embedded CodedInputStream to LetfnNode"
  [is]
  (serdes.core/cis->embedded cis->LetfnNode is))

(defn new-LetfnNode
  "Creates a new instance from a map, similar to map->LetfnNode except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::LetfnNode-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::LetfnNode-spec init))))]}
  (-> (merge LetfnNode-defaults init)
      (cond-> (some? (get init :bindings)) (update :bindings #(map new-Node %)))
      (cond-> (some? (get init :body)) (update :body new-Node))
      (map->LetfnNode-record)))

(defn pb->LetfnNode
  "Protobuf to LetfnNode"
  [input]
  (cis->LetfnNode (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record LetfnNode-meta {:type "clojure.rt.protobuf.bytecode.LetfnNode" :decoder pb->LetfnNode})

;-----------------------------------------------------------------------------
; BindingNode
;-----------------------------------------------------------------------------
(defrecord BindingNode-record [argId init local name isVariadic]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-Int32 1  {:optimize true} (:argId this) os)
    (serdes.core/write-embedded 2 (:init this) os)
    (write-LocalType 3  {:optimize true} (:local this) os)
    (serdes.core/write-String 4  {:optimize true} (:name this) os)
    (serdes.core/write-Bool 5  {:optimize true} (:isVariadic this) os))
  pb/TypeReflection
  (gettype [this]
    "clojure.rt.protobuf.bytecode.BindingNode"))

(s/def :clojure.rt.protobuf.bytecode.BindingNode/argId int?)

(s/def :clojure.rt.protobuf.bytecode.BindingNode/local (s/or :keyword keyword? :int int?))
(s/def :clojure.rt.protobuf.bytecode.BindingNode/name string?)
(s/def :clojure.rt.protobuf.bytecode.BindingNode/isVariadic boolean?)
(s/def ::BindingNode-spec (s/keys :opt-un [:clojure.rt.protobuf.bytecode.BindingNode/argId :clojure.rt.protobuf.bytecode.BindingNode/local :clojure.rt.protobuf.bytecode.BindingNode/name :clojure.rt.protobuf.bytecode.BindingNode/isVariadic ]))
(def BindingNode-defaults {:argId 0 :local LocalType-default :name "" :isVariadic false })

(defn cis->BindingNode
  "CodedInputStream to BindingNode"
  [is]
  (->> (tag-map BindingNode-defaults
         (fn [tag index]
             (case index
               1 [:argId (serdes.core/cis->Int32 is)]
               2 [:init (ecis->Node is)]
               3 [:local (cis->LocalType is)]
               4 [:name (serdes.core/cis->String is)]
               5 [:isVariadic (serdes.core/cis->Bool is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->BindingNode-record)))

(defn ecis->BindingNode
  "Embedded CodedInputStream to BindingNode"
  [is]
  (serdes.core/cis->embedded cis->BindingNode is))

(defn new-BindingNode
  "Creates a new instance from a map, similar to map->BindingNode except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::BindingNode-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::BindingNode-spec init))))]}
  (-> (merge BindingNode-defaults init)
      (cond-> (some? (get init :init)) (update :init new-Node))
      (map->BindingNode-record)))

(defn pb->BindingNode
  "Protobuf to BindingNode"
  [input]
  (cis->BindingNode (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record BindingNode-meta {:type "clojure.rt.protobuf.bytecode.BindingNode" :decoder pb->BindingNode})

;-----------------------------------------------------------------------------
; VarNode
;-----------------------------------------------------------------------------
(defrecord VarNode-record [isAssignable var]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-Bool 1  {:optimize true} (:isAssignable this) os)
    (serdes.core/write-String 2  {:optimize true} (:var this) os))
  pb/TypeReflection
  (gettype [this]
    "clojure.rt.protobuf.bytecode.VarNode"))

(s/def :clojure.rt.protobuf.bytecode.VarNode/isAssignable boolean?)
(s/def :clojure.rt.protobuf.bytecode.VarNode/var string?)
(s/def ::VarNode-spec (s/keys :opt-un [:clojure.rt.protobuf.bytecode.VarNode/isAssignable :clojure.rt.protobuf.bytecode.VarNode/var ]))
(def VarNode-defaults {:isAssignable false :var "" })

(defn cis->VarNode
  "CodedInputStream to VarNode"
  [is]
  (->> (tag-map VarNode-defaults
         (fn [tag index]
             (case index
               1 [:isAssignable (serdes.core/cis->Bool is)]
               2 [:var (serdes.core/cis->String is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->VarNode-record)))

(defn ecis->VarNode
  "Embedded CodedInputStream to VarNode"
  [is]
  (serdes.core/cis->embedded cis->VarNode is))

(defn new-VarNode
  "Creates a new instance from a map, similar to map->VarNode except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::VarNode-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::VarNode-spec init))))]}
  (-> (merge VarNode-defaults init)
      (map->VarNode-record)))

(defn pb->VarNode
  "Protobuf to VarNode"
  [input]
  (cis->VarNode (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record VarNode-meta {:type "clojure.rt.protobuf.bytecode.VarNode" :decoder pb->VarNode})

;-----------------------------------------------------------------------------
; SetNode
;-----------------------------------------------------------------------------
(defrecord SetNode-record [items]
  pb/Writer
  (serialize [this os]
    (serdes.complex/write-repeated serdes.core/write-embedded 1 (:items this) os))
  pb/TypeReflection
  (gettype [this]
    "clojure.rt.protobuf.bytecode.SetNode"))

(s/def ::SetNode-spec (s/keys :opt-un []))
(def SetNode-defaults {:items [] })

(defn cis->SetNode
  "CodedInputStream to SetNode"
  [is]
  (->> (tag-map SetNode-defaults
         (fn [tag index]
             (case index
               1 [:items (serdes.complex/cis->repeated ecis->Node is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->SetNode-record)))

(defn ecis->SetNode
  "Embedded CodedInputStream to SetNode"
  [is]
  (serdes.core/cis->embedded cis->SetNode is))

(defn new-SetNode
  "Creates a new instance from a map, similar to map->SetNode except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::SetNode-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::SetNode-spec init))))]}
  (-> (merge SetNode-defaults init)
      (cond-> (some? (get init :items)) (update :items #(map new-Node %)))
      (map->SetNode-record)))

(defn pb->SetNode
  "Protobuf to SetNode"
  [input]
  (cis->SetNode (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record SetNode-meta {:type "clojure.rt.protobuf.bytecode.SetNode" :decoder pb->SetNode})

;-----------------------------------------------------------------------------
; Node
;-----------------------------------------------------------------------------
(defrecord Node-record [subnode form loops tag unwindMemory rawForms dropMemory env topLevel op oTag ignoreTag]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-embedded 9 (:subnode this) os)
    (serdes.core/write-String 3  {:optimize true} (:form this) os)
    (serdes.complex/write-repeated serdes.core/write-String 5 (:loops this) os)
    (serdes.core/write-String 10  {:optimize true} (:tag this) os)
    (serdes.complex/write-repeated serdes.core/write-embedded 12 (:unwindMemory this) os)
    (serdes.complex/write-repeated serdes.core/write-String 8 (:rawForms this) os)
    (serdes.complex/write-repeated serdes.core/write-embedded 1 (:dropMemory this) os)
    (serdes.core/write-embedded 2 (:env this) os)
    (serdes.core/write-Bool 11  {:optimize true} (:topLevel this) os)
    (write-Op 7  {:optimize true} (:op this) os)
    (serdes.core/write-String 6  {:optimize true} (:oTag this) os)
    (serdes.core/write-Bool 4  {:optimize true} (:ignoreTag this) os))
  pb/TypeReflection
  (gettype [this]
    "clojure.rt.protobuf.bytecode.Node"))

(s/def :clojure.rt.protobuf.bytecode.Node/form string?)
(s/def :clojure.rt.protobuf.bytecode.Node/loops (s/every string?))
(s/def :clojure.rt.protobuf.bytecode.Node/tag string?)

(s/def :clojure.rt.protobuf.bytecode.Node/rawForms (s/every string?))


(s/def :clojure.rt.protobuf.bytecode.Node/topLevel boolean?)
(s/def :clojure.rt.protobuf.bytecode.Node/op (s/or :keyword keyword? :int int?))
(s/def :clojure.rt.protobuf.bytecode.Node/oTag string?)
(s/def :clojure.rt.protobuf.bytecode.Node/ignoreTag boolean?)
(s/def ::Node-spec (s/keys :opt-un [:clojure.rt.protobuf.bytecode.Node/form :clojure.rt.protobuf.bytecode.Node/loops :clojure.rt.protobuf.bytecode.Node/tag :clojure.rt.protobuf.bytecode.Node/rawForms :clojure.rt.protobuf.bytecode.Node/topLevel :clojure.rt.protobuf.bytecode.Node/op :clojure.rt.protobuf.bytecode.Node/oTag :clojure.rt.protobuf.bytecode.Node/ignoreTag ]))
(def Node-defaults {:form "" :loops [] :tag "" :unwindMemory [] :rawForms [] :dropMemory [] :topLevel false :op Op-default :oTag "" :ignoreTag false })

(defn cis->Node
  "CodedInputStream to Node"
  [is]
  (->> (tag-map Node-defaults
         (fn [tag index]
             (case index
               9 [:subnode (ecis->Subnode is)]
               3 [:form (serdes.core/cis->String is)]
               5 [:loops (serdes.complex/cis->repeated serdes.core/cis->String is)]
               10 [:tag (serdes.core/cis->String is)]
               12 [:unwindMemory (serdes.complex/cis->repeated ecis->MemoryManagementGuidance is)]
               8 [:rawForms (serdes.complex/cis->repeated serdes.core/cis->String is)]
               1 [:dropMemory (serdes.complex/cis->repeated ecis->MemoryManagementGuidance is)]
               2 [:env (ecis->Environment is)]
               11 [:topLevel (serdes.core/cis->Bool is)]
               7 [:op (cis->Op is)]
               6 [:oTag (serdes.core/cis->String is)]
               4 [:ignoreTag (serdes.core/cis->Bool is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->Node-record)))

(defn ecis->Node
  "Embedded CodedInputStream to Node"
  [is]
  (serdes.core/cis->embedded cis->Node is))

(defn new-Node
  "Creates a new instance from a map, similar to map->Node except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Node-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Node-spec init))))]}
  (-> (merge Node-defaults init)
      (cond-> (some? (get init :dropMemory)) (update :dropMemory #(map new-MemoryManagementGuidance %)))
      (cond-> (some? (get init :env)) (update :env new-Environment))
      (cond-> (some? (get init :subnode)) (update :subnode new-Subnode))
      (cond-> (some? (get init :unwindMemory)) (update :unwindMemory #(map new-MemoryManagementGuidance %)))
      (map->Node-record)))

(defn pb->Node
  "Protobuf to Node"
  [input]
  (cis->Node (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Node-meta {:type "clojure.rt.protobuf.bytecode.Node" :decoder pb->Node})

;-----------------------------------------------------------------------------
; FnNode
;-----------------------------------------------------------------------------
(defrecord FnNode-record [local maxFixedArity methods once isVariadic]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-embedded 1 (:local this) os)
    (serdes.core/write-Int32 2  {:optimize true} (:maxFixedArity this) os)
    (serdes.complex/write-repeated serdes.core/write-embedded 3 (:methods this) os)
    (serdes.core/write-Bool 4  {:optimize true} (:once this) os)
    (serdes.core/write-Bool 5  {:optimize true} (:isVariadic this) os))
  pb/TypeReflection
  (gettype [this]
    "clojure.rt.protobuf.bytecode.FnNode"))

(s/def :clojure.rt.protobuf.bytecode.FnNode/maxFixedArity int?)

(s/def :clojure.rt.protobuf.bytecode.FnNode/once boolean?)
(s/def :clojure.rt.protobuf.bytecode.FnNode/isVariadic boolean?)
(s/def ::FnNode-spec (s/keys :opt-un [:clojure.rt.protobuf.bytecode.FnNode/maxFixedArity :clojure.rt.protobuf.bytecode.FnNode/once :clojure.rt.protobuf.bytecode.FnNode/isVariadic ]))
(def FnNode-defaults {:maxFixedArity 0 :methods [] :once false :isVariadic false })

(defn cis->FnNode
  "CodedInputStream to FnNode"
  [is]
  (->> (tag-map FnNode-defaults
         (fn [tag index]
             (case index
               1 [:local (ecis->Node is)]
               2 [:maxFixedArity (serdes.core/cis->Int32 is)]
               3 [:methods (serdes.complex/cis->repeated ecis->Node is)]
               4 [:once (serdes.core/cis->Bool is)]
               5 [:isVariadic (serdes.core/cis->Bool is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->FnNode-record)))

(defn ecis->FnNode
  "Embedded CodedInputStream to FnNode"
  [is]
  (serdes.core/cis->embedded cis->FnNode is))

(defn new-FnNode
  "Creates a new instance from a map, similar to map->FnNode except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::FnNode-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::FnNode-spec init))))]}
  (-> (merge FnNode-defaults init)
      (cond-> (some? (get init :local)) (update :local new-Node))
      (cond-> (some? (get init :methods)) (update :methods #(map new-Node %)))
      (map->FnNode-record)))

(defn pb->FnNode
  "Protobuf to FnNode"
  [input]
  (cis->FnNode (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record FnNode-meta {:type "clojure.rt.protobuf.bytecode.FnNode" :decoder pb->FnNode})

;-----------------------------------------------------------------------------
; LocalNode
;-----------------------------------------------------------------------------
(defrecord LocalNode-record [argId isAssignable local name isVariadic]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-Int32 1  {:optimize true} (:argId this) os)
    (serdes.core/write-Bool 2  {:optimize true} (:isAssignable this) os)
    (write-LocalType 3  {:optimize true} (:local this) os)
    (serdes.core/write-String 4  {:optimize true} (:name this) os)
    (serdes.core/write-Bool 5  {:optimize true} (:isVariadic this) os))
  pb/TypeReflection
  (gettype [this]
    "clojure.rt.protobuf.bytecode.LocalNode"))

(s/def :clojure.rt.protobuf.bytecode.LocalNode/argId int?)
(s/def :clojure.rt.protobuf.bytecode.LocalNode/isAssignable boolean?)
(s/def :clojure.rt.protobuf.bytecode.LocalNode/local (s/or :keyword keyword? :int int?))
(s/def :clojure.rt.protobuf.bytecode.LocalNode/name string?)
(s/def :clojure.rt.protobuf.bytecode.LocalNode/isVariadic boolean?)
(s/def ::LocalNode-spec (s/keys :opt-un [:clojure.rt.protobuf.bytecode.LocalNode/argId :clojure.rt.protobuf.bytecode.LocalNode/isAssignable :clojure.rt.protobuf.bytecode.LocalNode/local :clojure.rt.protobuf.bytecode.LocalNode/name :clojure.rt.protobuf.bytecode.LocalNode/isVariadic ]))
(def LocalNode-defaults {:argId 0 :isAssignable false :local LocalType-default :name "" :isVariadic false })

(defn cis->LocalNode
  "CodedInputStream to LocalNode"
  [is]
  (->> (tag-map LocalNode-defaults
         (fn [tag index]
             (case index
               1 [:argId (serdes.core/cis->Int32 is)]
               2 [:isAssignable (serdes.core/cis->Bool is)]
               3 [:local (cis->LocalType is)]
               4 [:name (serdes.core/cis->String is)]
               5 [:isVariadic (serdes.core/cis->Bool is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->LocalNode-record)))

(defn ecis->LocalNode
  "Embedded CodedInputStream to LocalNode"
  [is]
  (serdes.core/cis->embedded cis->LocalNode is))

(defn new-LocalNode
  "Creates a new instance from a map, similar to map->LocalNode except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::LocalNode-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::LocalNode-spec init))))]}
  (-> (merge LocalNode-defaults init)
      (map->LocalNode-record)))

(defn pb->LocalNode
  "Protobuf to LocalNode"
  [input]
  (cis->LocalNode (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record LocalNode-meta {:type "clojure.rt.protobuf.bytecode.LocalNode" :decoder pb->LocalNode})

;-----------------------------------------------------------------------------
; DoNode
;-----------------------------------------------------------------------------
(defrecord DoNode-record [isBody ret statements]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-Bool 1  {:optimize true} (:isBody this) os)
    (serdes.core/write-embedded 2 (:ret this) os)
    (serdes.complex/write-repeated serdes.core/write-embedded 3 (:statements this) os))
  pb/TypeReflection
  (gettype [this]
    "clojure.rt.protobuf.bytecode.DoNode"))

(s/def :clojure.rt.protobuf.bytecode.DoNode/isBody boolean?)


(s/def ::DoNode-spec (s/keys :opt-un [:clojure.rt.protobuf.bytecode.DoNode/isBody ]))
(def DoNode-defaults {:isBody false :statements [] })

(defn cis->DoNode
  "CodedInputStream to DoNode"
  [is]
  (->> (tag-map DoNode-defaults
         (fn [tag index]
             (case index
               1 [:isBody (serdes.core/cis->Bool is)]
               2 [:ret (ecis->Node is)]
               3 [:statements (serdes.complex/cis->repeated ecis->Node is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->DoNode-record)))

(defn ecis->DoNode
  "Embedded CodedInputStream to DoNode"
  [is]
  (serdes.core/cis->embedded cis->DoNode is))

(defn new-DoNode
  "Creates a new instance from a map, similar to map->DoNode except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::DoNode-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::DoNode-spec init))))]}
  (-> (merge DoNode-defaults init)
      (cond-> (some? (get init :ret)) (update :ret new-Node))
      (cond-> (some? (get init :statements)) (update :statements #(map new-Node %)))
      (map->DoNode-record)))

(defn pb->DoNode
  "Protobuf to DoNode"
  [input]
  (cis->DoNode (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record DoNode-meta {:type "clojure.rt.protobuf.bytecode.DoNode" :decoder pb->DoNode})

;-----------------------------------------------------------------------------
; Subnode
;-----------------------------------------------------------------------------
(defrecord Subnode-record [types]
  pb/Writer
  (serialize [this os]
    (write-Subnode-types  (:types this) os))
  pb/TypeReflection
  (gettype [this]
    "clojure.rt.protobuf.bytecode.Subnode"))

(s/def ::Subnode-spec (s/keys :opt-un []))
(def Subnode-defaults {})

(defn cis->Subnode
  "CodedInputStream to Subnode"
  [is]
  (->> (tag-map Subnode-defaults
         (fn [tag index]
             (case index
               18 [:types {:invoke (ecis->InvokeNode is)}]
               24 [:types {:map (ecis->MapNode is)}]
               1 [:types {:binding (ecis->BindingNode is)}]
               23 [:types {:loop (ecis->LoopNode is)}]
               15 [:types {:instanceCall (ecis->InstanceCallNode is)}]
               35 [:types {:mutateSet (ecis->MutateSetNode is)}]
               36 [:types {:staticCall (ecis->StaticCallNode is)}]
               11 [:types {:fnMethod (ecis->FnMethodNode is)}]
               41 [:types {:var (ecis->VarNode is)}]
               16 [:types {:instanceField (ecis->InstanceFieldNode is)}]
               40 [:types {:try (ecis->TryNode is)}]
               25 [:types {:method (ecis->MethodNode is)}]
               19 [:types {:keywordInvoke (ecis->KeywordInvokeNode is)}]
               28 [:types {:new (ecis->NewNode is)}]
               10 [:types {:fn (ecis->FnNode is)}]
               26 [:types {:monitorEnter (ecis->MonitorEnterNode is)}]
               27 [:types {:monitorExit (ecis->MonitorExitNode is)}]
               5 [:types {:catch (ecis->CatchNode is)}]
               37 [:types {:staticField (ecis->StaticFieldNode is)}]
               13 [:types {:if (ecis->IfNode is)}]
               20 [:types {:let (ecis->LetNode is)}]
               33 [:types {:reify (ecis->ReifyNode is)}]
               14 [:types {:import (ecis->ImportNode is)}]
               42 [:types {:vector (ecis->VectorNode is)}]
               6 [:types {:const (ecis->ConstNode is)}]
               2 [:types {:case (ecis->CaseNode is)}]
               17 [:types {:isInstance (ecis->IsInstanceNode is)}]
               29 [:types {:primInvoke (ecis->PrimInvokeNode is)}]
               38 [:types {:theVar (ecis->TheVarNode is)}]
               9 [:types {:do (ecis->DoNode is)}]
               3 [:types {:caseTest (ecis->CaseTestNode is)}]
               4 [:types {:caseThen (ecis->CaseThenNode is)}]
               12 [:types {:hostInterop (ecis->HostInteropNode is)}]
               43 [:types {:withMeta (ecis->WithMetaNode is)}]
               31 [:types {:quote (ecis->QuoteNode is)}]
               22 [:types {:local (ecis->LocalNode is)}]
               34 [:types {:set (ecis->SetNode is)}]
               7 [:types {:def (ecis->DefNode is)}]
               32 [:types {:recur (ecis->RecurNode is)}]
               39 [:types {:throw (ecis->ThrowNode is)}]
               21 [:types {:letfn (ecis->LetfnNode is)}]
               30 [:types {:protocolInvoke (ecis->ProtocolInvokeNode is)}]
               8 [:types {:deftype (ecis->DeftypeNode is)}]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->Subnode-record)))

(defn ecis->Subnode
  "Embedded CodedInputStream to Subnode"
  [is]
  (serdes.core/cis->embedded cis->Subnode is))

(defn new-Subnode
  "Creates a new instance from a map, similar to map->Subnode except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Subnode-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Subnode-spec init))))]}
  (-> (merge Subnode-defaults init)
      (convert-Subnode-types)
      (map->Subnode-record)))

(defn pb->Subnode
  "Protobuf to Subnode"
  [input]
  (cis->Subnode (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Subnode-meta {:type "clojure.rt.protobuf.bytecode.Subnode" :decoder pb->Subnode})

