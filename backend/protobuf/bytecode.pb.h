// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bytecode.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_bytecode_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_bytecode_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021005 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_bytecode_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_bytecode_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_bytecode_2eproto;
namespace clojureRT {
namespace protobuf {
class BindingNode;
struct BindingNodeDefaultTypeInternal;
extern BindingNodeDefaultTypeInternal _BindingNode_default_instance_;
class CaseNode;
struct CaseNodeDefaultTypeInternal;
extern CaseNodeDefaultTypeInternal _CaseNode_default_instance_;
class CaseTestNode;
struct CaseTestNodeDefaultTypeInternal;
extern CaseTestNodeDefaultTypeInternal _CaseTestNode_default_instance_;
class CaseThenNode;
struct CaseThenNodeDefaultTypeInternal;
extern CaseThenNodeDefaultTypeInternal _CaseThenNode_default_instance_;
class CatchNode;
struct CatchNodeDefaultTypeInternal;
extern CatchNodeDefaultTypeInternal _CatchNode_default_instance_;
class ConstNode;
struct ConstNodeDefaultTypeInternal;
extern ConstNodeDefaultTypeInternal _ConstNode_default_instance_;
class DefNode;
struct DefNodeDefaultTypeInternal;
extern DefNodeDefaultTypeInternal _DefNode_default_instance_;
class DeftypeNode;
struct DeftypeNodeDefaultTypeInternal;
extern DeftypeNodeDefaultTypeInternal _DeftypeNode_default_instance_;
class DoNode;
struct DoNodeDefaultTypeInternal;
extern DoNodeDefaultTypeInternal _DoNode_default_instance_;
class FnMethodNode;
struct FnMethodNodeDefaultTypeInternal;
extern FnMethodNodeDefaultTypeInternal _FnMethodNode_default_instance_;
class FnNode;
struct FnNodeDefaultTypeInternal;
extern FnNodeDefaultTypeInternal _FnNode_default_instance_;
class HostInteropNode;
struct HostInteropNodeDefaultTypeInternal;
extern HostInteropNodeDefaultTypeInternal _HostInteropNode_default_instance_;
class IfNode;
struct IfNodeDefaultTypeInternal;
extern IfNodeDefaultTypeInternal _IfNode_default_instance_;
class ImportNode;
struct ImportNodeDefaultTypeInternal;
extern ImportNodeDefaultTypeInternal _ImportNode_default_instance_;
class InstanceCallNode;
struct InstanceCallNodeDefaultTypeInternal;
extern InstanceCallNodeDefaultTypeInternal _InstanceCallNode_default_instance_;
class InstanceFieldNode;
struct InstanceFieldNodeDefaultTypeInternal;
extern InstanceFieldNodeDefaultTypeInternal _InstanceFieldNode_default_instance_;
class InvokeNode;
struct InvokeNodeDefaultTypeInternal;
extern InvokeNodeDefaultTypeInternal _InvokeNode_default_instance_;
class IsInstanceNode;
struct IsInstanceNodeDefaultTypeInternal;
extern IsInstanceNodeDefaultTypeInternal _IsInstanceNode_default_instance_;
class KeywordInvokeNode;
struct KeywordInvokeNodeDefaultTypeInternal;
extern KeywordInvokeNodeDefaultTypeInternal _KeywordInvokeNode_default_instance_;
class LetNode;
struct LetNodeDefaultTypeInternal;
extern LetNodeDefaultTypeInternal _LetNode_default_instance_;
class LetfnNode;
struct LetfnNodeDefaultTypeInternal;
extern LetfnNodeDefaultTypeInternal _LetfnNode_default_instance_;
class LocalNode;
struct LocalNodeDefaultTypeInternal;
extern LocalNodeDefaultTypeInternal _LocalNode_default_instance_;
class LoopNode;
struct LoopNodeDefaultTypeInternal;
extern LoopNodeDefaultTypeInternal _LoopNode_default_instance_;
class MapNode;
struct MapNodeDefaultTypeInternal;
extern MapNodeDefaultTypeInternal _MapNode_default_instance_;
class MethodNode;
struct MethodNodeDefaultTypeInternal;
extern MethodNodeDefaultTypeInternal _MethodNode_default_instance_;
class MonitorEnterNode;
struct MonitorEnterNodeDefaultTypeInternal;
extern MonitorEnterNodeDefaultTypeInternal _MonitorEnterNode_default_instance_;
class MonitorExitNode;
struct MonitorExitNodeDefaultTypeInternal;
extern MonitorExitNodeDefaultTypeInternal _MonitorExitNode_default_instance_;
class MutateSetNode;
struct MutateSetNodeDefaultTypeInternal;
extern MutateSetNodeDefaultTypeInternal _MutateSetNode_default_instance_;
class NewNode;
struct NewNodeDefaultTypeInternal;
extern NewNodeDefaultTypeInternal _NewNode_default_instance_;
class Node;
struct NodeDefaultTypeInternal;
extern NodeDefaultTypeInternal _Node_default_instance_;
class PrimInvokeNode;
struct PrimInvokeNodeDefaultTypeInternal;
extern PrimInvokeNodeDefaultTypeInternal _PrimInvokeNode_default_instance_;
class ProtocolInvokeNode;
struct ProtocolInvokeNodeDefaultTypeInternal;
extern ProtocolInvokeNodeDefaultTypeInternal _ProtocolInvokeNode_default_instance_;
class QuoteNode;
struct QuoteNodeDefaultTypeInternal;
extern QuoteNodeDefaultTypeInternal _QuoteNode_default_instance_;
class RecurNode;
struct RecurNodeDefaultTypeInternal;
extern RecurNodeDefaultTypeInternal _RecurNode_default_instance_;
class ReifyNode;
struct ReifyNodeDefaultTypeInternal;
extern ReifyNodeDefaultTypeInternal _ReifyNode_default_instance_;
class SetNode;
struct SetNodeDefaultTypeInternal;
extern SetNodeDefaultTypeInternal _SetNode_default_instance_;
class StaticCallNode;
struct StaticCallNodeDefaultTypeInternal;
extern StaticCallNodeDefaultTypeInternal _StaticCallNode_default_instance_;
class StaticFieldNode;
struct StaticFieldNodeDefaultTypeInternal;
extern StaticFieldNodeDefaultTypeInternal _StaticFieldNode_default_instance_;
class Subnode;
struct SubnodeDefaultTypeInternal;
extern SubnodeDefaultTypeInternal _Subnode_default_instance_;
class TheVarNode;
struct TheVarNodeDefaultTypeInternal;
extern TheVarNodeDefaultTypeInternal _TheVarNode_default_instance_;
class ThrowNode;
struct ThrowNodeDefaultTypeInternal;
extern ThrowNodeDefaultTypeInternal _ThrowNode_default_instance_;
class TryNode;
struct TryNodeDefaultTypeInternal;
extern TryNodeDefaultTypeInternal _TryNode_default_instance_;
class VarNode;
struct VarNodeDefaultTypeInternal;
extern VarNodeDefaultTypeInternal _VarNode_default_instance_;
class VectorNode;
struct VectorNodeDefaultTypeInternal;
extern VectorNodeDefaultTypeInternal _VectorNode_default_instance_;
class WithMetaNode;
struct WithMetaNodeDefaultTypeInternal;
extern WithMetaNodeDefaultTypeInternal _WithMetaNode_default_instance_;
}  // namespace protobuf
}  // namespace clojureRT
PROTOBUF_NAMESPACE_OPEN
template<> ::clojureRT::protobuf::BindingNode* Arena::CreateMaybeMessage<::clojureRT::protobuf::BindingNode>(Arena*);
template<> ::clojureRT::protobuf::CaseNode* Arena::CreateMaybeMessage<::clojureRT::protobuf::CaseNode>(Arena*);
template<> ::clojureRT::protobuf::CaseTestNode* Arena::CreateMaybeMessage<::clojureRT::protobuf::CaseTestNode>(Arena*);
template<> ::clojureRT::protobuf::CaseThenNode* Arena::CreateMaybeMessage<::clojureRT::protobuf::CaseThenNode>(Arena*);
template<> ::clojureRT::protobuf::CatchNode* Arena::CreateMaybeMessage<::clojureRT::protobuf::CatchNode>(Arena*);
template<> ::clojureRT::protobuf::ConstNode* Arena::CreateMaybeMessage<::clojureRT::protobuf::ConstNode>(Arena*);
template<> ::clojureRT::protobuf::DefNode* Arena::CreateMaybeMessage<::clojureRT::protobuf::DefNode>(Arena*);
template<> ::clojureRT::protobuf::DeftypeNode* Arena::CreateMaybeMessage<::clojureRT::protobuf::DeftypeNode>(Arena*);
template<> ::clojureRT::protobuf::DoNode* Arena::CreateMaybeMessage<::clojureRT::protobuf::DoNode>(Arena*);
template<> ::clojureRT::protobuf::FnMethodNode* Arena::CreateMaybeMessage<::clojureRT::protobuf::FnMethodNode>(Arena*);
template<> ::clojureRT::protobuf::FnNode* Arena::CreateMaybeMessage<::clojureRT::protobuf::FnNode>(Arena*);
template<> ::clojureRT::protobuf::HostInteropNode* Arena::CreateMaybeMessage<::clojureRT::protobuf::HostInteropNode>(Arena*);
template<> ::clojureRT::protobuf::IfNode* Arena::CreateMaybeMessage<::clojureRT::protobuf::IfNode>(Arena*);
template<> ::clojureRT::protobuf::ImportNode* Arena::CreateMaybeMessage<::clojureRT::protobuf::ImportNode>(Arena*);
template<> ::clojureRT::protobuf::InstanceCallNode* Arena::CreateMaybeMessage<::clojureRT::protobuf::InstanceCallNode>(Arena*);
template<> ::clojureRT::protobuf::InstanceFieldNode* Arena::CreateMaybeMessage<::clojureRT::protobuf::InstanceFieldNode>(Arena*);
template<> ::clojureRT::protobuf::InvokeNode* Arena::CreateMaybeMessage<::clojureRT::protobuf::InvokeNode>(Arena*);
template<> ::clojureRT::protobuf::IsInstanceNode* Arena::CreateMaybeMessage<::clojureRT::protobuf::IsInstanceNode>(Arena*);
template<> ::clojureRT::protobuf::KeywordInvokeNode* Arena::CreateMaybeMessage<::clojureRT::protobuf::KeywordInvokeNode>(Arena*);
template<> ::clojureRT::protobuf::LetNode* Arena::CreateMaybeMessage<::clojureRT::protobuf::LetNode>(Arena*);
template<> ::clojureRT::protobuf::LetfnNode* Arena::CreateMaybeMessage<::clojureRT::protobuf::LetfnNode>(Arena*);
template<> ::clojureRT::protobuf::LocalNode* Arena::CreateMaybeMessage<::clojureRT::protobuf::LocalNode>(Arena*);
template<> ::clojureRT::protobuf::LoopNode* Arena::CreateMaybeMessage<::clojureRT::protobuf::LoopNode>(Arena*);
template<> ::clojureRT::protobuf::MapNode* Arena::CreateMaybeMessage<::clojureRT::protobuf::MapNode>(Arena*);
template<> ::clojureRT::protobuf::MethodNode* Arena::CreateMaybeMessage<::clojureRT::protobuf::MethodNode>(Arena*);
template<> ::clojureRT::protobuf::MonitorEnterNode* Arena::CreateMaybeMessage<::clojureRT::protobuf::MonitorEnterNode>(Arena*);
template<> ::clojureRT::protobuf::MonitorExitNode* Arena::CreateMaybeMessage<::clojureRT::protobuf::MonitorExitNode>(Arena*);
template<> ::clojureRT::protobuf::MutateSetNode* Arena::CreateMaybeMessage<::clojureRT::protobuf::MutateSetNode>(Arena*);
template<> ::clojureRT::protobuf::NewNode* Arena::CreateMaybeMessage<::clojureRT::protobuf::NewNode>(Arena*);
template<> ::clojureRT::protobuf::Node* Arena::CreateMaybeMessage<::clojureRT::protobuf::Node>(Arena*);
template<> ::clojureRT::protobuf::PrimInvokeNode* Arena::CreateMaybeMessage<::clojureRT::protobuf::PrimInvokeNode>(Arena*);
template<> ::clojureRT::protobuf::ProtocolInvokeNode* Arena::CreateMaybeMessage<::clojureRT::protobuf::ProtocolInvokeNode>(Arena*);
template<> ::clojureRT::protobuf::QuoteNode* Arena::CreateMaybeMessage<::clojureRT::protobuf::QuoteNode>(Arena*);
template<> ::clojureRT::protobuf::RecurNode* Arena::CreateMaybeMessage<::clojureRT::protobuf::RecurNode>(Arena*);
template<> ::clojureRT::protobuf::ReifyNode* Arena::CreateMaybeMessage<::clojureRT::protobuf::ReifyNode>(Arena*);
template<> ::clojureRT::protobuf::SetNode* Arena::CreateMaybeMessage<::clojureRT::protobuf::SetNode>(Arena*);
template<> ::clojureRT::protobuf::StaticCallNode* Arena::CreateMaybeMessage<::clojureRT::protobuf::StaticCallNode>(Arena*);
template<> ::clojureRT::protobuf::StaticFieldNode* Arena::CreateMaybeMessage<::clojureRT::protobuf::StaticFieldNode>(Arena*);
template<> ::clojureRT::protobuf::Subnode* Arena::CreateMaybeMessage<::clojureRT::protobuf::Subnode>(Arena*);
template<> ::clojureRT::protobuf::TheVarNode* Arena::CreateMaybeMessage<::clojureRT::protobuf::TheVarNode>(Arena*);
template<> ::clojureRT::protobuf::ThrowNode* Arena::CreateMaybeMessage<::clojureRT::protobuf::ThrowNode>(Arena*);
template<> ::clojureRT::protobuf::TryNode* Arena::CreateMaybeMessage<::clojureRT::protobuf::TryNode>(Arena*);
template<> ::clojureRT::protobuf::VarNode* Arena::CreateMaybeMessage<::clojureRT::protobuf::VarNode>(Arena*);
template<> ::clojureRT::protobuf::VectorNode* Arena::CreateMaybeMessage<::clojureRT::protobuf::VectorNode>(Arena*);
template<> ::clojureRT::protobuf::WithMetaNode* Arena::CreateMaybeMessage<::clojureRT::protobuf::WithMetaNode>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace clojureRT {
namespace protobuf {

enum CaseNode_SwitchType : int {
  CaseNode_SwitchType_switchTypeSparse = 0,
  CaseNode_SwitchType_switchTypeCompact = 1,
  CaseNode_SwitchType_CaseNode_SwitchType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CaseNode_SwitchType_CaseNode_SwitchType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CaseNode_SwitchType_IsValid(int value);
constexpr CaseNode_SwitchType CaseNode_SwitchType_SwitchType_MIN = CaseNode_SwitchType_switchTypeSparse;
constexpr CaseNode_SwitchType CaseNode_SwitchType_SwitchType_MAX = CaseNode_SwitchType_switchTypeCompact;
constexpr int CaseNode_SwitchType_SwitchType_ARRAYSIZE = CaseNode_SwitchType_SwitchType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CaseNode_SwitchType_descriptor();
template<typename T>
inline const std::string& CaseNode_SwitchType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CaseNode_SwitchType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CaseNode_SwitchType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CaseNode_SwitchType_descriptor(), enum_t_value);
}
inline bool CaseNode_SwitchType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CaseNode_SwitchType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CaseNode_SwitchType>(
    CaseNode_SwitchType_descriptor(), name, value);
}
enum CaseNode_TestType : int {
  CaseNode_TestType_testTypeInt = 0,
  CaseNode_TestType_testTypeHashEquiv = 1,
  CaseNode_TestType_testTypeHashIdentity = 2,
  CaseNode_TestType_CaseNode_TestType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CaseNode_TestType_CaseNode_TestType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CaseNode_TestType_IsValid(int value);
constexpr CaseNode_TestType CaseNode_TestType_TestType_MIN = CaseNode_TestType_testTypeInt;
constexpr CaseNode_TestType CaseNode_TestType_TestType_MAX = CaseNode_TestType_testTypeHashIdentity;
constexpr int CaseNode_TestType_TestType_ARRAYSIZE = CaseNode_TestType_TestType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CaseNode_TestType_descriptor();
template<typename T>
inline const std::string& CaseNode_TestType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CaseNode_TestType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CaseNode_TestType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CaseNode_TestType_descriptor(), enum_t_value);
}
inline bool CaseNode_TestType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CaseNode_TestType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CaseNode_TestType>(
    CaseNode_TestType_descriptor(), name, value);
}
enum ConstNode_ConstType : int {
  ConstNode_ConstType_constTypeNil = 0,
  ConstNode_ConstType_constTypeBool = 1,
  ConstNode_ConstType_constTypeKeyword = 2,
  ConstNode_ConstType_constTypeSymbol = 3,
  ConstNode_ConstType_constTypeString = 4,
  ConstNode_ConstType_constTypeNumber = 5,
  ConstNode_ConstType_constTypeType = 6,
  ConstNode_ConstType_constTypeRecord = 7,
  ConstNode_ConstType_constTypeMap = 8,
  ConstNode_ConstType_constTypeVector = 9,
  ConstNode_ConstType_constTypeSet = 10,
  ConstNode_ConstType_constTypeSeq = 11,
  ConstNode_ConstType_constTypeChar = 12,
  ConstNode_ConstType_constTypeRegex = 13,
  ConstNode_ConstType_constTypeClass = 14,
  ConstNode_ConstType_constTypeVar = 15,
  ConstNode_ConstType_constTypeUnknown = 16,
  ConstNode_ConstType_ConstNode_ConstType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ConstNode_ConstType_ConstNode_ConstType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ConstNode_ConstType_IsValid(int value);
constexpr ConstNode_ConstType ConstNode_ConstType_ConstType_MIN = ConstNode_ConstType_constTypeNil;
constexpr ConstNode_ConstType ConstNode_ConstType_ConstType_MAX = ConstNode_ConstType_constTypeUnknown;
constexpr int ConstNode_ConstType_ConstType_ARRAYSIZE = ConstNode_ConstType_ConstType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ConstNode_ConstType_descriptor();
template<typename T>
inline const std::string& ConstNode_ConstType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ConstNode_ConstType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ConstNode_ConstType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ConstNode_ConstType_descriptor(), enum_t_value);
}
inline bool ConstNode_ConstType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ConstNode_ConstType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ConstNode_ConstType>(
    ConstNode_ConstType_descriptor(), name, value);
}
enum Op : int {
  opBinding = 0,
  opCase = 1,
  opCaseTest = 2,
  opCaseThen = 3,
  opCatch = 4,
  opConst = 5,
  opDef = 6,
  opDeftype = 7,
  opDo = 8,
  opFn = 9,
  opFnMethod = 10,
  opHostInterop = 11,
  opIf = 12,
  opImport = 13,
  opInstanceCall = 14,
  opInstanceField = 15,
  opIsInstance = 16,
  opInvoke = 17,
  opKeywordInvoke = 18,
  opLet = 19,
  opLetfn = 20,
  opLocal = 21,
  opLoop = 22,
  opMap = 23,
  opMethod = 24,
  opMonitorEnter = 25,
  opMonitorExit = 26,
  opNew = 27,
  opPrimInvoke = 28,
  opProtocolInvoke = 29,
  opQuote = 30,
  opRecur = 31,
  opReify = 32,
  opSet = 33,
  opMutateSet = 34,
  opStaticCall = 35,
  opStaticField = 36,
  opTheVar = 37,
  opThrow = 38,
  opTry = 39,
  opVar = 40,
  opVector = 41,
  opWithMeta = 42,
  Op_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Op_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Op_IsValid(int value);
constexpr Op Op_MIN = opBinding;
constexpr Op Op_MAX = opWithMeta;
constexpr int Op_ARRAYSIZE = Op_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Op_descriptor();
template<typename T>
inline const std::string& Op_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Op>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Op_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Op_descriptor(), enum_t_value);
}
inline bool Op_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Op* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Op>(
    Op_descriptor(), name, value);
}
enum LocalType : int {
  localTypeArg = 0,
  localTypeCatch = 1,
  localTypeFn = 2,
  localTypeLet = 3,
  localTypeLetfn = 4,
  localTypeLoop = 5,
  localTypeField = 6,
  localTypeThis = 7,
  LocalType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  LocalType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool LocalType_IsValid(int value);
constexpr LocalType LocalType_MIN = localTypeArg;
constexpr LocalType LocalType_MAX = localTypeThis;
constexpr int LocalType_ARRAYSIZE = LocalType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LocalType_descriptor();
template<typename T>
inline const std::string& LocalType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LocalType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LocalType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LocalType_descriptor(), enum_t_value);
}
inline bool LocalType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LocalType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LocalType>(
    LocalType_descriptor(), name, value);
}
// ===================================================================

class Subnode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clojureRT.protobuf.Subnode) */ {
 public:
  inline Subnode() : Subnode(nullptr) {}
  ~Subnode() override;
  explicit PROTOBUF_CONSTEXPR Subnode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Subnode(const Subnode& from);
  Subnode(Subnode&& from) noexcept
    : Subnode() {
    *this = ::std::move(from);
  }

  inline Subnode& operator=(const Subnode& from) {
    CopyFrom(from);
    return *this;
  }
  inline Subnode& operator=(Subnode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Subnode& default_instance() {
    return *internal_default_instance();
  }
  enum TypesCase {
    kBinding = 1,
    kCase = 2,
    kCaseTest = 3,
    kCaseThen = 4,
    kCatch = 5,
    kConst = 6,
    kDef = 7,
    kDeftype = 8,
    kDo = 9,
    kFn = 10,
    kFnMethod = 11,
    kHostInterop = 12,
    kIf = 13,
    kImport = 14,
    kInstanceCall = 15,
    kInstanceField = 16,
    kIsInstance = 17,
    kInvoke = 18,
    kKeywordInvoke = 19,
    kLet = 20,
    kLetfn = 21,
    kLocal = 22,
    kLoop = 23,
    kMap = 24,
    kMethod = 25,
    kMonitorEnter = 26,
    kMonitorExit = 27,
    kNew = 28,
    kPrimInvoke = 29,
    kProtocolInvoke = 30,
    kQuote = 31,
    kRecur = 32,
    kReify = 33,
    kSet = 34,
    kMutateSet = 35,
    kStaticCall = 36,
    kStaticField = 37,
    kTheVar = 38,
    kThrow = 39,
    kTry = 40,
    kVar = 41,
    kVector = 42,
    kWithMeta = 43,
    TYPES_NOT_SET = 0,
  };

  static inline const Subnode* internal_default_instance() {
    return reinterpret_cast<const Subnode*>(
               &_Subnode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Subnode& a, Subnode& b) {
    a.Swap(&b);
  }
  inline void Swap(Subnode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Subnode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Subnode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Subnode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Subnode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Subnode& from) {
    Subnode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Subnode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clojureRT.protobuf.Subnode";
  }
  protected:
  explicit Subnode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBindingFieldNumber = 1,
    kCaseFieldNumber = 2,
    kCaseTestFieldNumber = 3,
    kCaseThenFieldNumber = 4,
    kCatchFieldNumber = 5,
    kConstFieldNumber = 6,
    kDefFieldNumber = 7,
    kDeftypeFieldNumber = 8,
    kDoFieldNumber = 9,
    kFnFieldNumber = 10,
    kFnMethodFieldNumber = 11,
    kHostInteropFieldNumber = 12,
    kIfFieldNumber = 13,
    kImportFieldNumber = 14,
    kInstanceCallFieldNumber = 15,
    kInstanceFieldFieldNumber = 16,
    kIsInstanceFieldNumber = 17,
    kInvokeFieldNumber = 18,
    kKeywordInvokeFieldNumber = 19,
    kLetFieldNumber = 20,
    kLetfnFieldNumber = 21,
    kLocalFieldNumber = 22,
    kLoopFieldNumber = 23,
    kMapFieldNumber = 24,
    kMethodFieldNumber = 25,
    kMonitorEnterFieldNumber = 26,
    kMonitorExitFieldNumber = 27,
    kNewFieldNumber = 28,
    kPrimInvokeFieldNumber = 29,
    kProtocolInvokeFieldNumber = 30,
    kQuoteFieldNumber = 31,
    kRecurFieldNumber = 32,
    kReifyFieldNumber = 33,
    kSetFieldNumber = 34,
    kMutateSetFieldNumber = 35,
    kStaticCallFieldNumber = 36,
    kStaticFieldFieldNumber = 37,
    kTheVarFieldNumber = 38,
    kThrowFieldNumber = 39,
    kTryFieldNumber = 40,
    kVarFieldNumber = 41,
    kVectorFieldNumber = 42,
    kWithMetaFieldNumber = 43,
  };
  // .clojureRT.protobuf.BindingNode binding = 1;
  bool has_binding() const;
  private:
  bool _internal_has_binding() const;
  public:
  void clear_binding();
  const ::clojureRT::protobuf::BindingNode& binding() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::BindingNode* release_binding();
  ::clojureRT::protobuf::BindingNode* mutable_binding();
  void set_allocated_binding(::clojureRT::protobuf::BindingNode* binding);
  private:
  const ::clojureRT::protobuf::BindingNode& _internal_binding() const;
  ::clojureRT::protobuf::BindingNode* _internal_mutable_binding();
  public:
  void unsafe_arena_set_allocated_binding(
      ::clojureRT::protobuf::BindingNode* binding);
  ::clojureRT::protobuf::BindingNode* unsafe_arena_release_binding();

  // .clojureRT.protobuf.CaseNode case = 2;
  bool has_case_() const;
  private:
  bool _internal_has_case_() const;
  public:
  void clear_case_();
  const ::clojureRT::protobuf::CaseNode& case_() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::CaseNode* release_case_();
  ::clojureRT::protobuf::CaseNode* mutable_case_();
  void set_allocated_case_(::clojureRT::protobuf::CaseNode* case_);
  private:
  const ::clojureRT::protobuf::CaseNode& _internal_case_() const;
  ::clojureRT::protobuf::CaseNode* _internal_mutable_case_();
  public:
  void unsafe_arena_set_allocated_case_(
      ::clojureRT::protobuf::CaseNode* case_);
  ::clojureRT::protobuf::CaseNode* unsafe_arena_release_case_();

  // .clojureRT.protobuf.CaseTestNode caseTest = 3;
  bool has_casetest() const;
  private:
  bool _internal_has_casetest() const;
  public:
  void clear_casetest();
  const ::clojureRT::protobuf::CaseTestNode& casetest() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::CaseTestNode* release_casetest();
  ::clojureRT::protobuf::CaseTestNode* mutable_casetest();
  void set_allocated_casetest(::clojureRT::protobuf::CaseTestNode* casetest);
  private:
  const ::clojureRT::protobuf::CaseTestNode& _internal_casetest() const;
  ::clojureRT::protobuf::CaseTestNode* _internal_mutable_casetest();
  public:
  void unsafe_arena_set_allocated_casetest(
      ::clojureRT::protobuf::CaseTestNode* casetest);
  ::clojureRT::protobuf::CaseTestNode* unsafe_arena_release_casetest();

  // .clojureRT.protobuf.CaseThenNode caseThen = 4;
  bool has_casethen() const;
  private:
  bool _internal_has_casethen() const;
  public:
  void clear_casethen();
  const ::clojureRT::protobuf::CaseThenNode& casethen() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::CaseThenNode* release_casethen();
  ::clojureRT::protobuf::CaseThenNode* mutable_casethen();
  void set_allocated_casethen(::clojureRT::protobuf::CaseThenNode* casethen);
  private:
  const ::clojureRT::protobuf::CaseThenNode& _internal_casethen() const;
  ::clojureRT::protobuf::CaseThenNode* _internal_mutable_casethen();
  public:
  void unsafe_arena_set_allocated_casethen(
      ::clojureRT::protobuf::CaseThenNode* casethen);
  ::clojureRT::protobuf::CaseThenNode* unsafe_arena_release_casethen();

  // .clojureRT.protobuf.CatchNode catch = 5;
  bool has_catch_() const;
  private:
  bool _internal_has_catch_() const;
  public:
  void clear_catch_();
  const ::clojureRT::protobuf::CatchNode& catch_() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::CatchNode* release_catch_();
  ::clojureRT::protobuf::CatchNode* mutable_catch_();
  void set_allocated_catch_(::clojureRT::protobuf::CatchNode* catch_);
  private:
  const ::clojureRT::protobuf::CatchNode& _internal_catch_() const;
  ::clojureRT::protobuf::CatchNode* _internal_mutable_catch_();
  public:
  void unsafe_arena_set_allocated_catch_(
      ::clojureRT::protobuf::CatchNode* catch_);
  ::clojureRT::protobuf::CatchNode* unsafe_arena_release_catch_();

  // .clojureRT.protobuf.ConstNode const = 6;
  bool has_const_() const;
  private:
  bool _internal_has_const_() const;
  public:
  void clear_const_();
  const ::clojureRT::protobuf::ConstNode& const_() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::ConstNode* release_const_();
  ::clojureRT::protobuf::ConstNode* mutable_const_();
  void set_allocated_const_(::clojureRT::protobuf::ConstNode* const_);
  private:
  const ::clojureRT::protobuf::ConstNode& _internal_const_() const;
  ::clojureRT::protobuf::ConstNode* _internal_mutable_const_();
  public:
  void unsafe_arena_set_allocated_const_(
      ::clojureRT::protobuf::ConstNode* const_);
  ::clojureRT::protobuf::ConstNode* unsafe_arena_release_const_();

  // .clojureRT.protobuf.DefNode def = 7;
  bool has_def() const;
  private:
  bool _internal_has_def() const;
  public:
  void clear_def();
  const ::clojureRT::protobuf::DefNode& def() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::DefNode* release_def();
  ::clojureRT::protobuf::DefNode* mutable_def();
  void set_allocated_def(::clojureRT::protobuf::DefNode* def);
  private:
  const ::clojureRT::protobuf::DefNode& _internal_def() const;
  ::clojureRT::protobuf::DefNode* _internal_mutable_def();
  public:
  void unsafe_arena_set_allocated_def(
      ::clojureRT::protobuf::DefNode* def);
  ::clojureRT::protobuf::DefNode* unsafe_arena_release_def();

  // .clojureRT.protobuf.DeftypeNode deftype = 8;
  bool has_deftype() const;
  private:
  bool _internal_has_deftype() const;
  public:
  void clear_deftype();
  const ::clojureRT::protobuf::DeftypeNode& deftype() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::DeftypeNode* release_deftype();
  ::clojureRT::protobuf::DeftypeNode* mutable_deftype();
  void set_allocated_deftype(::clojureRT::protobuf::DeftypeNode* deftype);
  private:
  const ::clojureRT::protobuf::DeftypeNode& _internal_deftype() const;
  ::clojureRT::protobuf::DeftypeNode* _internal_mutable_deftype();
  public:
  void unsafe_arena_set_allocated_deftype(
      ::clojureRT::protobuf::DeftypeNode* deftype);
  ::clojureRT::protobuf::DeftypeNode* unsafe_arena_release_deftype();

  // .clojureRT.protobuf.DoNode do = 9;
  bool has_do_() const;
  private:
  bool _internal_has_do_() const;
  public:
  void clear_do_();
  const ::clojureRT::protobuf::DoNode& do_() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::DoNode* release_do_();
  ::clojureRT::protobuf::DoNode* mutable_do_();
  void set_allocated_do_(::clojureRT::protobuf::DoNode* do_);
  private:
  const ::clojureRT::protobuf::DoNode& _internal_do_() const;
  ::clojureRT::protobuf::DoNode* _internal_mutable_do_();
  public:
  void unsafe_arena_set_allocated_do_(
      ::clojureRT::protobuf::DoNode* do_);
  ::clojureRT::protobuf::DoNode* unsafe_arena_release_do_();

  // .clojureRT.protobuf.FnNode fn = 10;
  bool has_fn() const;
  private:
  bool _internal_has_fn() const;
  public:
  void clear_fn();
  const ::clojureRT::protobuf::FnNode& fn() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::FnNode* release_fn();
  ::clojureRT::protobuf::FnNode* mutable_fn();
  void set_allocated_fn(::clojureRT::protobuf::FnNode* fn);
  private:
  const ::clojureRT::protobuf::FnNode& _internal_fn() const;
  ::clojureRT::protobuf::FnNode* _internal_mutable_fn();
  public:
  void unsafe_arena_set_allocated_fn(
      ::clojureRT::protobuf::FnNode* fn);
  ::clojureRT::protobuf::FnNode* unsafe_arena_release_fn();

  // .clojureRT.protobuf.FnMethodNode fnMethod = 11;
  bool has_fnmethod() const;
  private:
  bool _internal_has_fnmethod() const;
  public:
  void clear_fnmethod();
  const ::clojureRT::protobuf::FnMethodNode& fnmethod() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::FnMethodNode* release_fnmethod();
  ::clojureRT::protobuf::FnMethodNode* mutable_fnmethod();
  void set_allocated_fnmethod(::clojureRT::protobuf::FnMethodNode* fnmethod);
  private:
  const ::clojureRT::protobuf::FnMethodNode& _internal_fnmethod() const;
  ::clojureRT::protobuf::FnMethodNode* _internal_mutable_fnmethod();
  public:
  void unsafe_arena_set_allocated_fnmethod(
      ::clojureRT::protobuf::FnMethodNode* fnmethod);
  ::clojureRT::protobuf::FnMethodNode* unsafe_arena_release_fnmethod();

  // .clojureRT.protobuf.HostInteropNode hostInterop = 12;
  bool has_hostinterop() const;
  private:
  bool _internal_has_hostinterop() const;
  public:
  void clear_hostinterop();
  const ::clojureRT::protobuf::HostInteropNode& hostinterop() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::HostInteropNode* release_hostinterop();
  ::clojureRT::protobuf::HostInteropNode* mutable_hostinterop();
  void set_allocated_hostinterop(::clojureRT::protobuf::HostInteropNode* hostinterop);
  private:
  const ::clojureRT::protobuf::HostInteropNode& _internal_hostinterop() const;
  ::clojureRT::protobuf::HostInteropNode* _internal_mutable_hostinterop();
  public:
  void unsafe_arena_set_allocated_hostinterop(
      ::clojureRT::protobuf::HostInteropNode* hostinterop);
  ::clojureRT::protobuf::HostInteropNode* unsafe_arena_release_hostinterop();

  // .clojureRT.protobuf.IfNode if = 13;
  bool has_if_() const;
  private:
  bool _internal_has_if_() const;
  public:
  void clear_if_();
  const ::clojureRT::protobuf::IfNode& if_() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::IfNode* release_if_();
  ::clojureRT::protobuf::IfNode* mutable_if_();
  void set_allocated_if_(::clojureRT::protobuf::IfNode* if_);
  private:
  const ::clojureRT::protobuf::IfNode& _internal_if_() const;
  ::clojureRT::protobuf::IfNode* _internal_mutable_if_();
  public:
  void unsafe_arena_set_allocated_if_(
      ::clojureRT::protobuf::IfNode* if_);
  ::clojureRT::protobuf::IfNode* unsafe_arena_release_if_();

  // .clojureRT.protobuf.ImportNode import = 14;
  bool has_import() const;
  private:
  bool _internal_has_import() const;
  public:
  void clear_import();
  const ::clojureRT::protobuf::ImportNode& import() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::ImportNode* release_import();
  ::clojureRT::protobuf::ImportNode* mutable_import();
  void set_allocated_import(::clojureRT::protobuf::ImportNode* import);
  private:
  const ::clojureRT::protobuf::ImportNode& _internal_import() const;
  ::clojureRT::protobuf::ImportNode* _internal_mutable_import();
  public:
  void unsafe_arena_set_allocated_import(
      ::clojureRT::protobuf::ImportNode* import);
  ::clojureRT::protobuf::ImportNode* unsafe_arena_release_import();

  // .clojureRT.protobuf.InstanceCallNode instanceCall = 15;
  bool has_instancecall() const;
  private:
  bool _internal_has_instancecall() const;
  public:
  void clear_instancecall();
  const ::clojureRT::protobuf::InstanceCallNode& instancecall() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::InstanceCallNode* release_instancecall();
  ::clojureRT::protobuf::InstanceCallNode* mutable_instancecall();
  void set_allocated_instancecall(::clojureRT::protobuf::InstanceCallNode* instancecall);
  private:
  const ::clojureRT::protobuf::InstanceCallNode& _internal_instancecall() const;
  ::clojureRT::protobuf::InstanceCallNode* _internal_mutable_instancecall();
  public:
  void unsafe_arena_set_allocated_instancecall(
      ::clojureRT::protobuf::InstanceCallNode* instancecall);
  ::clojureRT::protobuf::InstanceCallNode* unsafe_arena_release_instancecall();

  // .clojureRT.protobuf.InstanceFieldNode instanceField = 16;
  bool has_instancefield() const;
  private:
  bool _internal_has_instancefield() const;
  public:
  void clear_instancefield();
  const ::clojureRT::protobuf::InstanceFieldNode& instancefield() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::InstanceFieldNode* release_instancefield();
  ::clojureRT::protobuf::InstanceFieldNode* mutable_instancefield();
  void set_allocated_instancefield(::clojureRT::protobuf::InstanceFieldNode* instancefield);
  private:
  const ::clojureRT::protobuf::InstanceFieldNode& _internal_instancefield() const;
  ::clojureRT::protobuf::InstanceFieldNode* _internal_mutable_instancefield();
  public:
  void unsafe_arena_set_allocated_instancefield(
      ::clojureRT::protobuf::InstanceFieldNode* instancefield);
  ::clojureRT::protobuf::InstanceFieldNode* unsafe_arena_release_instancefield();

  // .clojureRT.protobuf.IsInstanceNode isInstance = 17;
  bool has_isinstance() const;
  private:
  bool _internal_has_isinstance() const;
  public:
  void clear_isinstance();
  const ::clojureRT::protobuf::IsInstanceNode& isinstance() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::IsInstanceNode* release_isinstance();
  ::clojureRT::protobuf::IsInstanceNode* mutable_isinstance();
  void set_allocated_isinstance(::clojureRT::protobuf::IsInstanceNode* isinstance);
  private:
  const ::clojureRT::protobuf::IsInstanceNode& _internal_isinstance() const;
  ::clojureRT::protobuf::IsInstanceNode* _internal_mutable_isinstance();
  public:
  void unsafe_arena_set_allocated_isinstance(
      ::clojureRT::protobuf::IsInstanceNode* isinstance);
  ::clojureRT::protobuf::IsInstanceNode* unsafe_arena_release_isinstance();

  // .clojureRT.protobuf.InvokeNode invoke = 18;
  bool has_invoke() const;
  private:
  bool _internal_has_invoke() const;
  public:
  void clear_invoke();
  const ::clojureRT::protobuf::InvokeNode& invoke() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::InvokeNode* release_invoke();
  ::clojureRT::protobuf::InvokeNode* mutable_invoke();
  void set_allocated_invoke(::clojureRT::protobuf::InvokeNode* invoke);
  private:
  const ::clojureRT::protobuf::InvokeNode& _internal_invoke() const;
  ::clojureRT::protobuf::InvokeNode* _internal_mutable_invoke();
  public:
  void unsafe_arena_set_allocated_invoke(
      ::clojureRT::protobuf::InvokeNode* invoke);
  ::clojureRT::protobuf::InvokeNode* unsafe_arena_release_invoke();

  // .clojureRT.protobuf.KeywordInvokeNode keywordInvoke = 19;
  bool has_keywordinvoke() const;
  private:
  bool _internal_has_keywordinvoke() const;
  public:
  void clear_keywordinvoke();
  const ::clojureRT::protobuf::KeywordInvokeNode& keywordinvoke() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::KeywordInvokeNode* release_keywordinvoke();
  ::clojureRT::protobuf::KeywordInvokeNode* mutable_keywordinvoke();
  void set_allocated_keywordinvoke(::clojureRT::protobuf::KeywordInvokeNode* keywordinvoke);
  private:
  const ::clojureRT::protobuf::KeywordInvokeNode& _internal_keywordinvoke() const;
  ::clojureRT::protobuf::KeywordInvokeNode* _internal_mutable_keywordinvoke();
  public:
  void unsafe_arena_set_allocated_keywordinvoke(
      ::clojureRT::protobuf::KeywordInvokeNode* keywordinvoke);
  ::clojureRT::protobuf::KeywordInvokeNode* unsafe_arena_release_keywordinvoke();

  // .clojureRT.protobuf.LetNode let = 20;
  bool has_let() const;
  private:
  bool _internal_has_let() const;
  public:
  void clear_let();
  const ::clojureRT::protobuf::LetNode& let() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::LetNode* release_let();
  ::clojureRT::protobuf::LetNode* mutable_let();
  void set_allocated_let(::clojureRT::protobuf::LetNode* let);
  private:
  const ::clojureRT::protobuf::LetNode& _internal_let() const;
  ::clojureRT::protobuf::LetNode* _internal_mutable_let();
  public:
  void unsafe_arena_set_allocated_let(
      ::clojureRT::protobuf::LetNode* let);
  ::clojureRT::protobuf::LetNode* unsafe_arena_release_let();

  // .clojureRT.protobuf.LetfnNode letfn = 21;
  bool has_letfn() const;
  private:
  bool _internal_has_letfn() const;
  public:
  void clear_letfn();
  const ::clojureRT::protobuf::LetfnNode& letfn() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::LetfnNode* release_letfn();
  ::clojureRT::protobuf::LetfnNode* mutable_letfn();
  void set_allocated_letfn(::clojureRT::protobuf::LetfnNode* letfn);
  private:
  const ::clojureRT::protobuf::LetfnNode& _internal_letfn() const;
  ::clojureRT::protobuf::LetfnNode* _internal_mutable_letfn();
  public:
  void unsafe_arena_set_allocated_letfn(
      ::clojureRT::protobuf::LetfnNode* letfn);
  ::clojureRT::protobuf::LetfnNode* unsafe_arena_release_letfn();

  // .clojureRT.protobuf.LocalNode local = 22;
  bool has_local() const;
  private:
  bool _internal_has_local() const;
  public:
  void clear_local();
  const ::clojureRT::protobuf::LocalNode& local() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::LocalNode* release_local();
  ::clojureRT::protobuf::LocalNode* mutable_local();
  void set_allocated_local(::clojureRT::protobuf::LocalNode* local);
  private:
  const ::clojureRT::protobuf::LocalNode& _internal_local() const;
  ::clojureRT::protobuf::LocalNode* _internal_mutable_local();
  public:
  void unsafe_arena_set_allocated_local(
      ::clojureRT::protobuf::LocalNode* local);
  ::clojureRT::protobuf::LocalNode* unsafe_arena_release_local();

  // .clojureRT.protobuf.LoopNode loop = 23;
  bool has_loop() const;
  private:
  bool _internal_has_loop() const;
  public:
  void clear_loop();
  const ::clojureRT::protobuf::LoopNode& loop() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::LoopNode* release_loop();
  ::clojureRT::protobuf::LoopNode* mutable_loop();
  void set_allocated_loop(::clojureRT::protobuf::LoopNode* loop);
  private:
  const ::clojureRT::protobuf::LoopNode& _internal_loop() const;
  ::clojureRT::protobuf::LoopNode* _internal_mutable_loop();
  public:
  void unsafe_arena_set_allocated_loop(
      ::clojureRT::protobuf::LoopNode* loop);
  ::clojureRT::protobuf::LoopNode* unsafe_arena_release_loop();

  // .clojureRT.protobuf.MapNode map = 24;
  bool has_map() const;
  private:
  bool _internal_has_map() const;
  public:
  void clear_map();
  const ::clojureRT::protobuf::MapNode& map() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::MapNode* release_map();
  ::clojureRT::protobuf::MapNode* mutable_map();
  void set_allocated_map(::clojureRT::protobuf::MapNode* map);
  private:
  const ::clojureRT::protobuf::MapNode& _internal_map() const;
  ::clojureRT::protobuf::MapNode* _internal_mutable_map();
  public:
  void unsafe_arena_set_allocated_map(
      ::clojureRT::protobuf::MapNode* map);
  ::clojureRT::protobuf::MapNode* unsafe_arena_release_map();

  // .clojureRT.protobuf.MethodNode method = 25;
  bool has_method() const;
  private:
  bool _internal_has_method() const;
  public:
  void clear_method();
  const ::clojureRT::protobuf::MethodNode& method() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::MethodNode* release_method();
  ::clojureRT::protobuf::MethodNode* mutable_method();
  void set_allocated_method(::clojureRT::protobuf::MethodNode* method);
  private:
  const ::clojureRT::protobuf::MethodNode& _internal_method() const;
  ::clojureRT::protobuf::MethodNode* _internal_mutable_method();
  public:
  void unsafe_arena_set_allocated_method(
      ::clojureRT::protobuf::MethodNode* method);
  ::clojureRT::protobuf::MethodNode* unsafe_arena_release_method();

  // .clojureRT.protobuf.MonitorEnterNode monitorEnter = 26;
  bool has_monitorenter() const;
  private:
  bool _internal_has_monitorenter() const;
  public:
  void clear_monitorenter();
  const ::clojureRT::protobuf::MonitorEnterNode& monitorenter() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::MonitorEnterNode* release_monitorenter();
  ::clojureRT::protobuf::MonitorEnterNode* mutable_monitorenter();
  void set_allocated_monitorenter(::clojureRT::protobuf::MonitorEnterNode* monitorenter);
  private:
  const ::clojureRT::protobuf::MonitorEnterNode& _internal_monitorenter() const;
  ::clojureRT::protobuf::MonitorEnterNode* _internal_mutable_monitorenter();
  public:
  void unsafe_arena_set_allocated_monitorenter(
      ::clojureRT::protobuf::MonitorEnterNode* monitorenter);
  ::clojureRT::protobuf::MonitorEnterNode* unsafe_arena_release_monitorenter();

  // .clojureRT.protobuf.MonitorExitNode monitorExit = 27;
  bool has_monitorexit() const;
  private:
  bool _internal_has_monitorexit() const;
  public:
  void clear_monitorexit();
  const ::clojureRT::protobuf::MonitorExitNode& monitorexit() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::MonitorExitNode* release_monitorexit();
  ::clojureRT::protobuf::MonitorExitNode* mutable_monitorexit();
  void set_allocated_monitorexit(::clojureRT::protobuf::MonitorExitNode* monitorexit);
  private:
  const ::clojureRT::protobuf::MonitorExitNode& _internal_monitorexit() const;
  ::clojureRT::protobuf::MonitorExitNode* _internal_mutable_monitorexit();
  public:
  void unsafe_arena_set_allocated_monitorexit(
      ::clojureRT::protobuf::MonitorExitNode* monitorexit);
  ::clojureRT::protobuf::MonitorExitNode* unsafe_arena_release_monitorexit();

  // .clojureRT.protobuf.NewNode new = 28;
  bool has_new_() const;
  private:
  bool _internal_has_new_() const;
  public:
  void clear_new_();
  const ::clojureRT::protobuf::NewNode& new_() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::NewNode* release_new_();
  ::clojureRT::protobuf::NewNode* mutable_new_();
  void set_allocated_new_(::clojureRT::protobuf::NewNode* new_);
  private:
  const ::clojureRT::protobuf::NewNode& _internal_new_() const;
  ::clojureRT::protobuf::NewNode* _internal_mutable_new_();
  public:
  void unsafe_arena_set_allocated_new_(
      ::clojureRT::protobuf::NewNode* new_);
  ::clojureRT::protobuf::NewNode* unsafe_arena_release_new_();

  // .clojureRT.protobuf.PrimInvokeNode primInvoke = 29;
  bool has_priminvoke() const;
  private:
  bool _internal_has_priminvoke() const;
  public:
  void clear_priminvoke();
  const ::clojureRT::protobuf::PrimInvokeNode& priminvoke() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::PrimInvokeNode* release_priminvoke();
  ::clojureRT::protobuf::PrimInvokeNode* mutable_priminvoke();
  void set_allocated_priminvoke(::clojureRT::protobuf::PrimInvokeNode* priminvoke);
  private:
  const ::clojureRT::protobuf::PrimInvokeNode& _internal_priminvoke() const;
  ::clojureRT::protobuf::PrimInvokeNode* _internal_mutable_priminvoke();
  public:
  void unsafe_arena_set_allocated_priminvoke(
      ::clojureRT::protobuf::PrimInvokeNode* priminvoke);
  ::clojureRT::protobuf::PrimInvokeNode* unsafe_arena_release_priminvoke();

  // .clojureRT.protobuf.ProtocolInvokeNode protocolInvoke = 30;
  bool has_protocolinvoke() const;
  private:
  bool _internal_has_protocolinvoke() const;
  public:
  void clear_protocolinvoke();
  const ::clojureRT::protobuf::ProtocolInvokeNode& protocolinvoke() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::ProtocolInvokeNode* release_protocolinvoke();
  ::clojureRT::protobuf::ProtocolInvokeNode* mutable_protocolinvoke();
  void set_allocated_protocolinvoke(::clojureRT::protobuf::ProtocolInvokeNode* protocolinvoke);
  private:
  const ::clojureRT::protobuf::ProtocolInvokeNode& _internal_protocolinvoke() const;
  ::clojureRT::protobuf::ProtocolInvokeNode* _internal_mutable_protocolinvoke();
  public:
  void unsafe_arena_set_allocated_protocolinvoke(
      ::clojureRT::protobuf::ProtocolInvokeNode* protocolinvoke);
  ::clojureRT::protobuf::ProtocolInvokeNode* unsafe_arena_release_protocolinvoke();

  // .clojureRT.protobuf.QuoteNode quote = 31;
  bool has_quote() const;
  private:
  bool _internal_has_quote() const;
  public:
  void clear_quote();
  const ::clojureRT::protobuf::QuoteNode& quote() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::QuoteNode* release_quote();
  ::clojureRT::protobuf::QuoteNode* mutable_quote();
  void set_allocated_quote(::clojureRT::protobuf::QuoteNode* quote);
  private:
  const ::clojureRT::protobuf::QuoteNode& _internal_quote() const;
  ::clojureRT::protobuf::QuoteNode* _internal_mutable_quote();
  public:
  void unsafe_arena_set_allocated_quote(
      ::clojureRT::protobuf::QuoteNode* quote);
  ::clojureRT::protobuf::QuoteNode* unsafe_arena_release_quote();

  // .clojureRT.protobuf.RecurNode recur = 32;
  bool has_recur() const;
  private:
  bool _internal_has_recur() const;
  public:
  void clear_recur();
  const ::clojureRT::protobuf::RecurNode& recur() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::RecurNode* release_recur();
  ::clojureRT::protobuf::RecurNode* mutable_recur();
  void set_allocated_recur(::clojureRT::protobuf::RecurNode* recur);
  private:
  const ::clojureRT::protobuf::RecurNode& _internal_recur() const;
  ::clojureRT::protobuf::RecurNode* _internal_mutable_recur();
  public:
  void unsafe_arena_set_allocated_recur(
      ::clojureRT::protobuf::RecurNode* recur);
  ::clojureRT::protobuf::RecurNode* unsafe_arena_release_recur();

  // .clojureRT.protobuf.ReifyNode reify = 33;
  bool has_reify() const;
  private:
  bool _internal_has_reify() const;
  public:
  void clear_reify();
  const ::clojureRT::protobuf::ReifyNode& reify() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::ReifyNode* release_reify();
  ::clojureRT::protobuf::ReifyNode* mutable_reify();
  void set_allocated_reify(::clojureRT::protobuf::ReifyNode* reify);
  private:
  const ::clojureRT::protobuf::ReifyNode& _internal_reify() const;
  ::clojureRT::protobuf::ReifyNode* _internal_mutable_reify();
  public:
  void unsafe_arena_set_allocated_reify(
      ::clojureRT::protobuf::ReifyNode* reify);
  ::clojureRT::protobuf::ReifyNode* unsafe_arena_release_reify();

  // .clojureRT.protobuf.SetNode set = 34;
  bool has_set() const;
  private:
  bool _internal_has_set() const;
  public:
  void clear_set();
  const ::clojureRT::protobuf::SetNode& set() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::SetNode* release_set();
  ::clojureRT::protobuf::SetNode* mutable_set();
  void set_allocated_set(::clojureRT::protobuf::SetNode* set);
  private:
  const ::clojureRT::protobuf::SetNode& _internal_set() const;
  ::clojureRT::protobuf::SetNode* _internal_mutable_set();
  public:
  void unsafe_arena_set_allocated_set(
      ::clojureRT::protobuf::SetNode* set);
  ::clojureRT::protobuf::SetNode* unsafe_arena_release_set();

  // .clojureRT.protobuf.MutateSetNode mutateSet = 35;
  bool has_mutateset() const;
  private:
  bool _internal_has_mutateset() const;
  public:
  void clear_mutateset();
  const ::clojureRT::protobuf::MutateSetNode& mutateset() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::MutateSetNode* release_mutateset();
  ::clojureRT::protobuf::MutateSetNode* mutable_mutateset();
  void set_allocated_mutateset(::clojureRT::protobuf::MutateSetNode* mutateset);
  private:
  const ::clojureRT::protobuf::MutateSetNode& _internal_mutateset() const;
  ::clojureRT::protobuf::MutateSetNode* _internal_mutable_mutateset();
  public:
  void unsafe_arena_set_allocated_mutateset(
      ::clojureRT::protobuf::MutateSetNode* mutateset);
  ::clojureRT::protobuf::MutateSetNode* unsafe_arena_release_mutateset();

  // .clojureRT.protobuf.StaticCallNode staticCall = 36;
  bool has_staticcall() const;
  private:
  bool _internal_has_staticcall() const;
  public:
  void clear_staticcall();
  const ::clojureRT::protobuf::StaticCallNode& staticcall() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::StaticCallNode* release_staticcall();
  ::clojureRT::protobuf::StaticCallNode* mutable_staticcall();
  void set_allocated_staticcall(::clojureRT::protobuf::StaticCallNode* staticcall);
  private:
  const ::clojureRT::protobuf::StaticCallNode& _internal_staticcall() const;
  ::clojureRT::protobuf::StaticCallNode* _internal_mutable_staticcall();
  public:
  void unsafe_arena_set_allocated_staticcall(
      ::clojureRT::protobuf::StaticCallNode* staticcall);
  ::clojureRT::protobuf::StaticCallNode* unsafe_arena_release_staticcall();

  // .clojureRT.protobuf.StaticFieldNode staticField = 37;
  bool has_staticfield() const;
  private:
  bool _internal_has_staticfield() const;
  public:
  void clear_staticfield();
  const ::clojureRT::protobuf::StaticFieldNode& staticfield() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::StaticFieldNode* release_staticfield();
  ::clojureRT::protobuf::StaticFieldNode* mutable_staticfield();
  void set_allocated_staticfield(::clojureRT::protobuf::StaticFieldNode* staticfield);
  private:
  const ::clojureRT::protobuf::StaticFieldNode& _internal_staticfield() const;
  ::clojureRT::protobuf::StaticFieldNode* _internal_mutable_staticfield();
  public:
  void unsafe_arena_set_allocated_staticfield(
      ::clojureRT::protobuf::StaticFieldNode* staticfield);
  ::clojureRT::protobuf::StaticFieldNode* unsafe_arena_release_staticfield();

  // .clojureRT.protobuf.TheVarNode theVar = 38;
  bool has_thevar() const;
  private:
  bool _internal_has_thevar() const;
  public:
  void clear_thevar();
  const ::clojureRT::protobuf::TheVarNode& thevar() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::TheVarNode* release_thevar();
  ::clojureRT::protobuf::TheVarNode* mutable_thevar();
  void set_allocated_thevar(::clojureRT::protobuf::TheVarNode* thevar);
  private:
  const ::clojureRT::protobuf::TheVarNode& _internal_thevar() const;
  ::clojureRT::protobuf::TheVarNode* _internal_mutable_thevar();
  public:
  void unsafe_arena_set_allocated_thevar(
      ::clojureRT::protobuf::TheVarNode* thevar);
  ::clojureRT::protobuf::TheVarNode* unsafe_arena_release_thevar();

  // .clojureRT.protobuf.ThrowNode throw = 39;
  bool has_throw_() const;
  private:
  bool _internal_has_throw_() const;
  public:
  void clear_throw_();
  const ::clojureRT::protobuf::ThrowNode& throw_() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::ThrowNode* release_throw_();
  ::clojureRT::protobuf::ThrowNode* mutable_throw_();
  void set_allocated_throw_(::clojureRT::protobuf::ThrowNode* throw_);
  private:
  const ::clojureRT::protobuf::ThrowNode& _internal_throw_() const;
  ::clojureRT::protobuf::ThrowNode* _internal_mutable_throw_();
  public:
  void unsafe_arena_set_allocated_throw_(
      ::clojureRT::protobuf::ThrowNode* throw_);
  ::clojureRT::protobuf::ThrowNode* unsafe_arena_release_throw_();

  // .clojureRT.protobuf.TryNode try = 40;
  bool has_try_() const;
  private:
  bool _internal_has_try_() const;
  public:
  void clear_try_();
  const ::clojureRT::protobuf::TryNode& try_() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::TryNode* release_try_();
  ::clojureRT::protobuf::TryNode* mutable_try_();
  void set_allocated_try_(::clojureRT::protobuf::TryNode* try_);
  private:
  const ::clojureRT::protobuf::TryNode& _internal_try_() const;
  ::clojureRT::protobuf::TryNode* _internal_mutable_try_();
  public:
  void unsafe_arena_set_allocated_try_(
      ::clojureRT::protobuf::TryNode* try_);
  ::clojureRT::protobuf::TryNode* unsafe_arena_release_try_();

  // .clojureRT.protobuf.VarNode var = 41;
  bool has_var() const;
  private:
  bool _internal_has_var() const;
  public:
  void clear_var();
  const ::clojureRT::protobuf::VarNode& var() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::VarNode* release_var();
  ::clojureRT::protobuf::VarNode* mutable_var();
  void set_allocated_var(::clojureRT::protobuf::VarNode* var);
  private:
  const ::clojureRT::protobuf::VarNode& _internal_var() const;
  ::clojureRT::protobuf::VarNode* _internal_mutable_var();
  public:
  void unsafe_arena_set_allocated_var(
      ::clojureRT::protobuf::VarNode* var);
  ::clojureRT::protobuf::VarNode* unsafe_arena_release_var();

  // .clojureRT.protobuf.VectorNode vector = 42;
  bool has_vector() const;
  private:
  bool _internal_has_vector() const;
  public:
  void clear_vector();
  const ::clojureRT::protobuf::VectorNode& vector() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::VectorNode* release_vector();
  ::clojureRT::protobuf::VectorNode* mutable_vector();
  void set_allocated_vector(::clojureRT::protobuf::VectorNode* vector);
  private:
  const ::clojureRT::protobuf::VectorNode& _internal_vector() const;
  ::clojureRT::protobuf::VectorNode* _internal_mutable_vector();
  public:
  void unsafe_arena_set_allocated_vector(
      ::clojureRT::protobuf::VectorNode* vector);
  ::clojureRT::protobuf::VectorNode* unsafe_arena_release_vector();

  // .clojureRT.protobuf.WithMetaNode withMeta = 43;
  bool has_withmeta() const;
  private:
  bool _internal_has_withmeta() const;
  public:
  void clear_withmeta();
  const ::clojureRT::protobuf::WithMetaNode& withmeta() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::WithMetaNode* release_withmeta();
  ::clojureRT::protobuf::WithMetaNode* mutable_withmeta();
  void set_allocated_withmeta(::clojureRT::protobuf::WithMetaNode* withmeta);
  private:
  const ::clojureRT::protobuf::WithMetaNode& _internal_withmeta() const;
  ::clojureRT::protobuf::WithMetaNode* _internal_mutable_withmeta();
  public:
  void unsafe_arena_set_allocated_withmeta(
      ::clojureRT::protobuf::WithMetaNode* withmeta);
  ::clojureRT::protobuf::WithMetaNode* unsafe_arena_release_withmeta();

  void clear_types();
  TypesCase types_case() const;
  // @@protoc_insertion_point(class_scope:clojureRT.protobuf.Subnode)
 private:
  class _Internal;
  void set_has_binding();
  void set_has_case_();
  void set_has_casetest();
  void set_has_casethen();
  void set_has_catch_();
  void set_has_const_();
  void set_has_def();
  void set_has_deftype();
  void set_has_do_();
  void set_has_fn();
  void set_has_fnmethod();
  void set_has_hostinterop();
  void set_has_if_();
  void set_has_import();
  void set_has_instancecall();
  void set_has_instancefield();
  void set_has_isinstance();
  void set_has_invoke();
  void set_has_keywordinvoke();
  void set_has_let();
  void set_has_letfn();
  void set_has_local();
  void set_has_loop();
  void set_has_map();
  void set_has_method();
  void set_has_monitorenter();
  void set_has_monitorexit();
  void set_has_new_();
  void set_has_priminvoke();
  void set_has_protocolinvoke();
  void set_has_quote();
  void set_has_recur();
  void set_has_reify();
  void set_has_set();
  void set_has_mutateset();
  void set_has_staticcall();
  void set_has_staticfield();
  void set_has_thevar();
  void set_has_throw_();
  void set_has_try_();
  void set_has_var();
  void set_has_vector();
  void set_has_withmeta();

  inline bool has_types() const;
  inline void clear_has_types();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union TypesUnion {
      constexpr TypesUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::clojureRT::protobuf::BindingNode* binding_;
      ::clojureRT::protobuf::CaseNode* case__;
      ::clojureRT::protobuf::CaseTestNode* casetest_;
      ::clojureRT::protobuf::CaseThenNode* casethen_;
      ::clojureRT::protobuf::CatchNode* catch__;
      ::clojureRT::protobuf::ConstNode* const__;
      ::clojureRT::protobuf::DefNode* def_;
      ::clojureRT::protobuf::DeftypeNode* deftype_;
      ::clojureRT::protobuf::DoNode* do__;
      ::clojureRT::protobuf::FnNode* fn_;
      ::clojureRT::protobuf::FnMethodNode* fnmethod_;
      ::clojureRT::protobuf::HostInteropNode* hostinterop_;
      ::clojureRT::protobuf::IfNode* if__;
      ::clojureRT::protobuf::ImportNode* import_;
      ::clojureRT::protobuf::InstanceCallNode* instancecall_;
      ::clojureRT::protobuf::InstanceFieldNode* instancefield_;
      ::clojureRT::protobuf::IsInstanceNode* isinstance_;
      ::clojureRT::protobuf::InvokeNode* invoke_;
      ::clojureRT::protobuf::KeywordInvokeNode* keywordinvoke_;
      ::clojureRT::protobuf::LetNode* let_;
      ::clojureRT::protobuf::LetfnNode* letfn_;
      ::clojureRT::protobuf::LocalNode* local_;
      ::clojureRT::protobuf::LoopNode* loop_;
      ::clojureRT::protobuf::MapNode* map_;
      ::clojureRT::protobuf::MethodNode* method_;
      ::clojureRT::protobuf::MonitorEnterNode* monitorenter_;
      ::clojureRT::protobuf::MonitorExitNode* monitorexit_;
      ::clojureRT::protobuf::NewNode* new__;
      ::clojureRT::protobuf::PrimInvokeNode* priminvoke_;
      ::clojureRT::protobuf::ProtocolInvokeNode* protocolinvoke_;
      ::clojureRT::protobuf::QuoteNode* quote_;
      ::clojureRT::protobuf::RecurNode* recur_;
      ::clojureRT::protobuf::ReifyNode* reify_;
      ::clojureRT::protobuf::SetNode* set_;
      ::clojureRT::protobuf::MutateSetNode* mutateset_;
      ::clojureRT::protobuf::StaticCallNode* staticcall_;
      ::clojureRT::protobuf::StaticFieldNode* staticfield_;
      ::clojureRT::protobuf::TheVarNode* thevar_;
      ::clojureRT::protobuf::ThrowNode* throw__;
      ::clojureRT::protobuf::TryNode* try__;
      ::clojureRT::protobuf::VarNode* var_;
      ::clojureRT::protobuf::VectorNode* vector_;
      ::clojureRT::protobuf::WithMetaNode* withmeta_;
    } types_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bytecode_2eproto;
};
// -------------------------------------------------------------------

class BindingNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clojureRT.protobuf.BindingNode) */ {
 public:
  inline BindingNode() : BindingNode(nullptr) {}
  ~BindingNode() override;
  explicit PROTOBUF_CONSTEXPR BindingNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BindingNode(const BindingNode& from);
  BindingNode(BindingNode&& from) noexcept
    : BindingNode() {
    *this = ::std::move(from);
  }

  inline BindingNode& operator=(const BindingNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline BindingNode& operator=(BindingNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BindingNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const BindingNode* internal_default_instance() {
    return reinterpret_cast<const BindingNode*>(
               &_BindingNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(BindingNode& a, BindingNode& b) {
    a.Swap(&b);
  }
  inline void Swap(BindingNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BindingNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BindingNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BindingNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BindingNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BindingNode& from) {
    BindingNode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BindingNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clojureRT.protobuf.BindingNode";
  }
  protected:
  explicit BindingNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 4,
    kInitFieldNumber = 2,
    kArgIdFieldNumber = 1,
    kLocalFieldNumber = 3,
    kIsVariadicFieldNumber = 5,
  };
  // string name = 4;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional .clojureRT.protobuf.Node init = 2;
  bool has_init() const;
  private:
  bool _internal_has_init() const;
  public:
  void clear_init();
  const ::clojureRT::protobuf::Node& init() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::Node* release_init();
  ::clojureRT::protobuf::Node* mutable_init();
  void set_allocated_init(::clojureRT::protobuf::Node* init);
  private:
  const ::clojureRT::protobuf::Node& _internal_init() const;
  ::clojureRT::protobuf::Node* _internal_mutable_init();
  public:
  void unsafe_arena_set_allocated_init(
      ::clojureRT::protobuf::Node* init);
  ::clojureRT::protobuf::Node* unsafe_arena_release_init();

  // optional uint32 argId = 1;
  bool has_argid() const;
  private:
  bool _internal_has_argid() const;
  public:
  void clear_argid();
  uint32_t argid() const;
  void set_argid(uint32_t value);
  private:
  uint32_t _internal_argid() const;
  void _internal_set_argid(uint32_t value);
  public:

  // .clojureRT.protobuf.LocalType local = 3;
  void clear_local();
  ::clojureRT::protobuf::LocalType local() const;
  void set_local(::clojureRT::protobuf::LocalType value);
  private:
  ::clojureRT::protobuf::LocalType _internal_local() const;
  void _internal_set_local(::clojureRT::protobuf::LocalType value);
  public:

  // optional bool isVariadic = 5;
  bool has_isvariadic() const;
  private:
  bool _internal_has_isvariadic() const;
  public:
  void clear_isvariadic();
  bool isvariadic() const;
  void set_isvariadic(bool value);
  private:
  bool _internal_isvariadic() const;
  void _internal_set_isvariadic(bool value);
  public:

  // @@protoc_insertion_point(class_scope:clojureRT.protobuf.BindingNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::clojureRT::protobuf::Node* init_;
    uint32_t argid_;
    int local_;
    bool isvariadic_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bytecode_2eproto;
};
// -------------------------------------------------------------------

class CaseNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clojureRT.protobuf.CaseNode) */ {
 public:
  inline CaseNode() : CaseNode(nullptr) {}
  ~CaseNode() override;
  explicit PROTOBUF_CONSTEXPR CaseNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CaseNode(const CaseNode& from);
  CaseNode(CaseNode&& from) noexcept
    : CaseNode() {
    *this = ::std::move(from);
  }

  inline CaseNode& operator=(const CaseNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline CaseNode& operator=(CaseNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CaseNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const CaseNode* internal_default_instance() {
    return reinterpret_cast<const CaseNode*>(
               &_CaseNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CaseNode& a, CaseNode& b) {
    a.Swap(&b);
  }
  inline void Swap(CaseNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CaseNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CaseNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CaseNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CaseNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CaseNode& from) {
    CaseNode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CaseNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clojureRT.protobuf.CaseNode";
  }
  protected:
  explicit CaseNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CaseNode_SwitchType SwitchType;
  static constexpr SwitchType switchTypeSparse =
    CaseNode_SwitchType_switchTypeSparse;
  static constexpr SwitchType switchTypeCompact =
    CaseNode_SwitchType_switchTypeCompact;
  static inline bool SwitchType_IsValid(int value) {
    return CaseNode_SwitchType_IsValid(value);
  }
  static constexpr SwitchType SwitchType_MIN =
    CaseNode_SwitchType_SwitchType_MIN;
  static constexpr SwitchType SwitchType_MAX =
    CaseNode_SwitchType_SwitchType_MAX;
  static constexpr int SwitchType_ARRAYSIZE =
    CaseNode_SwitchType_SwitchType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SwitchType_descriptor() {
    return CaseNode_SwitchType_descriptor();
  }
  template<typename T>
  static inline const std::string& SwitchType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SwitchType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SwitchType_Name.");
    return CaseNode_SwitchType_Name(enum_t_value);
  }
  static inline bool SwitchType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SwitchType* value) {
    return CaseNode_SwitchType_Parse(name, value);
  }

  typedef CaseNode_TestType TestType;
  static constexpr TestType testTypeInt =
    CaseNode_TestType_testTypeInt;
  static constexpr TestType testTypeHashEquiv =
    CaseNode_TestType_testTypeHashEquiv;
  static constexpr TestType testTypeHashIdentity =
    CaseNode_TestType_testTypeHashIdentity;
  static inline bool TestType_IsValid(int value) {
    return CaseNode_TestType_IsValid(value);
  }
  static constexpr TestType TestType_MIN =
    CaseNode_TestType_TestType_MIN;
  static constexpr TestType TestType_MAX =
    CaseNode_TestType_TestType_MAX;
  static constexpr int TestType_ARRAYSIZE =
    CaseNode_TestType_TestType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  TestType_descriptor() {
    return CaseNode_TestType_descriptor();
  }
  template<typename T>
  static inline const std::string& TestType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TestType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TestType_Name.");
    return CaseNode_TestType_Name(enum_t_value);
  }
  static inline bool TestType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      TestType* value) {
    return CaseNode_TestType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTestsFieldNumber = 10,
    kThensFieldNumber = 11,
    kHighFieldNumber = 2,
    kLowFieldNumber = 3,
    kIsSkipCheckFieldNumber = 6,
    kDefaultFieldNumber = 1,
    kTestFieldNumber = 8,
    kMaskFieldNumber = 4,
    kShiftFieldNumber = 5,
    kSwitchTypeFieldNumber = 7,
    kTestTypeFieldNumber = 9,
  };
  // repeated .clojureRT.protobuf.Node tests = 10;
  int tests_size() const;
  private:
  int _internal_tests_size() const;
  public:
  void clear_tests();
  ::clojureRT::protobuf::Node* mutable_tests(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >*
      mutable_tests();
  private:
  const ::clojureRT::protobuf::Node& _internal_tests(int index) const;
  ::clojureRT::protobuf::Node* _internal_add_tests();
  public:
  const ::clojureRT::protobuf::Node& tests(int index) const;
  ::clojureRT::protobuf::Node* add_tests();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >&
      tests() const;

  // repeated .clojureRT.protobuf.Node thens = 11;
  int thens_size() const;
  private:
  int _internal_thens_size() const;
  public:
  void clear_thens();
  ::clojureRT::protobuf::Node* mutable_thens(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >*
      mutable_thens();
  private:
  const ::clojureRT::protobuf::Node& _internal_thens(int index) const;
  ::clojureRT::protobuf::Node* _internal_add_thens();
  public:
  const ::clojureRT::protobuf::Node& thens(int index) const;
  ::clojureRT::protobuf::Node* add_thens();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >&
      thens() const;

  // string high = 2;
  void clear_high();
  const std::string& high() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_high(ArgT0&& arg0, ArgT... args);
  std::string* mutable_high();
  PROTOBUF_NODISCARD std::string* release_high();
  void set_allocated_high(std::string* high);
  private:
  const std::string& _internal_high() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_high(const std::string& value);
  std::string* _internal_mutable_high();
  public:

  // string low = 3;
  void clear_low();
  const std::string& low() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_low(ArgT0&& arg0, ArgT... args);
  std::string* mutable_low();
  PROTOBUF_NODISCARD std::string* release_low();
  void set_allocated_low(std::string* low);
  private:
  const std::string& _internal_low() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_low(const std::string& value);
  std::string* _internal_mutable_low();
  public:

  // string isSkipCheck = 6;
  void clear_isskipcheck();
  const std::string& isskipcheck() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_isskipcheck(ArgT0&& arg0, ArgT... args);
  std::string* mutable_isskipcheck();
  PROTOBUF_NODISCARD std::string* release_isskipcheck();
  void set_allocated_isskipcheck(std::string* isskipcheck);
  private:
  const std::string& _internal_isskipcheck() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_isskipcheck(const std::string& value);
  std::string* _internal_mutable_isskipcheck();
  public:

  // .clojureRT.protobuf.Node default = 1;
  bool has_default_() const;
  private:
  bool _internal_has_default_() const;
  public:
  void clear_default_();
  const ::clojureRT::protobuf::Node& default_() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::Node* release_default_();
  ::clojureRT::protobuf::Node* mutable_default_();
  void set_allocated_default_(::clojureRT::protobuf::Node* default_);
  private:
  const ::clojureRT::protobuf::Node& _internal_default_() const;
  ::clojureRT::protobuf::Node* _internal_mutable_default_();
  public:
  void unsafe_arena_set_allocated_default_(
      ::clojureRT::protobuf::Node* default_);
  ::clojureRT::protobuf::Node* unsafe_arena_release_default_();

  // .clojureRT.protobuf.Node test = 8;
  bool has_test() const;
  private:
  bool _internal_has_test() const;
  public:
  void clear_test();
  const ::clojureRT::protobuf::Node& test() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::Node* release_test();
  ::clojureRT::protobuf::Node* mutable_test();
  void set_allocated_test(::clojureRT::protobuf::Node* test);
  private:
  const ::clojureRT::protobuf::Node& _internal_test() const;
  ::clojureRT::protobuf::Node* _internal_mutable_test();
  public:
  void unsafe_arena_set_allocated_test(
      ::clojureRT::protobuf::Node* test);
  ::clojureRT::protobuf::Node* unsafe_arena_release_test();

  // uint32 mask = 4;
  void clear_mask();
  uint32_t mask() const;
  void set_mask(uint32_t value);
  private:
  uint32_t _internal_mask() const;
  void _internal_set_mask(uint32_t value);
  public:

  // uint32 shift = 5;
  void clear_shift();
  uint32_t shift() const;
  void set_shift(uint32_t value);
  private:
  uint32_t _internal_shift() const;
  void _internal_set_shift(uint32_t value);
  public:

  // .clojureRT.protobuf.CaseNode.SwitchType switchType = 7;
  void clear_switchtype();
  ::clojureRT::protobuf::CaseNode_SwitchType switchtype() const;
  void set_switchtype(::clojureRT::protobuf::CaseNode_SwitchType value);
  private:
  ::clojureRT::protobuf::CaseNode_SwitchType _internal_switchtype() const;
  void _internal_set_switchtype(::clojureRT::protobuf::CaseNode_SwitchType value);
  public:

  // .clojureRT.protobuf.CaseNode.TestType testType = 9;
  void clear_testtype();
  ::clojureRT::protobuf::CaseNode_TestType testtype() const;
  void set_testtype(::clojureRT::protobuf::CaseNode_TestType value);
  private:
  ::clojureRT::protobuf::CaseNode_TestType _internal_testtype() const;
  void _internal_set_testtype(::clojureRT::protobuf::CaseNode_TestType value);
  public:

  // @@protoc_insertion_point(class_scope:clojureRT.protobuf.CaseNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node > tests_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node > thens_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr high_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr low_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr isskipcheck_;
    ::clojureRT::protobuf::Node* default__;
    ::clojureRT::protobuf::Node* test_;
    uint32_t mask_;
    uint32_t shift_;
    int switchtype_;
    int testtype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bytecode_2eproto;
};
// -------------------------------------------------------------------

class CaseTestNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clojureRT.protobuf.CaseTestNode) */ {
 public:
  inline CaseTestNode() : CaseTestNode(nullptr) {}
  ~CaseTestNode() override;
  explicit PROTOBUF_CONSTEXPR CaseTestNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CaseTestNode(const CaseTestNode& from);
  CaseTestNode(CaseTestNode&& from) noexcept
    : CaseTestNode() {
    *this = ::std::move(from);
  }

  inline CaseTestNode& operator=(const CaseTestNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline CaseTestNode& operator=(CaseTestNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CaseTestNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const CaseTestNode* internal_default_instance() {
    return reinterpret_cast<const CaseTestNode*>(
               &_CaseTestNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CaseTestNode& a, CaseTestNode& b) {
    a.Swap(&b);
  }
  inline void Swap(CaseTestNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CaseTestNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CaseTestNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CaseTestNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CaseTestNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CaseTestNode& from) {
    CaseTestNode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CaseTestNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clojureRT.protobuf.CaseTestNode";
  }
  protected:
  explicit CaseTestNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTestFieldNumber = 2,
    kHashFieldNumber = 1,
  };
  // .clojureRT.protobuf.Node test = 2;
  bool has_test() const;
  private:
  bool _internal_has_test() const;
  public:
  void clear_test();
  const ::clojureRT::protobuf::Node& test() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::Node* release_test();
  ::clojureRT::protobuf::Node* mutable_test();
  void set_allocated_test(::clojureRT::protobuf::Node* test);
  private:
  const ::clojureRT::protobuf::Node& _internal_test() const;
  ::clojureRT::protobuf::Node* _internal_mutable_test();
  public:
  void unsafe_arena_set_allocated_test(
      ::clojureRT::protobuf::Node* test);
  ::clojureRT::protobuf::Node* unsafe_arena_release_test();

  // uint32 hash = 1;
  void clear_hash();
  uint32_t hash() const;
  void set_hash(uint32_t value);
  private:
  uint32_t _internal_hash() const;
  void _internal_set_hash(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:clojureRT.protobuf.CaseTestNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::clojureRT::protobuf::Node* test_;
    uint32_t hash_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bytecode_2eproto;
};
// -------------------------------------------------------------------

class CaseThenNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clojureRT.protobuf.CaseThenNode) */ {
 public:
  inline CaseThenNode() : CaseThenNode(nullptr) {}
  ~CaseThenNode() override;
  explicit PROTOBUF_CONSTEXPR CaseThenNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CaseThenNode(const CaseThenNode& from);
  CaseThenNode(CaseThenNode&& from) noexcept
    : CaseThenNode() {
    *this = ::std::move(from);
  }

  inline CaseThenNode& operator=(const CaseThenNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline CaseThenNode& operator=(CaseThenNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CaseThenNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const CaseThenNode* internal_default_instance() {
    return reinterpret_cast<const CaseThenNode*>(
               &_CaseThenNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CaseThenNode& a, CaseThenNode& b) {
    a.Swap(&b);
  }
  inline void Swap(CaseThenNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CaseThenNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CaseThenNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CaseThenNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CaseThenNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CaseThenNode& from) {
    CaseThenNode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CaseThenNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clojureRT.protobuf.CaseThenNode";
  }
  protected:
  explicit CaseThenNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kThenFieldNumber = 2,
    kHashFieldNumber = 1,
  };
  // .clojureRT.protobuf.Node then = 2;
  bool has_then() const;
  private:
  bool _internal_has_then() const;
  public:
  void clear_then();
  const ::clojureRT::protobuf::Node& then() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::Node* release_then();
  ::clojureRT::protobuf::Node* mutable_then();
  void set_allocated_then(::clojureRT::protobuf::Node* then);
  private:
  const ::clojureRT::protobuf::Node& _internal_then() const;
  ::clojureRT::protobuf::Node* _internal_mutable_then();
  public:
  void unsafe_arena_set_allocated_then(
      ::clojureRT::protobuf::Node* then);
  ::clojureRT::protobuf::Node* unsafe_arena_release_then();

  // uint32 hash = 1;
  void clear_hash();
  uint32_t hash() const;
  void set_hash(uint32_t value);
  private:
  uint32_t _internal_hash() const;
  void _internal_set_hash(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:clojureRT.protobuf.CaseThenNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::clojureRT::protobuf::Node* then_;
    uint32_t hash_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bytecode_2eproto;
};
// -------------------------------------------------------------------

class CatchNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clojureRT.protobuf.CatchNode) */ {
 public:
  inline CatchNode() : CatchNode(nullptr) {}
  ~CatchNode() override;
  explicit PROTOBUF_CONSTEXPR CatchNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CatchNode(const CatchNode& from);
  CatchNode(CatchNode&& from) noexcept
    : CatchNode() {
    *this = ::std::move(from);
  }

  inline CatchNode& operator=(const CatchNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline CatchNode& operator=(CatchNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CatchNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const CatchNode* internal_default_instance() {
    return reinterpret_cast<const CatchNode*>(
               &_CatchNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CatchNode& a, CatchNode& b) {
    a.Swap(&b);
  }
  inline void Swap(CatchNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CatchNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CatchNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CatchNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CatchNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CatchNode& from) {
    CatchNode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CatchNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clojureRT.protobuf.CatchNode";
  }
  protected:
  explicit CatchNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBodyFieldNumber = 1,
    kClassFieldNumber = 2,
    kLocalFieldNumber = 3,
  };
  // .clojureRT.protobuf.Node body = 1;
  bool has_body() const;
  private:
  bool _internal_has_body() const;
  public:
  void clear_body();
  const ::clojureRT::protobuf::Node& body() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::Node* release_body();
  ::clojureRT::protobuf::Node* mutable_body();
  void set_allocated_body(::clojureRT::protobuf::Node* body);
  private:
  const ::clojureRT::protobuf::Node& _internal_body() const;
  ::clojureRT::protobuf::Node* _internal_mutable_body();
  public:
  void unsafe_arena_set_allocated_body(
      ::clojureRT::protobuf::Node* body);
  ::clojureRT::protobuf::Node* unsafe_arena_release_body();

  // .clojureRT.protobuf.Node class = 2;
  bool has_class_() const;
  private:
  bool _internal_has_class_() const;
  public:
  void clear_class_();
  const ::clojureRT::protobuf::Node& class_() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::Node* release_class_();
  ::clojureRT::protobuf::Node* mutable_class_();
  void set_allocated_class_(::clojureRT::protobuf::Node* class_);
  private:
  const ::clojureRT::protobuf::Node& _internal_class_() const;
  ::clojureRT::protobuf::Node* _internal_mutable_class_();
  public:
  void unsafe_arena_set_allocated_class_(
      ::clojureRT::protobuf::Node* class_);
  ::clojureRT::protobuf::Node* unsafe_arena_release_class_();

  // .clojureRT.protobuf.Node local = 3;
  bool has_local() const;
  private:
  bool _internal_has_local() const;
  public:
  void clear_local();
  const ::clojureRT::protobuf::Node& local() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::Node* release_local();
  ::clojureRT::protobuf::Node* mutable_local();
  void set_allocated_local(::clojureRT::protobuf::Node* local);
  private:
  const ::clojureRT::protobuf::Node& _internal_local() const;
  ::clojureRT::protobuf::Node* _internal_mutable_local();
  public:
  void unsafe_arena_set_allocated_local(
      ::clojureRT::protobuf::Node* local);
  ::clojureRT::protobuf::Node* unsafe_arena_release_local();

  // @@protoc_insertion_point(class_scope:clojureRT.protobuf.CatchNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::clojureRT::protobuf::Node* body_;
    ::clojureRT::protobuf::Node* class__;
    ::clojureRT::protobuf::Node* local_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bytecode_2eproto;
};
// -------------------------------------------------------------------

class ConstNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clojureRT.protobuf.ConstNode) */ {
 public:
  inline ConstNode() : ConstNode(nullptr) {}
  ~ConstNode() override;
  explicit PROTOBUF_CONSTEXPR ConstNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConstNode(const ConstNode& from);
  ConstNode(ConstNode&& from) noexcept
    : ConstNode() {
    *this = ::std::move(from);
  }

  inline ConstNode& operator=(const ConstNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConstNode& operator=(ConstNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConstNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConstNode* internal_default_instance() {
    return reinterpret_cast<const ConstNode*>(
               &_ConstNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ConstNode& a, ConstNode& b) {
    a.Swap(&b);
  }
  inline void Swap(ConstNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConstNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConstNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConstNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConstNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConstNode& from) {
    ConstNode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConstNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clojureRT.protobuf.ConstNode";
  }
  protected:
  explicit ConstNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ConstNode_ConstType ConstType;
  static constexpr ConstType constTypeNil =
    ConstNode_ConstType_constTypeNil;
  static constexpr ConstType constTypeBool =
    ConstNode_ConstType_constTypeBool;
  static constexpr ConstType constTypeKeyword =
    ConstNode_ConstType_constTypeKeyword;
  static constexpr ConstType constTypeSymbol =
    ConstNode_ConstType_constTypeSymbol;
  static constexpr ConstType constTypeString =
    ConstNode_ConstType_constTypeString;
  static constexpr ConstType constTypeNumber =
    ConstNode_ConstType_constTypeNumber;
  static constexpr ConstType constTypeType =
    ConstNode_ConstType_constTypeType;
  static constexpr ConstType constTypeRecord =
    ConstNode_ConstType_constTypeRecord;
  static constexpr ConstType constTypeMap =
    ConstNode_ConstType_constTypeMap;
  static constexpr ConstType constTypeVector =
    ConstNode_ConstType_constTypeVector;
  static constexpr ConstType constTypeSet =
    ConstNode_ConstType_constTypeSet;
  static constexpr ConstType constTypeSeq =
    ConstNode_ConstType_constTypeSeq;
  static constexpr ConstType constTypeChar =
    ConstNode_ConstType_constTypeChar;
  static constexpr ConstType constTypeRegex =
    ConstNode_ConstType_constTypeRegex;
  static constexpr ConstType constTypeClass =
    ConstNode_ConstType_constTypeClass;
  static constexpr ConstType constTypeVar =
    ConstNode_ConstType_constTypeVar;
  static constexpr ConstType constTypeUnknown =
    ConstNode_ConstType_constTypeUnknown;
  static inline bool ConstType_IsValid(int value) {
    return ConstNode_ConstType_IsValid(value);
  }
  static constexpr ConstType ConstType_MIN =
    ConstNode_ConstType_ConstType_MIN;
  static constexpr ConstType ConstType_MAX =
    ConstNode_ConstType_ConstType_MAX;
  static constexpr int ConstType_ARRAYSIZE =
    ConstNode_ConstType_ConstType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ConstType_descriptor() {
    return ConstNode_ConstType_descriptor();
  }
  template<typename T>
  static inline const std::string& ConstType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ConstType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ConstType_Name.");
    return ConstNode_ConstType_Name(enum_t_value);
  }
  static inline bool ConstType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ConstType* value) {
    return ConstNode_ConstType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kValFieldNumber = 4,
    kMetaFieldNumber = 2,
    kIsLiteralFieldNumber = 1,
    kTypeFieldNumber = 3,
  };
  // string val = 4;
  void clear_val();
  const std::string& val() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_val(ArgT0&& arg0, ArgT... args);
  std::string* mutable_val();
  PROTOBUF_NODISCARD std::string* release_val();
  void set_allocated_val(std::string* val);
  private:
  const std::string& _internal_val() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_val(const std::string& value);
  std::string* _internal_mutable_val();
  public:

  // optional .clojureRT.protobuf.Node meta = 2;
  bool has_meta() const;
  private:
  bool _internal_has_meta() const;
  public:
  void clear_meta();
  const ::clojureRT::protobuf::Node& meta() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::Node* release_meta();
  ::clojureRT::protobuf::Node* mutable_meta();
  void set_allocated_meta(::clojureRT::protobuf::Node* meta);
  private:
  const ::clojureRT::protobuf::Node& _internal_meta() const;
  ::clojureRT::protobuf::Node* _internal_mutable_meta();
  public:
  void unsafe_arena_set_allocated_meta(
      ::clojureRT::protobuf::Node* meta);
  ::clojureRT::protobuf::Node* unsafe_arena_release_meta();

  // bool isLiteral = 1;
  void clear_isliteral();
  bool isliteral() const;
  void set_isliteral(bool value);
  private:
  bool _internal_isliteral() const;
  void _internal_set_isliteral(bool value);
  public:

  // .clojureRT.protobuf.ConstNode.ConstType type = 3;
  void clear_type();
  ::clojureRT::protobuf::ConstNode_ConstType type() const;
  void set_type(::clojureRT::protobuf::ConstNode_ConstType value);
  private:
  ::clojureRT::protobuf::ConstNode_ConstType _internal_type() const;
  void _internal_set_type(::clojureRT::protobuf::ConstNode_ConstType value);
  public:

  // @@protoc_insertion_point(class_scope:clojureRT.protobuf.ConstNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr val_;
    ::clojureRT::protobuf::Node* meta_;
    bool isliteral_;
    int type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bytecode_2eproto;
};
// -------------------------------------------------------------------

class DefNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clojureRT.protobuf.DefNode) */ {
 public:
  inline DefNode() : DefNode(nullptr) {}
  ~DefNode() override;
  explicit PROTOBUF_CONSTEXPR DefNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DefNode(const DefNode& from);
  DefNode(DefNode&& from) noexcept
    : DefNode() {
    *this = ::std::move(from);
  }

  inline DefNode& operator=(const DefNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline DefNode& operator=(DefNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DefNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const DefNode* internal_default_instance() {
    return reinterpret_cast<const DefNode*>(
               &_DefNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(DefNode& a, DefNode& b) {
    a.Swap(&b);
  }
  inline void Swap(DefNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DefNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DefNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DefNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DefNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DefNode& from) {
    DefNode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DefNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clojureRT.protobuf.DefNode";
  }
  protected:
  explicit DefNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDocFieldNumber = 1,
    kNameFieldNumber = 4,
    kVarFieldNumber = 5,
    kInitFieldNumber = 2,
    kMetaFieldNumber = 3,
  };
  // optional string doc = 1;
  bool has_doc() const;
  private:
  bool _internal_has_doc() const;
  public:
  void clear_doc();
  const std::string& doc() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_doc(ArgT0&& arg0, ArgT... args);
  std::string* mutable_doc();
  PROTOBUF_NODISCARD std::string* release_doc();
  void set_allocated_doc(std::string* doc);
  private:
  const std::string& _internal_doc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_doc(const std::string& value);
  std::string* _internal_mutable_doc();
  public:

  // string name = 4;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string var = 5;
  void clear_var();
  const std::string& var() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_var(ArgT0&& arg0, ArgT... args);
  std::string* mutable_var();
  PROTOBUF_NODISCARD std::string* release_var();
  void set_allocated_var(std::string* var);
  private:
  const std::string& _internal_var() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_var(const std::string& value);
  std::string* _internal_mutable_var();
  public:

  // optional .clojureRT.protobuf.Node init = 2;
  bool has_init() const;
  private:
  bool _internal_has_init() const;
  public:
  void clear_init();
  const ::clojureRT::protobuf::Node& init() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::Node* release_init();
  ::clojureRT::protobuf::Node* mutable_init();
  void set_allocated_init(::clojureRT::protobuf::Node* init);
  private:
  const ::clojureRT::protobuf::Node& _internal_init() const;
  ::clojureRT::protobuf::Node* _internal_mutable_init();
  public:
  void unsafe_arena_set_allocated_init(
      ::clojureRT::protobuf::Node* init);
  ::clojureRT::protobuf::Node* unsafe_arena_release_init();

  // optional .clojureRT.protobuf.Node meta = 3;
  bool has_meta() const;
  private:
  bool _internal_has_meta() const;
  public:
  void clear_meta();
  const ::clojureRT::protobuf::Node& meta() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::Node* release_meta();
  ::clojureRT::protobuf::Node* mutable_meta();
  void set_allocated_meta(::clojureRT::protobuf::Node* meta);
  private:
  const ::clojureRT::protobuf::Node& _internal_meta() const;
  ::clojureRT::protobuf::Node* _internal_mutable_meta();
  public:
  void unsafe_arena_set_allocated_meta(
      ::clojureRT::protobuf::Node* meta);
  ::clojureRT::protobuf::Node* unsafe_arena_release_meta();

  // @@protoc_insertion_point(class_scope:clojureRT.protobuf.DefNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr doc_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr var_;
    ::clojureRT::protobuf::Node* init_;
    ::clojureRT::protobuf::Node* meta_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bytecode_2eproto;
};
// -------------------------------------------------------------------

class DeftypeNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clojureRT.protobuf.DeftypeNode) */ {
 public:
  inline DeftypeNode() : DeftypeNode(nullptr) {}
  ~DeftypeNode() override;
  explicit PROTOBUF_CONSTEXPR DeftypeNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeftypeNode(const DeftypeNode& from);
  DeftypeNode(DeftypeNode&& from) noexcept
    : DeftypeNode() {
    *this = ::std::move(from);
  }

  inline DeftypeNode& operator=(const DeftypeNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeftypeNode& operator=(DeftypeNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeftypeNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeftypeNode* internal_default_instance() {
    return reinterpret_cast<const DeftypeNode*>(
               &_DeftypeNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(DeftypeNode& a, DeftypeNode& b) {
    a.Swap(&b);
  }
  inline void Swap(DeftypeNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeftypeNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeftypeNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeftypeNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeftypeNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeftypeNode& from) {
    DeftypeNode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeftypeNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clojureRT.protobuf.DeftypeNode";
  }
  protected:
  explicit DeftypeNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldsFieldNumber = 2,
    kInterfacesFieldNumber = 3,
    kMethodsFieldNumber = 4,
    kClassNameFieldNumber = 1,
    kNameFieldNumber = 5,
  };
  // repeated .clojureRT.protobuf.Node fields = 2;
  int fields_size() const;
  private:
  int _internal_fields_size() const;
  public:
  void clear_fields();
  ::clojureRT::protobuf::Node* mutable_fields(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >*
      mutable_fields();
  private:
  const ::clojureRT::protobuf::Node& _internal_fields(int index) const;
  ::clojureRT::protobuf::Node* _internal_add_fields();
  public:
  const ::clojureRT::protobuf::Node& fields(int index) const;
  ::clojureRT::protobuf::Node* add_fields();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >&
      fields() const;

  // repeated string interfaces = 3;
  int interfaces_size() const;
  private:
  int _internal_interfaces_size() const;
  public:
  void clear_interfaces();
  const std::string& interfaces(int index) const;
  std::string* mutable_interfaces(int index);
  void set_interfaces(int index, const std::string& value);
  void set_interfaces(int index, std::string&& value);
  void set_interfaces(int index, const char* value);
  void set_interfaces(int index, const char* value, size_t size);
  std::string* add_interfaces();
  void add_interfaces(const std::string& value);
  void add_interfaces(std::string&& value);
  void add_interfaces(const char* value);
  void add_interfaces(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& interfaces() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_interfaces();
  private:
  const std::string& _internal_interfaces(int index) const;
  std::string* _internal_add_interfaces();
  public:

  // repeated .clojureRT.protobuf.Node methods = 4;
  int methods_size() const;
  private:
  int _internal_methods_size() const;
  public:
  void clear_methods();
  ::clojureRT::protobuf::Node* mutable_methods(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >*
      mutable_methods();
  private:
  const ::clojureRT::protobuf::Node& _internal_methods(int index) const;
  ::clojureRT::protobuf::Node* _internal_add_methods();
  public:
  const ::clojureRT::protobuf::Node& methods(int index) const;
  ::clojureRT::protobuf::Node* add_methods();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >&
      methods() const;

  // string className = 1;
  void clear_classname();
  const std::string& classname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_classname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_classname();
  PROTOBUF_NODISCARD std::string* release_classname();
  void set_allocated_classname(std::string* classname);
  private:
  const std::string& _internal_classname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_classname(const std::string& value);
  std::string* _internal_mutable_classname();
  public:

  // string name = 5;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:clojureRT.protobuf.DeftypeNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node > fields_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> interfaces_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node > methods_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr classname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bytecode_2eproto;
};
// -------------------------------------------------------------------

class DoNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clojureRT.protobuf.DoNode) */ {
 public:
  inline DoNode() : DoNode(nullptr) {}
  ~DoNode() override;
  explicit PROTOBUF_CONSTEXPR DoNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DoNode(const DoNode& from);
  DoNode(DoNode&& from) noexcept
    : DoNode() {
    *this = ::std::move(from);
  }

  inline DoNode& operator=(const DoNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline DoNode& operator=(DoNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DoNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const DoNode* internal_default_instance() {
    return reinterpret_cast<const DoNode*>(
               &_DoNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(DoNode& a, DoNode& b) {
    a.Swap(&b);
  }
  inline void Swap(DoNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DoNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DoNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DoNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DoNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DoNode& from) {
    DoNode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DoNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clojureRT.protobuf.DoNode";
  }
  protected:
  explicit DoNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatementsFieldNumber = 3,
    kRetFieldNumber = 2,
    kIsBodyFieldNumber = 1,
  };
  // repeated .clojureRT.protobuf.Node statements = 3;
  int statements_size() const;
  private:
  int _internal_statements_size() const;
  public:
  void clear_statements();
  ::clojureRT::protobuf::Node* mutable_statements(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >*
      mutable_statements();
  private:
  const ::clojureRT::protobuf::Node& _internal_statements(int index) const;
  ::clojureRT::protobuf::Node* _internal_add_statements();
  public:
  const ::clojureRT::protobuf::Node& statements(int index) const;
  ::clojureRT::protobuf::Node* add_statements();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >&
      statements() const;

  // .clojureRT.protobuf.Node ret = 2;
  bool has_ret() const;
  private:
  bool _internal_has_ret() const;
  public:
  void clear_ret();
  const ::clojureRT::protobuf::Node& ret() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::Node* release_ret();
  ::clojureRT::protobuf::Node* mutable_ret();
  void set_allocated_ret(::clojureRT::protobuf::Node* ret);
  private:
  const ::clojureRT::protobuf::Node& _internal_ret() const;
  ::clojureRT::protobuf::Node* _internal_mutable_ret();
  public:
  void unsafe_arena_set_allocated_ret(
      ::clojureRT::protobuf::Node* ret);
  ::clojureRT::protobuf::Node* unsafe_arena_release_ret();

  // optional bool isBody = 1;
  bool has_isbody() const;
  private:
  bool _internal_has_isbody() const;
  public:
  void clear_isbody();
  bool isbody() const;
  void set_isbody(bool value);
  private:
  bool _internal_isbody() const;
  void _internal_set_isbody(bool value);
  public:

  // @@protoc_insertion_point(class_scope:clojureRT.protobuf.DoNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node > statements_;
    ::clojureRT::protobuf::Node* ret_;
    bool isbody_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bytecode_2eproto;
};
// -------------------------------------------------------------------

class FnNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clojureRT.protobuf.FnNode) */ {
 public:
  inline FnNode() : FnNode(nullptr) {}
  ~FnNode() override;
  explicit PROTOBUF_CONSTEXPR FnNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FnNode(const FnNode& from);
  FnNode(FnNode&& from) noexcept
    : FnNode() {
    *this = ::std::move(from);
  }

  inline FnNode& operator=(const FnNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline FnNode& operator=(FnNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FnNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const FnNode* internal_default_instance() {
    return reinterpret_cast<const FnNode*>(
               &_FnNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(FnNode& a, FnNode& b) {
    a.Swap(&b);
  }
  inline void Swap(FnNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FnNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FnNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FnNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FnNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FnNode& from) {
    FnNode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FnNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clojureRT.protobuf.FnNode";
  }
  protected:
  explicit FnNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMethodsFieldNumber = 3,
    kLocalFieldNumber = 1,
    kMaxFixedArityFieldNumber = 2,
    kOnceFieldNumber = 4,
    kIsVariadicFieldNumber = 5,
  };
  // repeated .clojureRT.protobuf.Node methods = 3;
  int methods_size() const;
  private:
  int _internal_methods_size() const;
  public:
  void clear_methods();
  ::clojureRT::protobuf::Node* mutable_methods(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >*
      mutable_methods();
  private:
  const ::clojureRT::protobuf::Node& _internal_methods(int index) const;
  ::clojureRT::protobuf::Node* _internal_add_methods();
  public:
  const ::clojureRT::protobuf::Node& methods(int index) const;
  ::clojureRT::protobuf::Node* add_methods();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >&
      methods() const;

  // optional .clojureRT.protobuf.Node local = 1;
  bool has_local() const;
  private:
  bool _internal_has_local() const;
  public:
  void clear_local();
  const ::clojureRT::protobuf::Node& local() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::Node* release_local();
  ::clojureRT::protobuf::Node* mutable_local();
  void set_allocated_local(::clojureRT::protobuf::Node* local);
  private:
  const ::clojureRT::protobuf::Node& _internal_local() const;
  ::clojureRT::protobuf::Node* _internal_mutable_local();
  public:
  void unsafe_arena_set_allocated_local(
      ::clojureRT::protobuf::Node* local);
  ::clojureRT::protobuf::Node* unsafe_arena_release_local();

  // uint32 maxFixedArity = 2;
  void clear_maxfixedarity();
  uint32_t maxfixedarity() const;
  void set_maxfixedarity(uint32_t value);
  private:
  uint32_t _internal_maxfixedarity() const;
  void _internal_set_maxfixedarity(uint32_t value);
  public:

  // bool once = 4;
  void clear_once();
  bool once() const;
  void set_once(bool value);
  private:
  bool _internal_once() const;
  void _internal_set_once(bool value);
  public:

  // bool isVariadic = 5;
  void clear_isvariadic();
  bool isvariadic() const;
  void set_isvariadic(bool value);
  private:
  bool _internal_isvariadic() const;
  void _internal_set_isvariadic(bool value);
  public:

  // @@protoc_insertion_point(class_scope:clojureRT.protobuf.FnNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node > methods_;
    ::clojureRT::protobuf::Node* local_;
    uint32_t maxfixedarity_;
    bool once_;
    bool isvariadic_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bytecode_2eproto;
};
// -------------------------------------------------------------------

class FnMethodNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clojureRT.protobuf.FnMethodNode) */ {
 public:
  inline FnMethodNode() : FnMethodNode(nullptr) {}
  ~FnMethodNode() override;
  explicit PROTOBUF_CONSTEXPR FnMethodNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FnMethodNode(const FnMethodNode& from);
  FnMethodNode(FnMethodNode&& from) noexcept
    : FnMethodNode() {
    *this = ::std::move(from);
  }

  inline FnMethodNode& operator=(const FnMethodNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline FnMethodNode& operator=(FnMethodNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FnMethodNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const FnMethodNode* internal_default_instance() {
    return reinterpret_cast<const FnMethodNode*>(
               &_FnMethodNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(FnMethodNode& a, FnMethodNode& b) {
    a.Swap(&b);
  }
  inline void Swap(FnMethodNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FnMethodNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FnMethodNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FnMethodNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FnMethodNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FnMethodNode& from) {
    FnMethodNode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FnMethodNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clojureRT.protobuf.FnMethodNode";
  }
  protected:
  explicit FnMethodNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParamsFieldNumber = 4,
    kLoopIdFieldNumber = 3,
    kBodyFieldNumber = 1,
    kFixedArityFieldNumber = 2,
    kIsVariadicFieldNumber = 5,
  };
  // repeated .clojureRT.protobuf.Node params = 4;
  int params_size() const;
  private:
  int _internal_params_size() const;
  public:
  void clear_params();
  ::clojureRT::protobuf::Node* mutable_params(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >*
      mutable_params();
  private:
  const ::clojureRT::protobuf::Node& _internal_params(int index) const;
  ::clojureRT::protobuf::Node* _internal_add_params();
  public:
  const ::clojureRT::protobuf::Node& params(int index) const;
  ::clojureRT::protobuf::Node* add_params();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >&
      params() const;

  // string loopId = 3;
  void clear_loopid();
  const std::string& loopid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_loopid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_loopid();
  PROTOBUF_NODISCARD std::string* release_loopid();
  void set_allocated_loopid(std::string* loopid);
  private:
  const std::string& _internal_loopid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_loopid(const std::string& value);
  std::string* _internal_mutable_loopid();
  public:

  // .clojureRT.protobuf.Node body = 1;
  bool has_body() const;
  private:
  bool _internal_has_body() const;
  public:
  void clear_body();
  const ::clojureRT::protobuf::Node& body() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::Node* release_body();
  ::clojureRT::protobuf::Node* mutable_body();
  void set_allocated_body(::clojureRT::protobuf::Node* body);
  private:
  const ::clojureRT::protobuf::Node& _internal_body() const;
  ::clojureRT::protobuf::Node* _internal_mutable_body();
  public:
  void unsafe_arena_set_allocated_body(
      ::clojureRT::protobuf::Node* body);
  ::clojureRT::protobuf::Node* unsafe_arena_release_body();

  // uint32 fixedArity = 2;
  void clear_fixedarity();
  uint32_t fixedarity() const;
  void set_fixedarity(uint32_t value);
  private:
  uint32_t _internal_fixedarity() const;
  void _internal_set_fixedarity(uint32_t value);
  public:

  // bool isVariadic = 5;
  void clear_isvariadic();
  bool isvariadic() const;
  void set_isvariadic(bool value);
  private:
  bool _internal_isvariadic() const;
  void _internal_set_isvariadic(bool value);
  public:

  // @@protoc_insertion_point(class_scope:clojureRT.protobuf.FnMethodNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node > params_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr loopid_;
    ::clojureRT::protobuf::Node* body_;
    uint32_t fixedarity_;
    bool isvariadic_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bytecode_2eproto;
};
// -------------------------------------------------------------------

class HostInteropNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clojureRT.protobuf.HostInteropNode) */ {
 public:
  inline HostInteropNode() : HostInteropNode(nullptr) {}
  ~HostInteropNode() override;
  explicit PROTOBUF_CONSTEXPR HostInteropNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HostInteropNode(const HostInteropNode& from);
  HostInteropNode(HostInteropNode&& from) noexcept
    : HostInteropNode() {
    *this = ::std::move(from);
  }

  inline HostInteropNode& operator=(const HostInteropNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline HostInteropNode& operator=(HostInteropNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HostInteropNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const HostInteropNode* internal_default_instance() {
    return reinterpret_cast<const HostInteropNode*>(
               &_HostInteropNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(HostInteropNode& a, HostInteropNode& b) {
    a.Swap(&b);
  }
  inline void Swap(HostInteropNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HostInteropNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HostInteropNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HostInteropNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HostInteropNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HostInteropNode& from) {
    HostInteropNode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HostInteropNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clojureRT.protobuf.HostInteropNode";
  }
  protected:
  explicit HostInteropNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMOrFFieldNumber = 2,
    kTargetFieldNumber = 3,
    kIsAssignableFieldNumber = 1,
  };
  // string mOrF = 2;
  void clear_morf();
  const std::string& morf() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_morf(ArgT0&& arg0, ArgT... args);
  std::string* mutable_morf();
  PROTOBUF_NODISCARD std::string* release_morf();
  void set_allocated_morf(std::string* morf);
  private:
  const std::string& _internal_morf() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_morf(const std::string& value);
  std::string* _internal_mutable_morf();
  public:

  // .clojureRT.protobuf.Node target = 3;
  bool has_target() const;
  private:
  bool _internal_has_target() const;
  public:
  void clear_target();
  const ::clojureRT::protobuf::Node& target() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::Node* release_target();
  ::clojureRT::protobuf::Node* mutable_target();
  void set_allocated_target(::clojureRT::protobuf::Node* target);
  private:
  const ::clojureRT::protobuf::Node& _internal_target() const;
  ::clojureRT::protobuf::Node* _internal_mutable_target();
  public:
  void unsafe_arena_set_allocated_target(
      ::clojureRT::protobuf::Node* target);
  ::clojureRT::protobuf::Node* unsafe_arena_release_target();

  // bool isAssignable = 1;
  void clear_isassignable();
  bool isassignable() const;
  void set_isassignable(bool value);
  private:
  bool _internal_isassignable() const;
  void _internal_set_isassignable(bool value);
  public:

  // @@protoc_insertion_point(class_scope:clojureRT.protobuf.HostInteropNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr morf_;
    ::clojureRT::protobuf::Node* target_;
    bool isassignable_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bytecode_2eproto;
};
// -------------------------------------------------------------------

class IfNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clojureRT.protobuf.IfNode) */ {
 public:
  inline IfNode() : IfNode(nullptr) {}
  ~IfNode() override;
  explicit PROTOBUF_CONSTEXPR IfNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IfNode(const IfNode& from);
  IfNode(IfNode&& from) noexcept
    : IfNode() {
    *this = ::std::move(from);
  }

  inline IfNode& operator=(const IfNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline IfNode& operator=(IfNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IfNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const IfNode* internal_default_instance() {
    return reinterpret_cast<const IfNode*>(
               &_IfNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(IfNode& a, IfNode& b) {
    a.Swap(&b);
  }
  inline void Swap(IfNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IfNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IfNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IfNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IfNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IfNode& from) {
    IfNode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IfNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clojureRT.protobuf.IfNode";
  }
  protected:
  explicit IfNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kElseFieldNumber = 1,
    kTestFieldNumber = 2,
    kThenFieldNumber = 3,
  };
  // .clojureRT.protobuf.Node else = 1;
  bool has_else_() const;
  private:
  bool _internal_has_else_() const;
  public:
  void clear_else_();
  const ::clojureRT::protobuf::Node& else_() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::Node* release_else_();
  ::clojureRT::protobuf::Node* mutable_else_();
  void set_allocated_else_(::clojureRT::protobuf::Node* else_);
  private:
  const ::clojureRT::protobuf::Node& _internal_else_() const;
  ::clojureRT::protobuf::Node* _internal_mutable_else_();
  public:
  void unsafe_arena_set_allocated_else_(
      ::clojureRT::protobuf::Node* else_);
  ::clojureRT::protobuf::Node* unsafe_arena_release_else_();

  // .clojureRT.protobuf.Node test = 2;
  bool has_test() const;
  private:
  bool _internal_has_test() const;
  public:
  void clear_test();
  const ::clojureRT::protobuf::Node& test() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::Node* release_test();
  ::clojureRT::protobuf::Node* mutable_test();
  void set_allocated_test(::clojureRT::protobuf::Node* test);
  private:
  const ::clojureRT::protobuf::Node& _internal_test() const;
  ::clojureRT::protobuf::Node* _internal_mutable_test();
  public:
  void unsafe_arena_set_allocated_test(
      ::clojureRT::protobuf::Node* test);
  ::clojureRT::protobuf::Node* unsafe_arena_release_test();

  // .clojureRT.protobuf.Node then = 3;
  bool has_then() const;
  private:
  bool _internal_has_then() const;
  public:
  void clear_then();
  const ::clojureRT::protobuf::Node& then() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::Node* release_then();
  ::clojureRT::protobuf::Node* mutable_then();
  void set_allocated_then(::clojureRT::protobuf::Node* then);
  private:
  const ::clojureRT::protobuf::Node& _internal_then() const;
  ::clojureRT::protobuf::Node* _internal_mutable_then();
  public:
  void unsafe_arena_set_allocated_then(
      ::clojureRT::protobuf::Node* then);
  ::clojureRT::protobuf::Node* unsafe_arena_release_then();

  // @@protoc_insertion_point(class_scope:clojureRT.protobuf.IfNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::clojureRT::protobuf::Node* else__;
    ::clojureRT::protobuf::Node* test_;
    ::clojureRT::protobuf::Node* then_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bytecode_2eproto;
};
// -------------------------------------------------------------------

class ImportNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clojureRT.protobuf.ImportNode) */ {
 public:
  inline ImportNode() : ImportNode(nullptr) {}
  ~ImportNode() override;
  explicit PROTOBUF_CONSTEXPR ImportNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ImportNode(const ImportNode& from);
  ImportNode(ImportNode&& from) noexcept
    : ImportNode() {
    *this = ::std::move(from);
  }

  inline ImportNode& operator=(const ImportNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImportNode& operator=(ImportNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImportNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImportNode* internal_default_instance() {
    return reinterpret_cast<const ImportNode*>(
               &_ImportNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ImportNode& a, ImportNode& b) {
    a.Swap(&b);
  }
  inline void Swap(ImportNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImportNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ImportNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ImportNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ImportNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ImportNode& from) {
    ImportNode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImportNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clojureRT.protobuf.ImportNode";
  }
  protected:
  explicit ImportNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClassFieldNumber = 1,
  };
  // string class = 1;
  void clear_class_();
  const std::string& class_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_class_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_class_();
  PROTOBUF_NODISCARD std::string* release_class_();
  void set_allocated_class_(std::string* class_);
  private:
  const std::string& _internal_class_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_class_(const std::string& value);
  std::string* _internal_mutable_class_();
  public:

  // @@protoc_insertion_point(class_scope:clojureRT.protobuf.ImportNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr class__;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bytecode_2eproto;
};
// -------------------------------------------------------------------

class InstanceCallNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clojureRT.protobuf.InstanceCallNode) */ {
 public:
  inline InstanceCallNode() : InstanceCallNode(nullptr) {}
  ~InstanceCallNode() override;
  explicit PROTOBUF_CONSTEXPR InstanceCallNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InstanceCallNode(const InstanceCallNode& from);
  InstanceCallNode(InstanceCallNode&& from) noexcept
    : InstanceCallNode() {
    *this = ::std::move(from);
  }

  inline InstanceCallNode& operator=(const InstanceCallNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstanceCallNode& operator=(InstanceCallNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InstanceCallNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const InstanceCallNode* internal_default_instance() {
    return reinterpret_cast<const InstanceCallNode*>(
               &_InstanceCallNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(InstanceCallNode& a, InstanceCallNode& b) {
    a.Swap(&b);
  }
  inline void Swap(InstanceCallNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstanceCallNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InstanceCallNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InstanceCallNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InstanceCallNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InstanceCallNode& from) {
    InstanceCallNode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InstanceCallNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clojureRT.protobuf.InstanceCallNode";
  }
  protected:
  explicit InstanceCallNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArgsFieldNumber = 1,
    kClassFieldNumber = 2,
    kMethodFieldNumber = 4,
    kInstanceFieldNumber = 3,
    kIsValidatedFieldNumber = 5,
  };
  // repeated .clojureRT.protobuf.Node args = 1;
  int args_size() const;
  private:
  int _internal_args_size() const;
  public:
  void clear_args();
  ::clojureRT::protobuf::Node* mutable_args(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >*
      mutable_args();
  private:
  const ::clojureRT::protobuf::Node& _internal_args(int index) const;
  ::clojureRT::protobuf::Node* _internal_add_args();
  public:
  const ::clojureRT::protobuf::Node& args(int index) const;
  ::clojureRT::protobuf::Node* add_args();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >&
      args() const;

  // optional string class = 2;
  bool has_class_() const;
  private:
  bool _internal_has_class_() const;
  public:
  void clear_class_();
  const std::string& class_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_class_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_class_();
  PROTOBUF_NODISCARD std::string* release_class_();
  void set_allocated_class_(std::string* class_);
  private:
  const std::string& _internal_class_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_class_(const std::string& value);
  std::string* _internal_mutable_class_();
  public:

  // string method = 4;
  void clear_method();
  const std::string& method() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_method(ArgT0&& arg0, ArgT... args);
  std::string* mutable_method();
  PROTOBUF_NODISCARD std::string* release_method();
  void set_allocated_method(std::string* method);
  private:
  const std::string& _internal_method() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_method(const std::string& value);
  std::string* _internal_mutable_method();
  public:

  // .clojureRT.protobuf.Node instance = 3;
  bool has_instance() const;
  private:
  bool _internal_has_instance() const;
  public:
  void clear_instance();
  const ::clojureRT::protobuf::Node& instance() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::Node* release_instance();
  ::clojureRT::protobuf::Node* mutable_instance();
  void set_allocated_instance(::clojureRT::protobuf::Node* instance);
  private:
  const ::clojureRT::protobuf::Node& _internal_instance() const;
  ::clojureRT::protobuf::Node* _internal_mutable_instance();
  public:
  void unsafe_arena_set_allocated_instance(
      ::clojureRT::protobuf::Node* instance);
  ::clojureRT::protobuf::Node* unsafe_arena_release_instance();

  // optional bool isValidated = 5;
  bool has_isvalidated() const;
  private:
  bool _internal_has_isvalidated() const;
  public:
  void clear_isvalidated();
  bool isvalidated() const;
  void set_isvalidated(bool value);
  private:
  bool _internal_isvalidated() const;
  void _internal_set_isvalidated(bool value);
  public:

  // @@protoc_insertion_point(class_scope:clojureRT.protobuf.InstanceCallNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node > args_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr class__;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr method_;
    ::clojureRT::protobuf::Node* instance_;
    bool isvalidated_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bytecode_2eproto;
};
// -------------------------------------------------------------------

class InstanceFieldNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clojureRT.protobuf.InstanceFieldNode) */ {
 public:
  inline InstanceFieldNode() : InstanceFieldNode(nullptr) {}
  ~InstanceFieldNode() override;
  explicit PROTOBUF_CONSTEXPR InstanceFieldNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InstanceFieldNode(const InstanceFieldNode& from);
  InstanceFieldNode(InstanceFieldNode&& from) noexcept
    : InstanceFieldNode() {
    *this = ::std::move(from);
  }

  inline InstanceFieldNode& operator=(const InstanceFieldNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstanceFieldNode& operator=(InstanceFieldNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InstanceFieldNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const InstanceFieldNode* internal_default_instance() {
    return reinterpret_cast<const InstanceFieldNode*>(
               &_InstanceFieldNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(InstanceFieldNode& a, InstanceFieldNode& b) {
    a.Swap(&b);
  }
  inline void Swap(InstanceFieldNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstanceFieldNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InstanceFieldNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InstanceFieldNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InstanceFieldNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InstanceFieldNode& from) {
    InstanceFieldNode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InstanceFieldNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clojureRT.protobuf.InstanceFieldNode";
  }
  protected:
  explicit InstanceFieldNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClassFieldNumber = 2,
    kFieldFieldNumber = 3,
    kInstanceFieldNumber = 4,
    kIsAssignableFieldNumber = 1,
  };
  // string class = 2;
  void clear_class_();
  const std::string& class_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_class_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_class_();
  PROTOBUF_NODISCARD std::string* release_class_();
  void set_allocated_class_(std::string* class_);
  private:
  const std::string& _internal_class_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_class_(const std::string& value);
  std::string* _internal_mutable_class_();
  public:

  // string field = 3;
  void clear_field();
  const std::string& field() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field();
  PROTOBUF_NODISCARD std::string* release_field();
  void set_allocated_field(std::string* field);
  private:
  const std::string& _internal_field() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field(const std::string& value);
  std::string* _internal_mutable_field();
  public:

  // .clojureRT.protobuf.Node instance = 4;
  bool has_instance() const;
  private:
  bool _internal_has_instance() const;
  public:
  void clear_instance();
  const ::clojureRT::protobuf::Node& instance() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::Node* release_instance();
  ::clojureRT::protobuf::Node* mutable_instance();
  void set_allocated_instance(::clojureRT::protobuf::Node* instance);
  private:
  const ::clojureRT::protobuf::Node& _internal_instance() const;
  ::clojureRT::protobuf::Node* _internal_mutable_instance();
  public:
  void unsafe_arena_set_allocated_instance(
      ::clojureRT::protobuf::Node* instance);
  ::clojureRT::protobuf::Node* unsafe_arena_release_instance();

  // bool isAssignable = 1;
  void clear_isassignable();
  bool isassignable() const;
  void set_isassignable(bool value);
  private:
  bool _internal_isassignable() const;
  void _internal_set_isassignable(bool value);
  public:

  // @@protoc_insertion_point(class_scope:clojureRT.protobuf.InstanceFieldNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr class__;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field_;
    ::clojureRT::protobuf::Node* instance_;
    bool isassignable_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bytecode_2eproto;
};
// -------------------------------------------------------------------

class IsInstanceNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clojureRT.protobuf.IsInstanceNode) */ {
 public:
  inline IsInstanceNode() : IsInstanceNode(nullptr) {}
  ~IsInstanceNode() override;
  explicit PROTOBUF_CONSTEXPR IsInstanceNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IsInstanceNode(const IsInstanceNode& from);
  IsInstanceNode(IsInstanceNode&& from) noexcept
    : IsInstanceNode() {
    *this = ::std::move(from);
  }

  inline IsInstanceNode& operator=(const IsInstanceNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline IsInstanceNode& operator=(IsInstanceNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IsInstanceNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const IsInstanceNode* internal_default_instance() {
    return reinterpret_cast<const IsInstanceNode*>(
               &_IsInstanceNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(IsInstanceNode& a, IsInstanceNode& b) {
    a.Swap(&b);
  }
  inline void Swap(IsInstanceNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IsInstanceNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IsInstanceNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IsInstanceNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IsInstanceNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IsInstanceNode& from) {
    IsInstanceNode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IsInstanceNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clojureRT.protobuf.IsInstanceNode";
  }
  protected:
  explicit IsInstanceNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClassFieldNumber = 1,
    kTargetFieldNumber = 2,
  };
  // string class = 1;
  void clear_class_();
  const std::string& class_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_class_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_class_();
  PROTOBUF_NODISCARD std::string* release_class_();
  void set_allocated_class_(std::string* class_);
  private:
  const std::string& _internal_class_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_class_(const std::string& value);
  std::string* _internal_mutable_class_();
  public:

  // .clojureRT.protobuf.Node target = 2;
  bool has_target() const;
  private:
  bool _internal_has_target() const;
  public:
  void clear_target();
  const ::clojureRT::protobuf::Node& target() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::Node* release_target();
  ::clojureRT::protobuf::Node* mutable_target();
  void set_allocated_target(::clojureRT::protobuf::Node* target);
  private:
  const ::clojureRT::protobuf::Node& _internal_target() const;
  ::clojureRT::protobuf::Node* _internal_mutable_target();
  public:
  void unsafe_arena_set_allocated_target(
      ::clojureRT::protobuf::Node* target);
  ::clojureRT::protobuf::Node* unsafe_arena_release_target();

  // @@protoc_insertion_point(class_scope:clojureRT.protobuf.IsInstanceNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr class__;
    ::clojureRT::protobuf::Node* target_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bytecode_2eproto;
};
// -------------------------------------------------------------------

class InvokeNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clojureRT.protobuf.InvokeNode) */ {
 public:
  inline InvokeNode() : InvokeNode(nullptr) {}
  ~InvokeNode() override;
  explicit PROTOBUF_CONSTEXPR InvokeNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InvokeNode(const InvokeNode& from);
  InvokeNode(InvokeNode&& from) noexcept
    : InvokeNode() {
    *this = ::std::move(from);
  }

  inline InvokeNode& operator=(const InvokeNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline InvokeNode& operator=(InvokeNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InvokeNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const InvokeNode* internal_default_instance() {
    return reinterpret_cast<const InvokeNode*>(
               &_InvokeNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(InvokeNode& a, InvokeNode& b) {
    a.Swap(&b);
  }
  inline void Swap(InvokeNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InvokeNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InvokeNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InvokeNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InvokeNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InvokeNode& from) {
    InvokeNode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InvokeNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clojureRT.protobuf.InvokeNode";
  }
  protected:
  explicit InvokeNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArgsFieldNumber = 1,
    kMetaFieldNumber = 3,
    kFnFieldNumber = 2,
  };
  // repeated .clojureRT.protobuf.Node args = 1;
  int args_size() const;
  private:
  int _internal_args_size() const;
  public:
  void clear_args();
  ::clojureRT::protobuf::Node* mutable_args(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >*
      mutable_args();
  private:
  const ::clojureRT::protobuf::Node& _internal_args(int index) const;
  ::clojureRT::protobuf::Node* _internal_add_args();
  public:
  const ::clojureRT::protobuf::Node& args(int index) const;
  ::clojureRT::protobuf::Node* add_args();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >&
      args() const;

  // optional string meta = 3;
  bool has_meta() const;
  private:
  bool _internal_has_meta() const;
  public:
  void clear_meta();
  const std::string& meta() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_meta(ArgT0&& arg0, ArgT... args);
  std::string* mutable_meta();
  PROTOBUF_NODISCARD std::string* release_meta();
  void set_allocated_meta(std::string* meta);
  private:
  const std::string& _internal_meta() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_meta(const std::string& value);
  std::string* _internal_mutable_meta();
  public:

  // .clojureRT.protobuf.Node fn = 2;
  bool has_fn() const;
  private:
  bool _internal_has_fn() const;
  public:
  void clear_fn();
  const ::clojureRT::protobuf::Node& fn() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::Node* release_fn();
  ::clojureRT::protobuf::Node* mutable_fn();
  void set_allocated_fn(::clojureRT::protobuf::Node* fn);
  private:
  const ::clojureRT::protobuf::Node& _internal_fn() const;
  ::clojureRT::protobuf::Node* _internal_mutable_fn();
  public:
  void unsafe_arena_set_allocated_fn(
      ::clojureRT::protobuf::Node* fn);
  ::clojureRT::protobuf::Node* unsafe_arena_release_fn();

  // @@protoc_insertion_point(class_scope:clojureRT.protobuf.InvokeNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node > args_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr meta_;
    ::clojureRT::protobuf::Node* fn_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bytecode_2eproto;
};
// -------------------------------------------------------------------

class KeywordInvokeNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clojureRT.protobuf.KeywordInvokeNode) */ {
 public:
  inline KeywordInvokeNode() : KeywordInvokeNode(nullptr) {}
  ~KeywordInvokeNode() override;
  explicit PROTOBUF_CONSTEXPR KeywordInvokeNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KeywordInvokeNode(const KeywordInvokeNode& from);
  KeywordInvokeNode(KeywordInvokeNode&& from) noexcept
    : KeywordInvokeNode() {
    *this = ::std::move(from);
  }

  inline KeywordInvokeNode& operator=(const KeywordInvokeNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeywordInvokeNode& operator=(KeywordInvokeNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeywordInvokeNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeywordInvokeNode* internal_default_instance() {
    return reinterpret_cast<const KeywordInvokeNode*>(
               &_KeywordInvokeNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(KeywordInvokeNode& a, KeywordInvokeNode& b) {
    a.Swap(&b);
  }
  inline void Swap(KeywordInvokeNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeywordInvokeNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeywordInvokeNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KeywordInvokeNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KeywordInvokeNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const KeywordInvokeNode& from) {
    KeywordInvokeNode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeywordInvokeNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clojureRT.protobuf.KeywordInvokeNode";
  }
  protected:
  explicit KeywordInvokeNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeywordFieldNumber = 1,
    kTargetFieldNumber = 2,
  };
  // .clojureRT.protobuf.Node keyword = 1;
  bool has_keyword() const;
  private:
  bool _internal_has_keyword() const;
  public:
  void clear_keyword();
  const ::clojureRT::protobuf::Node& keyword() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::Node* release_keyword();
  ::clojureRT::protobuf::Node* mutable_keyword();
  void set_allocated_keyword(::clojureRT::protobuf::Node* keyword);
  private:
  const ::clojureRT::protobuf::Node& _internal_keyword() const;
  ::clojureRT::protobuf::Node* _internal_mutable_keyword();
  public:
  void unsafe_arena_set_allocated_keyword(
      ::clojureRT::protobuf::Node* keyword);
  ::clojureRT::protobuf::Node* unsafe_arena_release_keyword();

  // .clojureRT.protobuf.Node target = 2;
  bool has_target() const;
  private:
  bool _internal_has_target() const;
  public:
  void clear_target();
  const ::clojureRT::protobuf::Node& target() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::Node* release_target();
  ::clojureRT::protobuf::Node* mutable_target();
  void set_allocated_target(::clojureRT::protobuf::Node* target);
  private:
  const ::clojureRT::protobuf::Node& _internal_target() const;
  ::clojureRT::protobuf::Node* _internal_mutable_target();
  public:
  void unsafe_arena_set_allocated_target(
      ::clojureRT::protobuf::Node* target);
  ::clojureRT::protobuf::Node* unsafe_arena_release_target();

  // @@protoc_insertion_point(class_scope:clojureRT.protobuf.KeywordInvokeNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::clojureRT::protobuf::Node* keyword_;
    ::clojureRT::protobuf::Node* target_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bytecode_2eproto;
};
// -------------------------------------------------------------------

class LetNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clojureRT.protobuf.LetNode) */ {
 public:
  inline LetNode() : LetNode(nullptr) {}
  ~LetNode() override;
  explicit PROTOBUF_CONSTEXPR LetNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LetNode(const LetNode& from);
  LetNode(LetNode&& from) noexcept
    : LetNode() {
    *this = ::std::move(from);
  }

  inline LetNode& operator=(const LetNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline LetNode& operator=(LetNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LetNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const LetNode* internal_default_instance() {
    return reinterpret_cast<const LetNode*>(
               &_LetNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(LetNode& a, LetNode& b) {
    a.Swap(&b);
  }
  inline void Swap(LetNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LetNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LetNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LetNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LetNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LetNode& from) {
    LetNode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LetNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clojureRT.protobuf.LetNode";
  }
  protected:
  explicit LetNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBindingsFieldNumber = 1,
    kBodyFieldNumber = 2,
  };
  // repeated .clojureRT.protobuf.Node bindings = 1;
  int bindings_size() const;
  private:
  int _internal_bindings_size() const;
  public:
  void clear_bindings();
  ::clojureRT::protobuf::Node* mutable_bindings(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >*
      mutable_bindings();
  private:
  const ::clojureRT::protobuf::Node& _internal_bindings(int index) const;
  ::clojureRT::protobuf::Node* _internal_add_bindings();
  public:
  const ::clojureRT::protobuf::Node& bindings(int index) const;
  ::clojureRT::protobuf::Node* add_bindings();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >&
      bindings() const;

  // .clojureRT.protobuf.Node body = 2;
  bool has_body() const;
  private:
  bool _internal_has_body() const;
  public:
  void clear_body();
  const ::clojureRT::protobuf::Node& body() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::Node* release_body();
  ::clojureRT::protobuf::Node* mutable_body();
  void set_allocated_body(::clojureRT::protobuf::Node* body);
  private:
  const ::clojureRT::protobuf::Node& _internal_body() const;
  ::clojureRT::protobuf::Node* _internal_mutable_body();
  public:
  void unsafe_arena_set_allocated_body(
      ::clojureRT::protobuf::Node* body);
  ::clojureRT::protobuf::Node* unsafe_arena_release_body();

  // @@protoc_insertion_point(class_scope:clojureRT.protobuf.LetNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node > bindings_;
    ::clojureRT::protobuf::Node* body_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bytecode_2eproto;
};
// -------------------------------------------------------------------

class LetfnNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clojureRT.protobuf.LetfnNode) */ {
 public:
  inline LetfnNode() : LetfnNode(nullptr) {}
  ~LetfnNode() override;
  explicit PROTOBUF_CONSTEXPR LetfnNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LetfnNode(const LetfnNode& from);
  LetfnNode(LetfnNode&& from) noexcept
    : LetfnNode() {
    *this = ::std::move(from);
  }

  inline LetfnNode& operator=(const LetfnNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline LetfnNode& operator=(LetfnNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LetfnNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const LetfnNode* internal_default_instance() {
    return reinterpret_cast<const LetfnNode*>(
               &_LetfnNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(LetfnNode& a, LetfnNode& b) {
    a.Swap(&b);
  }
  inline void Swap(LetfnNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LetfnNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LetfnNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LetfnNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LetfnNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LetfnNode& from) {
    LetfnNode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LetfnNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clojureRT.protobuf.LetfnNode";
  }
  protected:
  explicit LetfnNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBindingsFieldNumber = 1,
    kBodyFieldNumber = 2,
  };
  // repeated .clojureRT.protobuf.Node bindings = 1;
  int bindings_size() const;
  private:
  int _internal_bindings_size() const;
  public:
  void clear_bindings();
  ::clojureRT::protobuf::Node* mutable_bindings(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >*
      mutable_bindings();
  private:
  const ::clojureRT::protobuf::Node& _internal_bindings(int index) const;
  ::clojureRT::protobuf::Node* _internal_add_bindings();
  public:
  const ::clojureRT::protobuf::Node& bindings(int index) const;
  ::clojureRT::protobuf::Node* add_bindings();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >&
      bindings() const;

  // .clojureRT.protobuf.Node body = 2;
  bool has_body() const;
  private:
  bool _internal_has_body() const;
  public:
  void clear_body();
  const ::clojureRT::protobuf::Node& body() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::Node* release_body();
  ::clojureRT::protobuf::Node* mutable_body();
  void set_allocated_body(::clojureRT::protobuf::Node* body);
  private:
  const ::clojureRT::protobuf::Node& _internal_body() const;
  ::clojureRT::protobuf::Node* _internal_mutable_body();
  public:
  void unsafe_arena_set_allocated_body(
      ::clojureRT::protobuf::Node* body);
  ::clojureRT::protobuf::Node* unsafe_arena_release_body();

  // @@protoc_insertion_point(class_scope:clojureRT.protobuf.LetfnNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node > bindings_;
    ::clojureRT::protobuf::Node* body_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bytecode_2eproto;
};
// -------------------------------------------------------------------

class LocalNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clojureRT.protobuf.LocalNode) */ {
 public:
  inline LocalNode() : LocalNode(nullptr) {}
  ~LocalNode() override;
  explicit PROTOBUF_CONSTEXPR LocalNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LocalNode(const LocalNode& from);
  LocalNode(LocalNode&& from) noexcept
    : LocalNode() {
    *this = ::std::move(from);
  }

  inline LocalNode& operator=(const LocalNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocalNode& operator=(LocalNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LocalNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const LocalNode* internal_default_instance() {
    return reinterpret_cast<const LocalNode*>(
               &_LocalNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(LocalNode& a, LocalNode& b) {
    a.Swap(&b);
  }
  inline void Swap(LocalNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LocalNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LocalNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LocalNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LocalNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LocalNode& from) {
    LocalNode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocalNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clojureRT.protobuf.LocalNode";
  }
  protected:
  explicit LocalNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 4,
    kArgIdFieldNumber = 1,
    kLocalFieldNumber = 3,
    kIsAssignableFieldNumber = 2,
    kIsVariadicFieldNumber = 5,
  };
  // string name = 4;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional uint32 argId = 1;
  bool has_argid() const;
  private:
  bool _internal_has_argid() const;
  public:
  void clear_argid();
  uint32_t argid() const;
  void set_argid(uint32_t value);
  private:
  uint32_t _internal_argid() const;
  void _internal_set_argid(uint32_t value);
  public:

  // .clojureRT.protobuf.LocalType local = 3;
  void clear_local();
  ::clojureRT::protobuf::LocalType local() const;
  void set_local(::clojureRT::protobuf::LocalType value);
  private:
  ::clojureRT::protobuf::LocalType _internal_local() const;
  void _internal_set_local(::clojureRT::protobuf::LocalType value);
  public:

  // bool isAssignable = 2;
  void clear_isassignable();
  bool isassignable() const;
  void set_isassignable(bool value);
  private:
  bool _internal_isassignable() const;
  void _internal_set_isassignable(bool value);
  public:

  // optional bool isVariadic = 5;
  bool has_isvariadic() const;
  private:
  bool _internal_has_isvariadic() const;
  public:
  void clear_isvariadic();
  bool isvariadic() const;
  void set_isvariadic(bool value);
  private:
  bool _internal_isvariadic() const;
  void _internal_set_isvariadic(bool value);
  public:

  // @@protoc_insertion_point(class_scope:clojureRT.protobuf.LocalNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    uint32_t argid_;
    int local_;
    bool isassignable_;
    bool isvariadic_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bytecode_2eproto;
};
// -------------------------------------------------------------------

class LoopNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clojureRT.protobuf.LoopNode) */ {
 public:
  inline LoopNode() : LoopNode(nullptr) {}
  ~LoopNode() override;
  explicit PROTOBUF_CONSTEXPR LoopNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoopNode(const LoopNode& from);
  LoopNode(LoopNode&& from) noexcept
    : LoopNode() {
    *this = ::std::move(from);
  }

  inline LoopNode& operator=(const LoopNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoopNode& operator=(LoopNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoopNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoopNode* internal_default_instance() {
    return reinterpret_cast<const LoopNode*>(
               &_LoopNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(LoopNode& a, LoopNode& b) {
    a.Swap(&b);
  }
  inline void Swap(LoopNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoopNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoopNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoopNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoopNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoopNode& from) {
    LoopNode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoopNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clojureRT.protobuf.LoopNode";
  }
  protected:
  explicit LoopNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBindingsFieldNumber = 1,
    kLoopIdFieldNumber = 3,
    kBodyFieldNumber = 2,
  };
  // repeated .clojureRT.protobuf.Node bindings = 1;
  int bindings_size() const;
  private:
  int _internal_bindings_size() const;
  public:
  void clear_bindings();
  ::clojureRT::protobuf::Node* mutable_bindings(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >*
      mutable_bindings();
  private:
  const ::clojureRT::protobuf::Node& _internal_bindings(int index) const;
  ::clojureRT::protobuf::Node* _internal_add_bindings();
  public:
  const ::clojureRT::protobuf::Node& bindings(int index) const;
  ::clojureRT::protobuf::Node* add_bindings();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >&
      bindings() const;

  // string loopId = 3;
  void clear_loopid();
  const std::string& loopid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_loopid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_loopid();
  PROTOBUF_NODISCARD std::string* release_loopid();
  void set_allocated_loopid(std::string* loopid);
  private:
  const std::string& _internal_loopid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_loopid(const std::string& value);
  std::string* _internal_mutable_loopid();
  public:

  // .clojureRT.protobuf.Node body = 2;
  bool has_body() const;
  private:
  bool _internal_has_body() const;
  public:
  void clear_body();
  const ::clojureRT::protobuf::Node& body() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::Node* release_body();
  ::clojureRT::protobuf::Node* mutable_body();
  void set_allocated_body(::clojureRT::protobuf::Node* body);
  private:
  const ::clojureRT::protobuf::Node& _internal_body() const;
  ::clojureRT::protobuf::Node* _internal_mutable_body();
  public:
  void unsafe_arena_set_allocated_body(
      ::clojureRT::protobuf::Node* body);
  ::clojureRT::protobuf::Node* unsafe_arena_release_body();

  // @@protoc_insertion_point(class_scope:clojureRT.protobuf.LoopNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node > bindings_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr loopid_;
    ::clojureRT::protobuf::Node* body_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bytecode_2eproto;
};
// -------------------------------------------------------------------

class MapNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clojureRT.protobuf.MapNode) */ {
 public:
  inline MapNode() : MapNode(nullptr) {}
  ~MapNode() override;
  explicit PROTOBUF_CONSTEXPR MapNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MapNode(const MapNode& from);
  MapNode(MapNode&& from) noexcept
    : MapNode() {
    *this = ::std::move(from);
  }

  inline MapNode& operator=(const MapNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline MapNode& operator=(MapNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MapNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const MapNode* internal_default_instance() {
    return reinterpret_cast<const MapNode*>(
               &_MapNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(MapNode& a, MapNode& b) {
    a.Swap(&b);
  }
  inline void Swap(MapNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MapNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MapNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MapNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MapNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MapNode& from) {
    MapNode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MapNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clojureRT.protobuf.MapNode";
  }
  protected:
  explicit MapNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeysFieldNumber = 1,
    kValsFieldNumber = 2,
  };
  // repeated .clojureRT.protobuf.Node keys = 1;
  int keys_size() const;
  private:
  int _internal_keys_size() const;
  public:
  void clear_keys();
  ::clojureRT::protobuf::Node* mutable_keys(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >*
      mutable_keys();
  private:
  const ::clojureRT::protobuf::Node& _internal_keys(int index) const;
  ::clojureRT::protobuf::Node* _internal_add_keys();
  public:
  const ::clojureRT::protobuf::Node& keys(int index) const;
  ::clojureRT::protobuf::Node* add_keys();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >&
      keys() const;

  // repeated .clojureRT.protobuf.Node vals = 2;
  int vals_size() const;
  private:
  int _internal_vals_size() const;
  public:
  void clear_vals();
  ::clojureRT::protobuf::Node* mutable_vals(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >*
      mutable_vals();
  private:
  const ::clojureRT::protobuf::Node& _internal_vals(int index) const;
  ::clojureRT::protobuf::Node* _internal_add_vals();
  public:
  const ::clojureRT::protobuf::Node& vals(int index) const;
  ::clojureRT::protobuf::Node* add_vals();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >&
      vals() const;

  // @@protoc_insertion_point(class_scope:clojureRT.protobuf.MapNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node > keys_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node > vals_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bytecode_2eproto;
};
// -------------------------------------------------------------------

class MethodNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clojureRT.protobuf.MethodNode) */ {
 public:
  inline MethodNode() : MethodNode(nullptr) {}
  ~MethodNode() override;
  explicit PROTOBUF_CONSTEXPR MethodNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MethodNode(const MethodNode& from);
  MethodNode(MethodNode&& from) noexcept
    : MethodNode() {
    *this = ::std::move(from);
  }

  inline MethodNode& operator=(const MethodNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline MethodNode& operator=(MethodNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MethodNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const MethodNode* internal_default_instance() {
    return reinterpret_cast<const MethodNode*>(
               &_MethodNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(MethodNode& a, MethodNode& b) {
    a.Swap(&b);
  }
  inline void Swap(MethodNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MethodNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MethodNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MethodNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MethodNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MethodNode& from) {
    MethodNode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MethodNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clojureRT.protobuf.MethodNode";
  }
  protected:
  explicit MethodNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBridgesFieldNumber = 2,
    kParamsFieldNumber = 7,
    kInterfaceFieldNumber = 4,
    kLoopIdFieldNumber = 5,
    kNameFieldNumber = 6,
    kBodyFieldNumber = 1,
    kThisFieldNumber = 8,
    kFixedArityFieldNumber = 3,
  };
  // repeated string bridges = 2;
  int bridges_size() const;
  private:
  int _internal_bridges_size() const;
  public:
  void clear_bridges();
  const std::string& bridges(int index) const;
  std::string* mutable_bridges(int index);
  void set_bridges(int index, const std::string& value);
  void set_bridges(int index, std::string&& value);
  void set_bridges(int index, const char* value);
  void set_bridges(int index, const char* value, size_t size);
  std::string* add_bridges();
  void add_bridges(const std::string& value);
  void add_bridges(std::string&& value);
  void add_bridges(const char* value);
  void add_bridges(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& bridges() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_bridges();
  private:
  const std::string& _internal_bridges(int index) const;
  std::string* _internal_add_bridges();
  public:

  // repeated .clojureRT.protobuf.Node params = 7;
  int params_size() const;
  private:
  int _internal_params_size() const;
  public:
  void clear_params();
  ::clojureRT::protobuf::Node* mutable_params(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >*
      mutable_params();
  private:
  const ::clojureRT::protobuf::Node& _internal_params(int index) const;
  ::clojureRT::protobuf::Node* _internal_add_params();
  public:
  const ::clojureRT::protobuf::Node& params(int index) const;
  ::clojureRT::protobuf::Node* add_params();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >&
      params() const;

  // string interface = 4;
  void clear_interface();
  const std::string& interface() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_interface(ArgT0&& arg0, ArgT... args);
  std::string* mutable_interface();
  PROTOBUF_NODISCARD std::string* release_interface();
  void set_allocated_interface(std::string* interface);
  private:
  const std::string& _internal_interface() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_interface(const std::string& value);
  std::string* _internal_mutable_interface();
  public:

  // string loopId = 5;
  void clear_loopid();
  const std::string& loopid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_loopid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_loopid();
  PROTOBUF_NODISCARD std::string* release_loopid();
  void set_allocated_loopid(std::string* loopid);
  private:
  const std::string& _internal_loopid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_loopid(const std::string& value);
  std::string* _internal_mutable_loopid();
  public:

  // string name = 6;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .clojureRT.protobuf.Node body = 1;
  bool has_body() const;
  private:
  bool _internal_has_body() const;
  public:
  void clear_body();
  const ::clojureRT::protobuf::Node& body() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::Node* release_body();
  ::clojureRT::protobuf::Node* mutable_body();
  void set_allocated_body(::clojureRT::protobuf::Node* body);
  private:
  const ::clojureRT::protobuf::Node& _internal_body() const;
  ::clojureRT::protobuf::Node* _internal_mutable_body();
  public:
  void unsafe_arena_set_allocated_body(
      ::clojureRT::protobuf::Node* body);
  ::clojureRT::protobuf::Node* unsafe_arena_release_body();

  // .clojureRT.protobuf.Node this = 8;
  bool has_this_() const;
  private:
  bool _internal_has_this_() const;
  public:
  void clear_this_();
  const ::clojureRT::protobuf::Node& this_() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::Node* release_this_();
  ::clojureRT::protobuf::Node* mutable_this_();
  void set_allocated_this_(::clojureRT::protobuf::Node* this_);
  private:
  const ::clojureRT::protobuf::Node& _internal_this_() const;
  ::clojureRT::protobuf::Node* _internal_mutable_this_();
  public:
  void unsafe_arena_set_allocated_this_(
      ::clojureRT::protobuf::Node* this_);
  ::clojureRT::protobuf::Node* unsafe_arena_release_this_();

  // uint32 fixedArity = 3;
  void clear_fixedarity();
  uint32_t fixedarity() const;
  void set_fixedarity(uint32_t value);
  private:
  uint32_t _internal_fixedarity() const;
  void _internal_set_fixedarity(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:clojureRT.protobuf.MethodNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> bridges_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node > params_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr interface_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr loopid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::clojureRT::protobuf::Node* body_;
    ::clojureRT::protobuf::Node* this__;
    uint32_t fixedarity_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bytecode_2eproto;
};
// -------------------------------------------------------------------

class MonitorEnterNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clojureRT.protobuf.MonitorEnterNode) */ {
 public:
  inline MonitorEnterNode() : MonitorEnterNode(nullptr) {}
  ~MonitorEnterNode() override;
  explicit PROTOBUF_CONSTEXPR MonitorEnterNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MonitorEnterNode(const MonitorEnterNode& from);
  MonitorEnterNode(MonitorEnterNode&& from) noexcept
    : MonitorEnterNode() {
    *this = ::std::move(from);
  }

  inline MonitorEnterNode& operator=(const MonitorEnterNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline MonitorEnterNode& operator=(MonitorEnterNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MonitorEnterNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const MonitorEnterNode* internal_default_instance() {
    return reinterpret_cast<const MonitorEnterNode*>(
               &_MonitorEnterNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(MonitorEnterNode& a, MonitorEnterNode& b) {
    a.Swap(&b);
  }
  inline void Swap(MonitorEnterNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MonitorEnterNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MonitorEnterNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MonitorEnterNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MonitorEnterNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MonitorEnterNode& from) {
    MonitorEnterNode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MonitorEnterNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clojureRT.protobuf.MonitorEnterNode";
  }
  protected:
  explicit MonitorEnterNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetFieldNumber = 1,
  };
  // .clojureRT.protobuf.Node target = 1;
  bool has_target() const;
  private:
  bool _internal_has_target() const;
  public:
  void clear_target();
  const ::clojureRT::protobuf::Node& target() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::Node* release_target();
  ::clojureRT::protobuf::Node* mutable_target();
  void set_allocated_target(::clojureRT::protobuf::Node* target);
  private:
  const ::clojureRT::protobuf::Node& _internal_target() const;
  ::clojureRT::protobuf::Node* _internal_mutable_target();
  public:
  void unsafe_arena_set_allocated_target(
      ::clojureRT::protobuf::Node* target);
  ::clojureRT::protobuf::Node* unsafe_arena_release_target();

  // @@protoc_insertion_point(class_scope:clojureRT.protobuf.MonitorEnterNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::clojureRT::protobuf::Node* target_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bytecode_2eproto;
};
// -------------------------------------------------------------------

class MonitorExitNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clojureRT.protobuf.MonitorExitNode) */ {
 public:
  inline MonitorExitNode() : MonitorExitNode(nullptr) {}
  ~MonitorExitNode() override;
  explicit PROTOBUF_CONSTEXPR MonitorExitNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MonitorExitNode(const MonitorExitNode& from);
  MonitorExitNode(MonitorExitNode&& from) noexcept
    : MonitorExitNode() {
    *this = ::std::move(from);
  }

  inline MonitorExitNode& operator=(const MonitorExitNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline MonitorExitNode& operator=(MonitorExitNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MonitorExitNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const MonitorExitNode* internal_default_instance() {
    return reinterpret_cast<const MonitorExitNode*>(
               &_MonitorExitNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(MonitorExitNode& a, MonitorExitNode& b) {
    a.Swap(&b);
  }
  inline void Swap(MonitorExitNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MonitorExitNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MonitorExitNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MonitorExitNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MonitorExitNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MonitorExitNode& from) {
    MonitorExitNode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MonitorExitNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clojureRT.protobuf.MonitorExitNode";
  }
  protected:
  explicit MonitorExitNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetFieldNumber = 1,
  };
  // .clojureRT.protobuf.Node target = 1;
  bool has_target() const;
  private:
  bool _internal_has_target() const;
  public:
  void clear_target();
  const ::clojureRT::protobuf::Node& target() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::Node* release_target();
  ::clojureRT::protobuf::Node* mutable_target();
  void set_allocated_target(::clojureRT::protobuf::Node* target);
  private:
  const ::clojureRT::protobuf::Node& _internal_target() const;
  ::clojureRT::protobuf::Node* _internal_mutable_target();
  public:
  void unsafe_arena_set_allocated_target(
      ::clojureRT::protobuf::Node* target);
  ::clojureRT::protobuf::Node* unsafe_arena_release_target();

  // @@protoc_insertion_point(class_scope:clojureRT.protobuf.MonitorExitNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::clojureRT::protobuf::Node* target_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bytecode_2eproto;
};
// -------------------------------------------------------------------

class NewNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clojureRT.protobuf.NewNode) */ {
 public:
  inline NewNode() : NewNode(nullptr) {}
  ~NewNode() override;
  explicit PROTOBUF_CONSTEXPR NewNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NewNode(const NewNode& from);
  NewNode(NewNode&& from) noexcept
    : NewNode() {
    *this = ::std::move(from);
  }

  inline NewNode& operator=(const NewNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewNode& operator=(NewNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NewNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const NewNode* internal_default_instance() {
    return reinterpret_cast<const NewNode*>(
               &_NewNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(NewNode& a, NewNode& b) {
    a.Swap(&b);
  }
  inline void Swap(NewNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NewNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NewNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NewNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NewNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NewNode& from) {
    NewNode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clojureRT.protobuf.NewNode";
  }
  protected:
  explicit NewNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArgsFieldNumber = 1,
    kClassFieldNumber = 2,
    kIsValidatedFieldNumber = 3,
  };
  // repeated .clojureRT.protobuf.Node args = 1;
  int args_size() const;
  private:
  int _internal_args_size() const;
  public:
  void clear_args();
  ::clojureRT::protobuf::Node* mutable_args(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >*
      mutable_args();
  private:
  const ::clojureRT::protobuf::Node& _internal_args(int index) const;
  ::clojureRT::protobuf::Node* _internal_add_args();
  public:
  const ::clojureRT::protobuf::Node& args(int index) const;
  ::clojureRT::protobuf::Node* add_args();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >&
      args() const;

  // .clojureRT.protobuf.Node class = 2;
  bool has_class_() const;
  private:
  bool _internal_has_class_() const;
  public:
  void clear_class_();
  const ::clojureRT::protobuf::Node& class_() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::Node* release_class_();
  ::clojureRT::protobuf::Node* mutable_class_();
  void set_allocated_class_(::clojureRT::protobuf::Node* class_);
  private:
  const ::clojureRT::protobuf::Node& _internal_class_() const;
  ::clojureRT::protobuf::Node* _internal_mutable_class_();
  public:
  void unsafe_arena_set_allocated_class_(
      ::clojureRT::protobuf::Node* class_);
  ::clojureRT::protobuf::Node* unsafe_arena_release_class_();

  // optional bool isValidated = 3;
  bool has_isvalidated() const;
  private:
  bool _internal_has_isvalidated() const;
  public:
  void clear_isvalidated();
  bool isvalidated() const;
  void set_isvalidated(bool value);
  private:
  bool _internal_isvalidated() const;
  void _internal_set_isvalidated(bool value);
  public:

  // @@protoc_insertion_point(class_scope:clojureRT.protobuf.NewNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node > args_;
    ::clojureRT::protobuf::Node* class__;
    bool isvalidated_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bytecode_2eproto;
};
// -------------------------------------------------------------------

class PrimInvokeNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clojureRT.protobuf.PrimInvokeNode) */ {
 public:
  inline PrimInvokeNode() : PrimInvokeNode(nullptr) {}
  ~PrimInvokeNode() override;
  explicit PROTOBUF_CONSTEXPR PrimInvokeNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PrimInvokeNode(const PrimInvokeNode& from);
  PrimInvokeNode(PrimInvokeNode&& from) noexcept
    : PrimInvokeNode() {
    *this = ::std::move(from);
  }

  inline PrimInvokeNode& operator=(const PrimInvokeNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrimInvokeNode& operator=(PrimInvokeNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PrimInvokeNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const PrimInvokeNode* internal_default_instance() {
    return reinterpret_cast<const PrimInvokeNode*>(
               &_PrimInvokeNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(PrimInvokeNode& a, PrimInvokeNode& b) {
    a.Swap(&b);
  }
  inline void Swap(PrimInvokeNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrimInvokeNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PrimInvokeNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PrimInvokeNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PrimInvokeNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PrimInvokeNode& from) {
    PrimInvokeNode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PrimInvokeNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clojureRT.protobuf.PrimInvokeNode";
  }
  protected:
  explicit PrimInvokeNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArgsFieldNumber = 1,
    kMetaFieldNumber = 3,
    kPrimInterfaceFieldNumber = 4,
    kFnFieldNumber = 2,
  };
  // repeated .clojureRT.protobuf.Node args = 1;
  int args_size() const;
  private:
  int _internal_args_size() const;
  public:
  void clear_args();
  ::clojureRT::protobuf::Node* mutable_args(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >*
      mutable_args();
  private:
  const ::clojureRT::protobuf::Node& _internal_args(int index) const;
  ::clojureRT::protobuf::Node* _internal_add_args();
  public:
  const ::clojureRT::protobuf::Node& args(int index) const;
  ::clojureRT::protobuf::Node* add_args();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >&
      args() const;

  // optional string meta = 3;
  bool has_meta() const;
  private:
  bool _internal_has_meta() const;
  public:
  void clear_meta();
  const std::string& meta() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_meta(ArgT0&& arg0, ArgT... args);
  std::string* mutable_meta();
  PROTOBUF_NODISCARD std::string* release_meta();
  void set_allocated_meta(std::string* meta);
  private:
  const std::string& _internal_meta() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_meta(const std::string& value);
  std::string* _internal_mutable_meta();
  public:

  // string primInterface = 4;
  void clear_priminterface();
  const std::string& priminterface() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_priminterface(ArgT0&& arg0, ArgT... args);
  std::string* mutable_priminterface();
  PROTOBUF_NODISCARD std::string* release_priminterface();
  void set_allocated_priminterface(std::string* priminterface);
  private:
  const std::string& _internal_priminterface() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_priminterface(const std::string& value);
  std::string* _internal_mutable_priminterface();
  public:

  // .clojureRT.protobuf.Node fn = 2;
  bool has_fn() const;
  private:
  bool _internal_has_fn() const;
  public:
  void clear_fn();
  const ::clojureRT::protobuf::Node& fn() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::Node* release_fn();
  ::clojureRT::protobuf::Node* mutable_fn();
  void set_allocated_fn(::clojureRT::protobuf::Node* fn);
  private:
  const ::clojureRT::protobuf::Node& _internal_fn() const;
  ::clojureRT::protobuf::Node* _internal_mutable_fn();
  public:
  void unsafe_arena_set_allocated_fn(
      ::clojureRT::protobuf::Node* fn);
  ::clojureRT::protobuf::Node* unsafe_arena_release_fn();

  // @@protoc_insertion_point(class_scope:clojureRT.protobuf.PrimInvokeNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node > args_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr meta_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr priminterface_;
    ::clojureRT::protobuf::Node* fn_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bytecode_2eproto;
};
// -------------------------------------------------------------------

class ProtocolInvokeNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clojureRT.protobuf.ProtocolInvokeNode) */ {
 public:
  inline ProtocolInvokeNode() : ProtocolInvokeNode(nullptr) {}
  ~ProtocolInvokeNode() override;
  explicit PROTOBUF_CONSTEXPR ProtocolInvokeNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProtocolInvokeNode(const ProtocolInvokeNode& from);
  ProtocolInvokeNode(ProtocolInvokeNode&& from) noexcept
    : ProtocolInvokeNode() {
    *this = ::std::move(from);
  }

  inline ProtocolInvokeNode& operator=(const ProtocolInvokeNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProtocolInvokeNode& operator=(ProtocolInvokeNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProtocolInvokeNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProtocolInvokeNode* internal_default_instance() {
    return reinterpret_cast<const ProtocolInvokeNode*>(
               &_ProtocolInvokeNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(ProtocolInvokeNode& a, ProtocolInvokeNode& b) {
    a.Swap(&b);
  }
  inline void Swap(ProtocolInvokeNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProtocolInvokeNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProtocolInvokeNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProtocolInvokeNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProtocolInvokeNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProtocolInvokeNode& from) {
    ProtocolInvokeNode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtocolInvokeNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clojureRT.protobuf.ProtocolInvokeNode";
  }
  protected:
  explicit ProtocolInvokeNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArgsFieldNumber = 1,
    kProtocolFnFieldNumber = 2,
    kTargetFieldNumber = 3,
  };
  // repeated .clojureRT.protobuf.Node args = 1;
  int args_size() const;
  private:
  int _internal_args_size() const;
  public:
  void clear_args();
  ::clojureRT::protobuf::Node* mutable_args(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >*
      mutable_args();
  private:
  const ::clojureRT::protobuf::Node& _internal_args(int index) const;
  ::clojureRT::protobuf::Node* _internal_add_args();
  public:
  const ::clojureRT::protobuf::Node& args(int index) const;
  ::clojureRT::protobuf::Node* add_args();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >&
      args() const;

  // .clojureRT.protobuf.Node protocolFn = 2;
  bool has_protocolfn() const;
  private:
  bool _internal_has_protocolfn() const;
  public:
  void clear_protocolfn();
  const ::clojureRT::protobuf::Node& protocolfn() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::Node* release_protocolfn();
  ::clojureRT::protobuf::Node* mutable_protocolfn();
  void set_allocated_protocolfn(::clojureRT::protobuf::Node* protocolfn);
  private:
  const ::clojureRT::protobuf::Node& _internal_protocolfn() const;
  ::clojureRT::protobuf::Node* _internal_mutable_protocolfn();
  public:
  void unsafe_arena_set_allocated_protocolfn(
      ::clojureRT::protobuf::Node* protocolfn);
  ::clojureRT::protobuf::Node* unsafe_arena_release_protocolfn();

  // .clojureRT.protobuf.Node target = 3;
  bool has_target() const;
  private:
  bool _internal_has_target() const;
  public:
  void clear_target();
  const ::clojureRT::protobuf::Node& target() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::Node* release_target();
  ::clojureRT::protobuf::Node* mutable_target();
  void set_allocated_target(::clojureRT::protobuf::Node* target);
  private:
  const ::clojureRT::protobuf::Node& _internal_target() const;
  ::clojureRT::protobuf::Node* _internal_mutable_target();
  public:
  void unsafe_arena_set_allocated_target(
      ::clojureRT::protobuf::Node* target);
  ::clojureRT::protobuf::Node* unsafe_arena_release_target();

  // @@protoc_insertion_point(class_scope:clojureRT.protobuf.ProtocolInvokeNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node > args_;
    ::clojureRT::protobuf::Node* protocolfn_;
    ::clojureRT::protobuf::Node* target_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bytecode_2eproto;
};
// -------------------------------------------------------------------

class QuoteNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clojureRT.protobuf.QuoteNode) */ {
 public:
  inline QuoteNode() : QuoteNode(nullptr) {}
  ~QuoteNode() override;
  explicit PROTOBUF_CONSTEXPR QuoteNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QuoteNode(const QuoteNode& from);
  QuoteNode(QuoteNode&& from) noexcept
    : QuoteNode() {
    *this = ::std::move(from);
  }

  inline QuoteNode& operator=(const QuoteNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline QuoteNode& operator=(QuoteNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QuoteNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const QuoteNode* internal_default_instance() {
    return reinterpret_cast<const QuoteNode*>(
               &_QuoteNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(QuoteNode& a, QuoteNode& b) {
    a.Swap(&b);
  }
  inline void Swap(QuoteNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QuoteNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QuoteNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QuoteNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QuoteNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QuoteNode& from) {
    QuoteNode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QuoteNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clojureRT.protobuf.QuoteNode";
  }
  protected:
  explicit QuoteNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExprFieldNumber = 1,
    kIsLiteralFieldNumber = 2,
  };
  // .clojureRT.protobuf.Node expr = 1;
  bool has_expr() const;
  private:
  bool _internal_has_expr() const;
  public:
  void clear_expr();
  const ::clojureRT::protobuf::Node& expr() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::Node* release_expr();
  ::clojureRT::protobuf::Node* mutable_expr();
  void set_allocated_expr(::clojureRT::protobuf::Node* expr);
  private:
  const ::clojureRT::protobuf::Node& _internal_expr() const;
  ::clojureRT::protobuf::Node* _internal_mutable_expr();
  public:
  void unsafe_arena_set_allocated_expr(
      ::clojureRT::protobuf::Node* expr);
  ::clojureRT::protobuf::Node* unsafe_arena_release_expr();

  // bool isLiteral = 2;
  void clear_isliteral();
  bool isliteral() const;
  void set_isliteral(bool value);
  private:
  bool _internal_isliteral() const;
  void _internal_set_isliteral(bool value);
  public:

  // @@protoc_insertion_point(class_scope:clojureRT.protobuf.QuoteNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::clojureRT::protobuf::Node* expr_;
    bool isliteral_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bytecode_2eproto;
};
// -------------------------------------------------------------------

class RecurNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clojureRT.protobuf.RecurNode) */ {
 public:
  inline RecurNode() : RecurNode(nullptr) {}
  ~RecurNode() override;
  explicit PROTOBUF_CONSTEXPR RecurNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RecurNode(const RecurNode& from);
  RecurNode(RecurNode&& from) noexcept
    : RecurNode() {
    *this = ::std::move(from);
  }

  inline RecurNode& operator=(const RecurNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecurNode& operator=(RecurNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecurNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecurNode* internal_default_instance() {
    return reinterpret_cast<const RecurNode*>(
               &_RecurNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(RecurNode& a, RecurNode& b) {
    a.Swap(&b);
  }
  inline void Swap(RecurNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecurNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecurNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RecurNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RecurNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RecurNode& from) {
    RecurNode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecurNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clojureRT.protobuf.RecurNode";
  }
  protected:
  explicit RecurNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExprsFieldNumber = 1,
    kLoopIdFieldNumber = 2,
  };
  // repeated .clojureRT.protobuf.Node exprs = 1;
  int exprs_size() const;
  private:
  int _internal_exprs_size() const;
  public:
  void clear_exprs();
  ::clojureRT::protobuf::Node* mutable_exprs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >*
      mutable_exprs();
  private:
  const ::clojureRT::protobuf::Node& _internal_exprs(int index) const;
  ::clojureRT::protobuf::Node* _internal_add_exprs();
  public:
  const ::clojureRT::protobuf::Node& exprs(int index) const;
  ::clojureRT::protobuf::Node* add_exprs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >&
      exprs() const;

  // string loopId = 2;
  void clear_loopid();
  const std::string& loopid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_loopid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_loopid();
  PROTOBUF_NODISCARD std::string* release_loopid();
  void set_allocated_loopid(std::string* loopid);
  private:
  const std::string& _internal_loopid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_loopid(const std::string& value);
  std::string* _internal_mutable_loopid();
  public:

  // @@protoc_insertion_point(class_scope:clojureRT.protobuf.RecurNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node > exprs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr loopid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bytecode_2eproto;
};
// -------------------------------------------------------------------

class ReifyNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clojureRT.protobuf.ReifyNode) */ {
 public:
  inline ReifyNode() : ReifyNode(nullptr) {}
  ~ReifyNode() override;
  explicit PROTOBUF_CONSTEXPR ReifyNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReifyNode(const ReifyNode& from);
  ReifyNode(ReifyNode&& from) noexcept
    : ReifyNode() {
    *this = ::std::move(from);
  }

  inline ReifyNode& operator=(const ReifyNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReifyNode& operator=(ReifyNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReifyNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReifyNode* internal_default_instance() {
    return reinterpret_cast<const ReifyNode*>(
               &_ReifyNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(ReifyNode& a, ReifyNode& b) {
    a.Swap(&b);
  }
  inline void Swap(ReifyNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReifyNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReifyNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReifyNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReifyNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReifyNode& from) {
    ReifyNode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReifyNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clojureRT.protobuf.ReifyNode";
  }
  protected:
  explicit ReifyNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInterfacesFieldNumber = 2,
    kMethodsFieldNumber = 3,
    kClassNameFieldNumber = 1,
  };
  // repeated string interfaces = 2;
  int interfaces_size() const;
  private:
  int _internal_interfaces_size() const;
  public:
  void clear_interfaces();
  const std::string& interfaces(int index) const;
  std::string* mutable_interfaces(int index);
  void set_interfaces(int index, const std::string& value);
  void set_interfaces(int index, std::string&& value);
  void set_interfaces(int index, const char* value);
  void set_interfaces(int index, const char* value, size_t size);
  std::string* add_interfaces();
  void add_interfaces(const std::string& value);
  void add_interfaces(std::string&& value);
  void add_interfaces(const char* value);
  void add_interfaces(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& interfaces() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_interfaces();
  private:
  const std::string& _internal_interfaces(int index) const;
  std::string* _internal_add_interfaces();
  public:

  // repeated .clojureRT.protobuf.Node methods = 3;
  int methods_size() const;
  private:
  int _internal_methods_size() const;
  public:
  void clear_methods();
  ::clojureRT::protobuf::Node* mutable_methods(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >*
      mutable_methods();
  private:
  const ::clojureRT::protobuf::Node& _internal_methods(int index) const;
  ::clojureRT::protobuf::Node* _internal_add_methods();
  public:
  const ::clojureRT::protobuf::Node& methods(int index) const;
  ::clojureRT::protobuf::Node* add_methods();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >&
      methods() const;

  // string className = 1;
  void clear_classname();
  const std::string& classname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_classname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_classname();
  PROTOBUF_NODISCARD std::string* release_classname();
  void set_allocated_classname(std::string* classname);
  private:
  const std::string& _internal_classname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_classname(const std::string& value);
  std::string* _internal_mutable_classname();
  public:

  // @@protoc_insertion_point(class_scope:clojureRT.protobuf.ReifyNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> interfaces_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node > methods_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr classname_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bytecode_2eproto;
};
// -------------------------------------------------------------------

class SetNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clojureRT.protobuf.SetNode) */ {
 public:
  inline SetNode() : SetNode(nullptr) {}
  ~SetNode() override;
  explicit PROTOBUF_CONSTEXPR SetNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetNode(const SetNode& from);
  SetNode(SetNode&& from) noexcept
    : SetNode() {
    *this = ::std::move(from);
  }

  inline SetNode& operator=(const SetNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetNode& operator=(SetNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetNode* internal_default_instance() {
    return reinterpret_cast<const SetNode*>(
               &_SetNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(SetNode& a, SetNode& b) {
    a.Swap(&b);
  }
  inline void Swap(SetNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetNode& from) {
    SetNode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clojureRT.protobuf.SetNode";
  }
  protected:
  explicit SetNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .clojureRT.protobuf.Node items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::clojureRT::protobuf::Node* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >*
      mutable_items();
  private:
  const ::clojureRT::protobuf::Node& _internal_items(int index) const;
  ::clojureRT::protobuf::Node* _internal_add_items();
  public:
  const ::clojureRT::protobuf::Node& items(int index) const;
  ::clojureRT::protobuf::Node* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >&
      items() const;

  // @@protoc_insertion_point(class_scope:clojureRT.protobuf.SetNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node > items_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bytecode_2eproto;
};
// -------------------------------------------------------------------

class MutateSetNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clojureRT.protobuf.MutateSetNode) */ {
 public:
  inline MutateSetNode() : MutateSetNode(nullptr) {}
  ~MutateSetNode() override;
  explicit PROTOBUF_CONSTEXPR MutateSetNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MutateSetNode(const MutateSetNode& from);
  MutateSetNode(MutateSetNode&& from) noexcept
    : MutateSetNode() {
    *this = ::std::move(from);
  }

  inline MutateSetNode& operator=(const MutateSetNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline MutateSetNode& operator=(MutateSetNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MutateSetNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const MutateSetNode* internal_default_instance() {
    return reinterpret_cast<const MutateSetNode*>(
               &_MutateSetNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(MutateSetNode& a, MutateSetNode& b) {
    a.Swap(&b);
  }
  inline void Swap(MutateSetNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MutateSetNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MutateSetNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MutateSetNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MutateSetNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MutateSetNode& from) {
    MutateSetNode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MutateSetNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clojureRT.protobuf.MutateSetNode";
  }
  protected:
  explicit MutateSetNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetFieldNumber = 1,
    kValFieldNumber = 2,
  };
  // .clojureRT.protobuf.Node target = 1;
  bool has_target() const;
  private:
  bool _internal_has_target() const;
  public:
  void clear_target();
  const ::clojureRT::protobuf::Node& target() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::Node* release_target();
  ::clojureRT::protobuf::Node* mutable_target();
  void set_allocated_target(::clojureRT::protobuf::Node* target);
  private:
  const ::clojureRT::protobuf::Node& _internal_target() const;
  ::clojureRT::protobuf::Node* _internal_mutable_target();
  public:
  void unsafe_arena_set_allocated_target(
      ::clojureRT::protobuf::Node* target);
  ::clojureRT::protobuf::Node* unsafe_arena_release_target();

  // .clojureRT.protobuf.Node val = 2;
  bool has_val() const;
  private:
  bool _internal_has_val() const;
  public:
  void clear_val();
  const ::clojureRT::protobuf::Node& val() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::Node* release_val();
  ::clojureRT::protobuf::Node* mutable_val();
  void set_allocated_val(::clojureRT::protobuf::Node* val);
  private:
  const ::clojureRT::protobuf::Node& _internal_val() const;
  ::clojureRT::protobuf::Node* _internal_mutable_val();
  public:
  void unsafe_arena_set_allocated_val(
      ::clojureRT::protobuf::Node* val);
  ::clojureRT::protobuf::Node* unsafe_arena_release_val();

  // @@protoc_insertion_point(class_scope:clojureRT.protobuf.MutateSetNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::clojureRT::protobuf::Node* target_;
    ::clojureRT::protobuf::Node* val_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bytecode_2eproto;
};
// -------------------------------------------------------------------

class StaticCallNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clojureRT.protobuf.StaticCallNode) */ {
 public:
  inline StaticCallNode() : StaticCallNode(nullptr) {}
  ~StaticCallNode() override;
  explicit PROTOBUF_CONSTEXPR StaticCallNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StaticCallNode(const StaticCallNode& from);
  StaticCallNode(StaticCallNode&& from) noexcept
    : StaticCallNode() {
    *this = ::std::move(from);
  }

  inline StaticCallNode& operator=(const StaticCallNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline StaticCallNode& operator=(StaticCallNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StaticCallNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const StaticCallNode* internal_default_instance() {
    return reinterpret_cast<const StaticCallNode*>(
               &_StaticCallNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(StaticCallNode& a, StaticCallNode& b) {
    a.Swap(&b);
  }
  inline void Swap(StaticCallNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StaticCallNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StaticCallNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StaticCallNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StaticCallNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StaticCallNode& from) {
    StaticCallNode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StaticCallNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clojureRT.protobuf.StaticCallNode";
  }
  protected:
  explicit StaticCallNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArgsFieldNumber = 1,
    kClassFieldNumber = 2,
    kMethodFieldNumber = 3,
    kIsValidatedFieldNumber = 4,
  };
  // repeated .clojureRT.protobuf.Node args = 1;
  int args_size() const;
  private:
  int _internal_args_size() const;
  public:
  void clear_args();
  ::clojureRT::protobuf::Node* mutable_args(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >*
      mutable_args();
  private:
  const ::clojureRT::protobuf::Node& _internal_args(int index) const;
  ::clojureRT::protobuf::Node* _internal_add_args();
  public:
  const ::clojureRT::protobuf::Node& args(int index) const;
  ::clojureRT::protobuf::Node* add_args();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >&
      args() const;

  // string class = 2;
  void clear_class_();
  const std::string& class_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_class_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_class_();
  PROTOBUF_NODISCARD std::string* release_class_();
  void set_allocated_class_(std::string* class_);
  private:
  const std::string& _internal_class_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_class_(const std::string& value);
  std::string* _internal_mutable_class_();
  public:

  // string method = 3;
  void clear_method();
  const std::string& method() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_method(ArgT0&& arg0, ArgT... args);
  std::string* mutable_method();
  PROTOBUF_NODISCARD std::string* release_method();
  void set_allocated_method(std::string* method);
  private:
  const std::string& _internal_method() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_method(const std::string& value);
  std::string* _internal_mutable_method();
  public:

  // optional bool isValidated = 4;
  bool has_isvalidated() const;
  private:
  bool _internal_has_isvalidated() const;
  public:
  void clear_isvalidated();
  bool isvalidated() const;
  void set_isvalidated(bool value);
  private:
  bool _internal_isvalidated() const;
  void _internal_set_isvalidated(bool value);
  public:

  // @@protoc_insertion_point(class_scope:clojureRT.protobuf.StaticCallNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node > args_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr class__;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr method_;
    bool isvalidated_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bytecode_2eproto;
};
// -------------------------------------------------------------------

class StaticFieldNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clojureRT.protobuf.StaticFieldNode) */ {
 public:
  inline StaticFieldNode() : StaticFieldNode(nullptr) {}
  ~StaticFieldNode() override;
  explicit PROTOBUF_CONSTEXPR StaticFieldNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StaticFieldNode(const StaticFieldNode& from);
  StaticFieldNode(StaticFieldNode&& from) noexcept
    : StaticFieldNode() {
    *this = ::std::move(from);
  }

  inline StaticFieldNode& operator=(const StaticFieldNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline StaticFieldNode& operator=(StaticFieldNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StaticFieldNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const StaticFieldNode* internal_default_instance() {
    return reinterpret_cast<const StaticFieldNode*>(
               &_StaticFieldNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(StaticFieldNode& a, StaticFieldNode& b) {
    a.Swap(&b);
  }
  inline void Swap(StaticFieldNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StaticFieldNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StaticFieldNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StaticFieldNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StaticFieldNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StaticFieldNode& from) {
    StaticFieldNode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StaticFieldNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clojureRT.protobuf.StaticFieldNode";
  }
  protected:
  explicit StaticFieldNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClassFieldNumber = 2,
    kFieldFieldNumber = 3,
    kIsAssignableFieldNumber = 1,
  };
  // string class = 2;
  void clear_class_();
  const std::string& class_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_class_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_class_();
  PROTOBUF_NODISCARD std::string* release_class_();
  void set_allocated_class_(std::string* class_);
  private:
  const std::string& _internal_class_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_class_(const std::string& value);
  std::string* _internal_mutable_class_();
  public:

  // string field = 3;
  void clear_field();
  const std::string& field() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field();
  PROTOBUF_NODISCARD std::string* release_field();
  void set_allocated_field(std::string* field);
  private:
  const std::string& _internal_field() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field(const std::string& value);
  std::string* _internal_mutable_field();
  public:

  // optional bool isAssignable = 1;
  bool has_isassignable() const;
  private:
  bool _internal_has_isassignable() const;
  public:
  void clear_isassignable();
  bool isassignable() const;
  void set_isassignable(bool value);
  private:
  bool _internal_isassignable() const;
  void _internal_set_isassignable(bool value);
  public:

  // @@protoc_insertion_point(class_scope:clojureRT.protobuf.StaticFieldNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr class__;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field_;
    bool isassignable_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bytecode_2eproto;
};
// -------------------------------------------------------------------

class TheVarNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clojureRT.protobuf.TheVarNode) */ {
 public:
  inline TheVarNode() : TheVarNode(nullptr) {}
  ~TheVarNode() override;
  explicit PROTOBUF_CONSTEXPR TheVarNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TheVarNode(const TheVarNode& from);
  TheVarNode(TheVarNode&& from) noexcept
    : TheVarNode() {
    *this = ::std::move(from);
  }

  inline TheVarNode& operator=(const TheVarNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline TheVarNode& operator=(TheVarNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TheVarNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const TheVarNode* internal_default_instance() {
    return reinterpret_cast<const TheVarNode*>(
               &_TheVarNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(TheVarNode& a, TheVarNode& b) {
    a.Swap(&b);
  }
  inline void Swap(TheVarNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TheVarNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TheVarNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TheVarNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TheVarNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TheVarNode& from) {
    TheVarNode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TheVarNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clojureRT.protobuf.TheVarNode";
  }
  protected:
  explicit TheVarNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVarFieldNumber = 1,
  };
  // string var = 1;
  void clear_var();
  const std::string& var() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_var(ArgT0&& arg0, ArgT... args);
  std::string* mutable_var();
  PROTOBUF_NODISCARD std::string* release_var();
  void set_allocated_var(std::string* var);
  private:
  const std::string& _internal_var() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_var(const std::string& value);
  std::string* _internal_mutable_var();
  public:

  // @@protoc_insertion_point(class_scope:clojureRT.protobuf.TheVarNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr var_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bytecode_2eproto;
};
// -------------------------------------------------------------------

class ThrowNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clojureRT.protobuf.ThrowNode) */ {
 public:
  inline ThrowNode() : ThrowNode(nullptr) {}
  ~ThrowNode() override;
  explicit PROTOBUF_CONSTEXPR ThrowNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ThrowNode(const ThrowNode& from);
  ThrowNode(ThrowNode&& from) noexcept
    : ThrowNode() {
    *this = ::std::move(from);
  }

  inline ThrowNode& operator=(const ThrowNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline ThrowNode& operator=(ThrowNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ThrowNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const ThrowNode* internal_default_instance() {
    return reinterpret_cast<const ThrowNode*>(
               &_ThrowNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(ThrowNode& a, ThrowNode& b) {
    a.Swap(&b);
  }
  inline void Swap(ThrowNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ThrowNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ThrowNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ThrowNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ThrowNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ThrowNode& from) {
    ThrowNode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ThrowNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clojureRT.protobuf.ThrowNode";
  }
  protected:
  explicit ThrowNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExceptionFieldNumber = 1,
  };
  // .clojureRT.protobuf.Node exception = 1;
  bool has_exception() const;
  private:
  bool _internal_has_exception() const;
  public:
  void clear_exception();
  const ::clojureRT::protobuf::Node& exception() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::Node* release_exception();
  ::clojureRT::protobuf::Node* mutable_exception();
  void set_allocated_exception(::clojureRT::protobuf::Node* exception);
  private:
  const ::clojureRT::protobuf::Node& _internal_exception() const;
  ::clojureRT::protobuf::Node* _internal_mutable_exception();
  public:
  void unsafe_arena_set_allocated_exception(
      ::clojureRT::protobuf::Node* exception);
  ::clojureRT::protobuf::Node* unsafe_arena_release_exception();

  // @@protoc_insertion_point(class_scope:clojureRT.protobuf.ThrowNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::clojureRT::protobuf::Node* exception_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bytecode_2eproto;
};
// -------------------------------------------------------------------

class TryNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clojureRT.protobuf.TryNode) */ {
 public:
  inline TryNode() : TryNode(nullptr) {}
  ~TryNode() override;
  explicit PROTOBUF_CONSTEXPR TryNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TryNode(const TryNode& from);
  TryNode(TryNode&& from) noexcept
    : TryNode() {
    *this = ::std::move(from);
  }

  inline TryNode& operator=(const TryNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline TryNode& operator=(TryNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TryNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const TryNode* internal_default_instance() {
    return reinterpret_cast<const TryNode*>(
               &_TryNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(TryNode& a, TryNode& b) {
    a.Swap(&b);
  }
  inline void Swap(TryNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TryNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TryNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TryNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TryNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TryNode& from) {
    TryNode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TryNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clojureRT.protobuf.TryNode";
  }
  protected:
  explicit TryNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCatchesFieldNumber = 2,
    kBodyFieldNumber = 1,
    kFinallyFieldNumber = 3,
  };
  // repeated .clojureRT.protobuf.Node catches = 2;
  int catches_size() const;
  private:
  int _internal_catches_size() const;
  public:
  void clear_catches();
  ::clojureRT::protobuf::Node* mutable_catches(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >*
      mutable_catches();
  private:
  const ::clojureRT::protobuf::Node& _internal_catches(int index) const;
  ::clojureRT::protobuf::Node* _internal_add_catches();
  public:
  const ::clojureRT::protobuf::Node& catches(int index) const;
  ::clojureRT::protobuf::Node* add_catches();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >&
      catches() const;

  // .clojureRT.protobuf.Node body = 1;
  bool has_body() const;
  private:
  bool _internal_has_body() const;
  public:
  void clear_body();
  const ::clojureRT::protobuf::Node& body() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::Node* release_body();
  ::clojureRT::protobuf::Node* mutable_body();
  void set_allocated_body(::clojureRT::protobuf::Node* body);
  private:
  const ::clojureRT::protobuf::Node& _internal_body() const;
  ::clojureRT::protobuf::Node* _internal_mutable_body();
  public:
  void unsafe_arena_set_allocated_body(
      ::clojureRT::protobuf::Node* body);
  ::clojureRT::protobuf::Node* unsafe_arena_release_body();

  // optional .clojureRT.protobuf.Node finally = 3;
  bool has_finally() const;
  private:
  bool _internal_has_finally() const;
  public:
  void clear_finally();
  const ::clojureRT::protobuf::Node& finally() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::Node* release_finally();
  ::clojureRT::protobuf::Node* mutable_finally();
  void set_allocated_finally(::clojureRT::protobuf::Node* finally);
  private:
  const ::clojureRT::protobuf::Node& _internal_finally() const;
  ::clojureRT::protobuf::Node* _internal_mutable_finally();
  public:
  void unsafe_arena_set_allocated_finally(
      ::clojureRT::protobuf::Node* finally);
  ::clojureRT::protobuf::Node* unsafe_arena_release_finally();

  // @@protoc_insertion_point(class_scope:clojureRT.protobuf.TryNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node > catches_;
    ::clojureRT::protobuf::Node* body_;
    ::clojureRT::protobuf::Node* finally_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bytecode_2eproto;
};
// -------------------------------------------------------------------

class VarNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clojureRT.protobuf.VarNode) */ {
 public:
  inline VarNode() : VarNode(nullptr) {}
  ~VarNode() override;
  explicit PROTOBUF_CONSTEXPR VarNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VarNode(const VarNode& from);
  VarNode(VarNode&& from) noexcept
    : VarNode() {
    *this = ::std::move(from);
  }

  inline VarNode& operator=(const VarNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline VarNode& operator=(VarNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VarNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const VarNode* internal_default_instance() {
    return reinterpret_cast<const VarNode*>(
               &_VarNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(VarNode& a, VarNode& b) {
    a.Swap(&b);
  }
  inline void Swap(VarNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VarNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VarNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VarNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VarNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VarNode& from) {
    VarNode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VarNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clojureRT.protobuf.VarNode";
  }
  protected:
  explicit VarNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVarFieldNumber = 2,
    kIsAssignableFieldNumber = 1,
  };
  // string var = 2;
  void clear_var();
  const std::string& var() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_var(ArgT0&& arg0, ArgT... args);
  std::string* mutable_var();
  PROTOBUF_NODISCARD std::string* release_var();
  void set_allocated_var(std::string* var);
  private:
  const std::string& _internal_var() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_var(const std::string& value);
  std::string* _internal_mutable_var();
  public:

  // optional bool isAssignable = 1;
  bool has_isassignable() const;
  private:
  bool _internal_has_isassignable() const;
  public:
  void clear_isassignable();
  bool isassignable() const;
  void set_isassignable(bool value);
  private:
  bool _internal_isassignable() const;
  void _internal_set_isassignable(bool value);
  public:

  // @@protoc_insertion_point(class_scope:clojureRT.protobuf.VarNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr var_;
    bool isassignable_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bytecode_2eproto;
};
// -------------------------------------------------------------------

class VectorNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clojureRT.protobuf.VectorNode) */ {
 public:
  inline VectorNode() : VectorNode(nullptr) {}
  ~VectorNode() override;
  explicit PROTOBUF_CONSTEXPR VectorNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VectorNode(const VectorNode& from);
  VectorNode(VectorNode&& from) noexcept
    : VectorNode() {
    *this = ::std::move(from);
  }

  inline VectorNode& operator=(const VectorNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline VectorNode& operator=(VectorNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VectorNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const VectorNode* internal_default_instance() {
    return reinterpret_cast<const VectorNode*>(
               &_VectorNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(VectorNode& a, VectorNode& b) {
    a.Swap(&b);
  }
  inline void Swap(VectorNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VectorNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VectorNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VectorNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VectorNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VectorNode& from) {
    VectorNode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VectorNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clojureRT.protobuf.VectorNode";
  }
  protected:
  explicit VectorNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .clojureRT.protobuf.Node items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::clojureRT::protobuf::Node* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >*
      mutable_items();
  private:
  const ::clojureRT::protobuf::Node& _internal_items(int index) const;
  ::clojureRT::protobuf::Node* _internal_add_items();
  public:
  const ::clojureRT::protobuf::Node& items(int index) const;
  ::clojureRT::protobuf::Node* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >&
      items() const;

  // @@protoc_insertion_point(class_scope:clojureRT.protobuf.VectorNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node > items_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bytecode_2eproto;
};
// -------------------------------------------------------------------

class WithMetaNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clojureRT.protobuf.WithMetaNode) */ {
 public:
  inline WithMetaNode() : WithMetaNode(nullptr) {}
  ~WithMetaNode() override;
  explicit PROTOBUF_CONSTEXPR WithMetaNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WithMetaNode(const WithMetaNode& from);
  WithMetaNode(WithMetaNode&& from) noexcept
    : WithMetaNode() {
    *this = ::std::move(from);
  }

  inline WithMetaNode& operator=(const WithMetaNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline WithMetaNode& operator=(WithMetaNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WithMetaNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const WithMetaNode* internal_default_instance() {
    return reinterpret_cast<const WithMetaNode*>(
               &_WithMetaNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(WithMetaNode& a, WithMetaNode& b) {
    a.Swap(&b);
  }
  inline void Swap(WithMetaNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WithMetaNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WithMetaNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WithMetaNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WithMetaNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WithMetaNode& from) {
    WithMetaNode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WithMetaNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clojureRT.protobuf.WithMetaNode";
  }
  protected:
  explicit WithMetaNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExprFieldNumber = 1,
    kMetaFieldNumber = 2,
  };
  // .clojureRT.protobuf.Node expr = 1;
  bool has_expr() const;
  private:
  bool _internal_has_expr() const;
  public:
  void clear_expr();
  const ::clojureRT::protobuf::Node& expr() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::Node* release_expr();
  ::clojureRT::protobuf::Node* mutable_expr();
  void set_allocated_expr(::clojureRT::protobuf::Node* expr);
  private:
  const ::clojureRT::protobuf::Node& _internal_expr() const;
  ::clojureRT::protobuf::Node* _internal_mutable_expr();
  public:
  void unsafe_arena_set_allocated_expr(
      ::clojureRT::protobuf::Node* expr);
  ::clojureRT::protobuf::Node* unsafe_arena_release_expr();

  // .clojureRT.protobuf.Node meta = 2;
  bool has_meta() const;
  private:
  bool _internal_has_meta() const;
  public:
  void clear_meta();
  const ::clojureRT::protobuf::Node& meta() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::Node* release_meta();
  ::clojureRT::protobuf::Node* mutable_meta();
  void set_allocated_meta(::clojureRT::protobuf::Node* meta);
  private:
  const ::clojureRT::protobuf::Node& _internal_meta() const;
  ::clojureRT::protobuf::Node* _internal_mutable_meta();
  public:
  void unsafe_arena_set_allocated_meta(
      ::clojureRT::protobuf::Node* meta);
  ::clojureRT::protobuf::Node* unsafe_arena_release_meta();

  // @@protoc_insertion_point(class_scope:clojureRT.protobuf.WithMetaNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::clojureRT::protobuf::Node* expr_;
    ::clojureRT::protobuf::Node* meta_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bytecode_2eproto;
};
// -------------------------------------------------------------------

class Node final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clojureRT.protobuf.Node) */ {
 public:
  inline Node() : Node(nullptr) {}
  ~Node() override;
  explicit PROTOBUF_CONSTEXPR Node(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Node(const Node& from);
  Node(Node&& from) noexcept
    : Node() {
    *this = ::std::move(from);
  }

  inline Node& operator=(const Node& from) {
    CopyFrom(from);
    return *this;
  }
  inline Node& operator=(Node&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Node& default_instance() {
    return *internal_default_instance();
  }
  static inline const Node* internal_default_instance() {
    return reinterpret_cast<const Node*>(
               &_Node_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(Node& a, Node& b) {
    a.Swap(&b);
  }
  inline void Swap(Node* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Node* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Node* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Node>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Node& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Node& from) {
    Node::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Node* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clojureRT.protobuf.Node";
  }
  protected:
  explicit Node(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLoopsFieldNumber = 4,
    kRawFormsFieldNumber = 7,
    kEnvFieldNumber = 1,
    kFormFieldNumber = 2,
    kOTagFieldNumber = 5,
    kTagFieldNumber = 9,
    kSubnodeFieldNumber = 8,
    kOpFieldNumber = 6,
    kIgnoreTagFieldNumber = 3,
    kTopLevelFieldNumber = 10,
  };
  // repeated string loops = 4;
  int loops_size() const;
  private:
  int _internal_loops_size() const;
  public:
  void clear_loops();
  const std::string& loops(int index) const;
  std::string* mutable_loops(int index);
  void set_loops(int index, const std::string& value);
  void set_loops(int index, std::string&& value);
  void set_loops(int index, const char* value);
  void set_loops(int index, const char* value, size_t size);
  std::string* add_loops();
  void add_loops(const std::string& value);
  void add_loops(std::string&& value);
  void add_loops(const char* value);
  void add_loops(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& loops() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_loops();
  private:
  const std::string& _internal_loops(int index) const;
  std::string* _internal_add_loops();
  public:

  // repeated string rawForms = 7;
  int rawforms_size() const;
  private:
  int _internal_rawforms_size() const;
  public:
  void clear_rawforms();
  const std::string& rawforms(int index) const;
  std::string* mutable_rawforms(int index);
  void set_rawforms(int index, const std::string& value);
  void set_rawforms(int index, std::string&& value);
  void set_rawforms(int index, const char* value);
  void set_rawforms(int index, const char* value, size_t size);
  std::string* add_rawforms();
  void add_rawforms(const std::string& value);
  void add_rawforms(std::string&& value);
  void add_rawforms(const char* value);
  void add_rawforms(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& rawforms() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_rawforms();
  private:
  const std::string& _internal_rawforms(int index) const;
  std::string* _internal_add_rawforms();
  public:

  // string env = 1;
  void clear_env();
  const std::string& env() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_env(ArgT0&& arg0, ArgT... args);
  std::string* mutable_env();
  PROTOBUF_NODISCARD std::string* release_env();
  void set_allocated_env(std::string* env);
  private:
  const std::string& _internal_env() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_env(const std::string& value);
  std::string* _internal_mutable_env();
  public:

  // string form = 2;
  void clear_form();
  const std::string& form() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_form(ArgT0&& arg0, ArgT... args);
  std::string* mutable_form();
  PROTOBUF_NODISCARD std::string* release_form();
  void set_allocated_form(std::string* form);
  private:
  const std::string& _internal_form() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_form(const std::string& value);
  std::string* _internal_mutable_form();
  public:

  // string oTag = 5;
  void clear_otag();
  const std::string& otag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_otag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_otag();
  PROTOBUF_NODISCARD std::string* release_otag();
  void set_allocated_otag(std::string* otag);
  private:
  const std::string& _internal_otag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_otag(const std::string& value);
  std::string* _internal_mutable_otag();
  public:

  // string tag = 9;
  void clear_tag();
  const std::string& tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tag();
  PROTOBUF_NODISCARD std::string* release_tag();
  void set_allocated_tag(std::string* tag);
  private:
  const std::string& _internal_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tag(const std::string& value);
  std::string* _internal_mutable_tag();
  public:

  // .clojureRT.protobuf.Subnode subnode = 8;
  bool has_subnode() const;
  private:
  bool _internal_has_subnode() const;
  public:
  void clear_subnode();
  const ::clojureRT::protobuf::Subnode& subnode() const;
  PROTOBUF_NODISCARD ::clojureRT::protobuf::Subnode* release_subnode();
  ::clojureRT::protobuf::Subnode* mutable_subnode();
  void set_allocated_subnode(::clojureRT::protobuf::Subnode* subnode);
  private:
  const ::clojureRT::protobuf::Subnode& _internal_subnode() const;
  ::clojureRT::protobuf::Subnode* _internal_mutable_subnode();
  public:
  void unsafe_arena_set_allocated_subnode(
      ::clojureRT::protobuf::Subnode* subnode);
  ::clojureRT::protobuf::Subnode* unsafe_arena_release_subnode();

  // .clojureRT.protobuf.Op op = 6;
  void clear_op();
  ::clojureRT::protobuf::Op op() const;
  void set_op(::clojureRT::protobuf::Op value);
  private:
  ::clojureRT::protobuf::Op _internal_op() const;
  void _internal_set_op(::clojureRT::protobuf::Op value);
  public:

  // optional bool ignoreTag = 3;
  bool has_ignoretag() const;
  private:
  bool _internal_has_ignoretag() const;
  public:
  void clear_ignoretag();
  bool ignoretag() const;
  void set_ignoretag(bool value);
  private:
  bool _internal_ignoretag() const;
  void _internal_set_ignoretag(bool value);
  public:

  // optional bool topLevel = 10;
  bool has_toplevel() const;
  private:
  bool _internal_has_toplevel() const;
  public:
  void clear_toplevel();
  bool toplevel() const;
  void set_toplevel(bool value);
  private:
  bool _internal_toplevel() const;
  void _internal_set_toplevel(bool value);
  public:

  // @@protoc_insertion_point(class_scope:clojureRT.protobuf.Node)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> loops_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> rawforms_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr env_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr form_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr otag_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_;
    ::clojureRT::protobuf::Subnode* subnode_;
    int op_;
    bool ignoretag_;
    bool toplevel_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bytecode_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Subnode

// .clojureRT.protobuf.BindingNode binding = 1;
inline bool Subnode::_internal_has_binding() const {
  return types_case() == kBinding;
}
inline bool Subnode::has_binding() const {
  return _internal_has_binding();
}
inline void Subnode::set_has_binding() {
  _impl_._oneof_case_[0] = kBinding;
}
inline void Subnode::clear_binding() {
  if (_internal_has_binding()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.types_.binding_;
    }
    clear_has_types();
  }
}
inline ::clojureRT::protobuf::BindingNode* Subnode::release_binding() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.Subnode.binding)
  if (_internal_has_binding()) {
    clear_has_types();
    ::clojureRT::protobuf::BindingNode* temp = _impl_.types_.binding_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.types_.binding_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clojureRT::protobuf::BindingNode& Subnode::_internal_binding() const {
  return _internal_has_binding()
      ? *_impl_.types_.binding_
      : reinterpret_cast< ::clojureRT::protobuf::BindingNode&>(::clojureRT::protobuf::_BindingNode_default_instance_);
}
inline const ::clojureRT::protobuf::BindingNode& Subnode::binding() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.Subnode.binding)
  return _internal_binding();
}
inline ::clojureRT::protobuf::BindingNode* Subnode::unsafe_arena_release_binding() {
  // @@protoc_insertion_point(field_unsafe_arena_release:clojureRT.protobuf.Subnode.binding)
  if (_internal_has_binding()) {
    clear_has_types();
    ::clojureRT::protobuf::BindingNode* temp = _impl_.types_.binding_;
    _impl_.types_.binding_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Subnode::unsafe_arena_set_allocated_binding(::clojureRT::protobuf::BindingNode* binding) {
  clear_types();
  if (binding) {
    set_has_binding();
    _impl_.types_.binding_ = binding;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.Subnode.binding)
}
inline ::clojureRT::protobuf::BindingNode* Subnode::_internal_mutable_binding() {
  if (!_internal_has_binding()) {
    clear_types();
    set_has_binding();
    _impl_.types_.binding_ = CreateMaybeMessage< ::clojureRT::protobuf::BindingNode >(GetArenaForAllocation());
  }
  return _impl_.types_.binding_;
}
inline ::clojureRT::protobuf::BindingNode* Subnode::mutable_binding() {
  ::clojureRT::protobuf::BindingNode* _msg = _internal_mutable_binding();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.Subnode.binding)
  return _msg;
}

// .clojureRT.protobuf.CaseNode case = 2;
inline bool Subnode::_internal_has_case_() const {
  return types_case() == kCase;
}
inline bool Subnode::has_case_() const {
  return _internal_has_case_();
}
inline void Subnode::set_has_case_() {
  _impl_._oneof_case_[0] = kCase;
}
inline void Subnode::clear_case_() {
  if (_internal_has_case_()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.types_.case__;
    }
    clear_has_types();
  }
}
inline ::clojureRT::protobuf::CaseNode* Subnode::release_case_() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.Subnode.case)
  if (_internal_has_case_()) {
    clear_has_types();
    ::clojureRT::protobuf::CaseNode* temp = _impl_.types_.case__;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.types_.case__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clojureRT::protobuf::CaseNode& Subnode::_internal_case_() const {
  return _internal_has_case_()
      ? *_impl_.types_.case__
      : reinterpret_cast< ::clojureRT::protobuf::CaseNode&>(::clojureRT::protobuf::_CaseNode_default_instance_);
}
inline const ::clojureRT::protobuf::CaseNode& Subnode::case_() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.Subnode.case)
  return _internal_case_();
}
inline ::clojureRT::protobuf::CaseNode* Subnode::unsafe_arena_release_case_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:clojureRT.protobuf.Subnode.case)
  if (_internal_has_case_()) {
    clear_has_types();
    ::clojureRT::protobuf::CaseNode* temp = _impl_.types_.case__;
    _impl_.types_.case__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Subnode::unsafe_arena_set_allocated_case_(::clojureRT::protobuf::CaseNode* case_) {
  clear_types();
  if (case_) {
    set_has_case_();
    _impl_.types_.case__ = case_;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.Subnode.case)
}
inline ::clojureRT::protobuf::CaseNode* Subnode::_internal_mutable_case_() {
  if (!_internal_has_case_()) {
    clear_types();
    set_has_case_();
    _impl_.types_.case__ = CreateMaybeMessage< ::clojureRT::protobuf::CaseNode >(GetArenaForAllocation());
  }
  return _impl_.types_.case__;
}
inline ::clojureRT::protobuf::CaseNode* Subnode::mutable_case_() {
  ::clojureRT::protobuf::CaseNode* _msg = _internal_mutable_case_();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.Subnode.case)
  return _msg;
}

// .clojureRT.protobuf.CaseTestNode caseTest = 3;
inline bool Subnode::_internal_has_casetest() const {
  return types_case() == kCaseTest;
}
inline bool Subnode::has_casetest() const {
  return _internal_has_casetest();
}
inline void Subnode::set_has_casetest() {
  _impl_._oneof_case_[0] = kCaseTest;
}
inline void Subnode::clear_casetest() {
  if (_internal_has_casetest()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.types_.casetest_;
    }
    clear_has_types();
  }
}
inline ::clojureRT::protobuf::CaseTestNode* Subnode::release_casetest() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.Subnode.caseTest)
  if (_internal_has_casetest()) {
    clear_has_types();
    ::clojureRT::protobuf::CaseTestNode* temp = _impl_.types_.casetest_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.types_.casetest_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clojureRT::protobuf::CaseTestNode& Subnode::_internal_casetest() const {
  return _internal_has_casetest()
      ? *_impl_.types_.casetest_
      : reinterpret_cast< ::clojureRT::protobuf::CaseTestNode&>(::clojureRT::protobuf::_CaseTestNode_default_instance_);
}
inline const ::clojureRT::protobuf::CaseTestNode& Subnode::casetest() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.Subnode.caseTest)
  return _internal_casetest();
}
inline ::clojureRT::protobuf::CaseTestNode* Subnode::unsafe_arena_release_casetest() {
  // @@protoc_insertion_point(field_unsafe_arena_release:clojureRT.protobuf.Subnode.caseTest)
  if (_internal_has_casetest()) {
    clear_has_types();
    ::clojureRT::protobuf::CaseTestNode* temp = _impl_.types_.casetest_;
    _impl_.types_.casetest_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Subnode::unsafe_arena_set_allocated_casetest(::clojureRT::protobuf::CaseTestNode* casetest) {
  clear_types();
  if (casetest) {
    set_has_casetest();
    _impl_.types_.casetest_ = casetest;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.Subnode.caseTest)
}
inline ::clojureRT::protobuf::CaseTestNode* Subnode::_internal_mutable_casetest() {
  if (!_internal_has_casetest()) {
    clear_types();
    set_has_casetest();
    _impl_.types_.casetest_ = CreateMaybeMessage< ::clojureRT::protobuf::CaseTestNode >(GetArenaForAllocation());
  }
  return _impl_.types_.casetest_;
}
inline ::clojureRT::protobuf::CaseTestNode* Subnode::mutable_casetest() {
  ::clojureRT::protobuf::CaseTestNode* _msg = _internal_mutable_casetest();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.Subnode.caseTest)
  return _msg;
}

// .clojureRT.protobuf.CaseThenNode caseThen = 4;
inline bool Subnode::_internal_has_casethen() const {
  return types_case() == kCaseThen;
}
inline bool Subnode::has_casethen() const {
  return _internal_has_casethen();
}
inline void Subnode::set_has_casethen() {
  _impl_._oneof_case_[0] = kCaseThen;
}
inline void Subnode::clear_casethen() {
  if (_internal_has_casethen()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.types_.casethen_;
    }
    clear_has_types();
  }
}
inline ::clojureRT::protobuf::CaseThenNode* Subnode::release_casethen() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.Subnode.caseThen)
  if (_internal_has_casethen()) {
    clear_has_types();
    ::clojureRT::protobuf::CaseThenNode* temp = _impl_.types_.casethen_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.types_.casethen_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clojureRT::protobuf::CaseThenNode& Subnode::_internal_casethen() const {
  return _internal_has_casethen()
      ? *_impl_.types_.casethen_
      : reinterpret_cast< ::clojureRT::protobuf::CaseThenNode&>(::clojureRT::protobuf::_CaseThenNode_default_instance_);
}
inline const ::clojureRT::protobuf::CaseThenNode& Subnode::casethen() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.Subnode.caseThen)
  return _internal_casethen();
}
inline ::clojureRT::protobuf::CaseThenNode* Subnode::unsafe_arena_release_casethen() {
  // @@protoc_insertion_point(field_unsafe_arena_release:clojureRT.protobuf.Subnode.caseThen)
  if (_internal_has_casethen()) {
    clear_has_types();
    ::clojureRT::protobuf::CaseThenNode* temp = _impl_.types_.casethen_;
    _impl_.types_.casethen_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Subnode::unsafe_arena_set_allocated_casethen(::clojureRT::protobuf::CaseThenNode* casethen) {
  clear_types();
  if (casethen) {
    set_has_casethen();
    _impl_.types_.casethen_ = casethen;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.Subnode.caseThen)
}
inline ::clojureRT::protobuf::CaseThenNode* Subnode::_internal_mutable_casethen() {
  if (!_internal_has_casethen()) {
    clear_types();
    set_has_casethen();
    _impl_.types_.casethen_ = CreateMaybeMessage< ::clojureRT::protobuf::CaseThenNode >(GetArenaForAllocation());
  }
  return _impl_.types_.casethen_;
}
inline ::clojureRT::protobuf::CaseThenNode* Subnode::mutable_casethen() {
  ::clojureRT::protobuf::CaseThenNode* _msg = _internal_mutable_casethen();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.Subnode.caseThen)
  return _msg;
}

// .clojureRT.protobuf.CatchNode catch = 5;
inline bool Subnode::_internal_has_catch_() const {
  return types_case() == kCatch;
}
inline bool Subnode::has_catch_() const {
  return _internal_has_catch_();
}
inline void Subnode::set_has_catch_() {
  _impl_._oneof_case_[0] = kCatch;
}
inline void Subnode::clear_catch_() {
  if (_internal_has_catch_()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.types_.catch__;
    }
    clear_has_types();
  }
}
inline ::clojureRT::protobuf::CatchNode* Subnode::release_catch_() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.Subnode.catch)
  if (_internal_has_catch_()) {
    clear_has_types();
    ::clojureRT::protobuf::CatchNode* temp = _impl_.types_.catch__;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.types_.catch__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clojureRT::protobuf::CatchNode& Subnode::_internal_catch_() const {
  return _internal_has_catch_()
      ? *_impl_.types_.catch__
      : reinterpret_cast< ::clojureRT::protobuf::CatchNode&>(::clojureRT::protobuf::_CatchNode_default_instance_);
}
inline const ::clojureRT::protobuf::CatchNode& Subnode::catch_() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.Subnode.catch)
  return _internal_catch_();
}
inline ::clojureRT::protobuf::CatchNode* Subnode::unsafe_arena_release_catch_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:clojureRT.protobuf.Subnode.catch)
  if (_internal_has_catch_()) {
    clear_has_types();
    ::clojureRT::protobuf::CatchNode* temp = _impl_.types_.catch__;
    _impl_.types_.catch__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Subnode::unsafe_arena_set_allocated_catch_(::clojureRT::protobuf::CatchNode* catch_) {
  clear_types();
  if (catch_) {
    set_has_catch_();
    _impl_.types_.catch__ = catch_;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.Subnode.catch)
}
inline ::clojureRT::protobuf::CatchNode* Subnode::_internal_mutable_catch_() {
  if (!_internal_has_catch_()) {
    clear_types();
    set_has_catch_();
    _impl_.types_.catch__ = CreateMaybeMessage< ::clojureRT::protobuf::CatchNode >(GetArenaForAllocation());
  }
  return _impl_.types_.catch__;
}
inline ::clojureRT::protobuf::CatchNode* Subnode::mutable_catch_() {
  ::clojureRT::protobuf::CatchNode* _msg = _internal_mutable_catch_();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.Subnode.catch)
  return _msg;
}

// .clojureRT.protobuf.ConstNode const = 6;
inline bool Subnode::_internal_has_const_() const {
  return types_case() == kConst;
}
inline bool Subnode::has_const_() const {
  return _internal_has_const_();
}
inline void Subnode::set_has_const_() {
  _impl_._oneof_case_[0] = kConst;
}
inline void Subnode::clear_const_() {
  if (_internal_has_const_()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.types_.const__;
    }
    clear_has_types();
  }
}
inline ::clojureRT::protobuf::ConstNode* Subnode::release_const_() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.Subnode.const)
  if (_internal_has_const_()) {
    clear_has_types();
    ::clojureRT::protobuf::ConstNode* temp = _impl_.types_.const__;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.types_.const__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clojureRT::protobuf::ConstNode& Subnode::_internal_const_() const {
  return _internal_has_const_()
      ? *_impl_.types_.const__
      : reinterpret_cast< ::clojureRT::protobuf::ConstNode&>(::clojureRT::protobuf::_ConstNode_default_instance_);
}
inline const ::clojureRT::protobuf::ConstNode& Subnode::const_() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.Subnode.const)
  return _internal_const_();
}
inline ::clojureRT::protobuf::ConstNode* Subnode::unsafe_arena_release_const_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:clojureRT.protobuf.Subnode.const)
  if (_internal_has_const_()) {
    clear_has_types();
    ::clojureRT::protobuf::ConstNode* temp = _impl_.types_.const__;
    _impl_.types_.const__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Subnode::unsafe_arena_set_allocated_const_(::clojureRT::protobuf::ConstNode* const_) {
  clear_types();
  if (const_) {
    set_has_const_();
    _impl_.types_.const__ = const_;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.Subnode.const)
}
inline ::clojureRT::protobuf::ConstNode* Subnode::_internal_mutable_const_() {
  if (!_internal_has_const_()) {
    clear_types();
    set_has_const_();
    _impl_.types_.const__ = CreateMaybeMessage< ::clojureRT::protobuf::ConstNode >(GetArenaForAllocation());
  }
  return _impl_.types_.const__;
}
inline ::clojureRT::protobuf::ConstNode* Subnode::mutable_const_() {
  ::clojureRT::protobuf::ConstNode* _msg = _internal_mutable_const_();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.Subnode.const)
  return _msg;
}

// .clojureRT.protobuf.DefNode def = 7;
inline bool Subnode::_internal_has_def() const {
  return types_case() == kDef;
}
inline bool Subnode::has_def() const {
  return _internal_has_def();
}
inline void Subnode::set_has_def() {
  _impl_._oneof_case_[0] = kDef;
}
inline void Subnode::clear_def() {
  if (_internal_has_def()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.types_.def_;
    }
    clear_has_types();
  }
}
inline ::clojureRT::protobuf::DefNode* Subnode::release_def() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.Subnode.def)
  if (_internal_has_def()) {
    clear_has_types();
    ::clojureRT::protobuf::DefNode* temp = _impl_.types_.def_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.types_.def_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clojureRT::protobuf::DefNode& Subnode::_internal_def() const {
  return _internal_has_def()
      ? *_impl_.types_.def_
      : reinterpret_cast< ::clojureRT::protobuf::DefNode&>(::clojureRT::protobuf::_DefNode_default_instance_);
}
inline const ::clojureRT::protobuf::DefNode& Subnode::def() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.Subnode.def)
  return _internal_def();
}
inline ::clojureRT::protobuf::DefNode* Subnode::unsafe_arena_release_def() {
  // @@protoc_insertion_point(field_unsafe_arena_release:clojureRT.protobuf.Subnode.def)
  if (_internal_has_def()) {
    clear_has_types();
    ::clojureRT::protobuf::DefNode* temp = _impl_.types_.def_;
    _impl_.types_.def_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Subnode::unsafe_arena_set_allocated_def(::clojureRT::protobuf::DefNode* def) {
  clear_types();
  if (def) {
    set_has_def();
    _impl_.types_.def_ = def;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.Subnode.def)
}
inline ::clojureRT::protobuf::DefNode* Subnode::_internal_mutable_def() {
  if (!_internal_has_def()) {
    clear_types();
    set_has_def();
    _impl_.types_.def_ = CreateMaybeMessage< ::clojureRT::protobuf::DefNode >(GetArenaForAllocation());
  }
  return _impl_.types_.def_;
}
inline ::clojureRT::protobuf::DefNode* Subnode::mutable_def() {
  ::clojureRT::protobuf::DefNode* _msg = _internal_mutable_def();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.Subnode.def)
  return _msg;
}

// .clojureRT.protobuf.DeftypeNode deftype = 8;
inline bool Subnode::_internal_has_deftype() const {
  return types_case() == kDeftype;
}
inline bool Subnode::has_deftype() const {
  return _internal_has_deftype();
}
inline void Subnode::set_has_deftype() {
  _impl_._oneof_case_[0] = kDeftype;
}
inline void Subnode::clear_deftype() {
  if (_internal_has_deftype()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.types_.deftype_;
    }
    clear_has_types();
  }
}
inline ::clojureRT::protobuf::DeftypeNode* Subnode::release_deftype() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.Subnode.deftype)
  if (_internal_has_deftype()) {
    clear_has_types();
    ::clojureRT::protobuf::DeftypeNode* temp = _impl_.types_.deftype_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.types_.deftype_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clojureRT::protobuf::DeftypeNode& Subnode::_internal_deftype() const {
  return _internal_has_deftype()
      ? *_impl_.types_.deftype_
      : reinterpret_cast< ::clojureRT::protobuf::DeftypeNode&>(::clojureRT::protobuf::_DeftypeNode_default_instance_);
}
inline const ::clojureRT::protobuf::DeftypeNode& Subnode::deftype() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.Subnode.deftype)
  return _internal_deftype();
}
inline ::clojureRT::protobuf::DeftypeNode* Subnode::unsafe_arena_release_deftype() {
  // @@protoc_insertion_point(field_unsafe_arena_release:clojureRT.protobuf.Subnode.deftype)
  if (_internal_has_deftype()) {
    clear_has_types();
    ::clojureRT::protobuf::DeftypeNode* temp = _impl_.types_.deftype_;
    _impl_.types_.deftype_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Subnode::unsafe_arena_set_allocated_deftype(::clojureRT::protobuf::DeftypeNode* deftype) {
  clear_types();
  if (deftype) {
    set_has_deftype();
    _impl_.types_.deftype_ = deftype;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.Subnode.deftype)
}
inline ::clojureRT::protobuf::DeftypeNode* Subnode::_internal_mutable_deftype() {
  if (!_internal_has_deftype()) {
    clear_types();
    set_has_deftype();
    _impl_.types_.deftype_ = CreateMaybeMessage< ::clojureRT::protobuf::DeftypeNode >(GetArenaForAllocation());
  }
  return _impl_.types_.deftype_;
}
inline ::clojureRT::protobuf::DeftypeNode* Subnode::mutable_deftype() {
  ::clojureRT::protobuf::DeftypeNode* _msg = _internal_mutable_deftype();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.Subnode.deftype)
  return _msg;
}

// .clojureRT.protobuf.DoNode do = 9;
inline bool Subnode::_internal_has_do_() const {
  return types_case() == kDo;
}
inline bool Subnode::has_do_() const {
  return _internal_has_do_();
}
inline void Subnode::set_has_do_() {
  _impl_._oneof_case_[0] = kDo;
}
inline void Subnode::clear_do_() {
  if (_internal_has_do_()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.types_.do__;
    }
    clear_has_types();
  }
}
inline ::clojureRT::protobuf::DoNode* Subnode::release_do_() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.Subnode.do)
  if (_internal_has_do_()) {
    clear_has_types();
    ::clojureRT::protobuf::DoNode* temp = _impl_.types_.do__;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.types_.do__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clojureRT::protobuf::DoNode& Subnode::_internal_do_() const {
  return _internal_has_do_()
      ? *_impl_.types_.do__
      : reinterpret_cast< ::clojureRT::protobuf::DoNode&>(::clojureRT::protobuf::_DoNode_default_instance_);
}
inline const ::clojureRT::protobuf::DoNode& Subnode::do_() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.Subnode.do)
  return _internal_do_();
}
inline ::clojureRT::protobuf::DoNode* Subnode::unsafe_arena_release_do_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:clojureRT.protobuf.Subnode.do)
  if (_internal_has_do_()) {
    clear_has_types();
    ::clojureRT::protobuf::DoNode* temp = _impl_.types_.do__;
    _impl_.types_.do__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Subnode::unsafe_arena_set_allocated_do_(::clojureRT::protobuf::DoNode* do_) {
  clear_types();
  if (do_) {
    set_has_do_();
    _impl_.types_.do__ = do_;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.Subnode.do)
}
inline ::clojureRT::protobuf::DoNode* Subnode::_internal_mutable_do_() {
  if (!_internal_has_do_()) {
    clear_types();
    set_has_do_();
    _impl_.types_.do__ = CreateMaybeMessage< ::clojureRT::protobuf::DoNode >(GetArenaForAllocation());
  }
  return _impl_.types_.do__;
}
inline ::clojureRT::protobuf::DoNode* Subnode::mutable_do_() {
  ::clojureRT::protobuf::DoNode* _msg = _internal_mutable_do_();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.Subnode.do)
  return _msg;
}

// .clojureRT.protobuf.FnNode fn = 10;
inline bool Subnode::_internal_has_fn() const {
  return types_case() == kFn;
}
inline bool Subnode::has_fn() const {
  return _internal_has_fn();
}
inline void Subnode::set_has_fn() {
  _impl_._oneof_case_[0] = kFn;
}
inline void Subnode::clear_fn() {
  if (_internal_has_fn()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.types_.fn_;
    }
    clear_has_types();
  }
}
inline ::clojureRT::protobuf::FnNode* Subnode::release_fn() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.Subnode.fn)
  if (_internal_has_fn()) {
    clear_has_types();
    ::clojureRT::protobuf::FnNode* temp = _impl_.types_.fn_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.types_.fn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clojureRT::protobuf::FnNode& Subnode::_internal_fn() const {
  return _internal_has_fn()
      ? *_impl_.types_.fn_
      : reinterpret_cast< ::clojureRT::protobuf::FnNode&>(::clojureRT::protobuf::_FnNode_default_instance_);
}
inline const ::clojureRT::protobuf::FnNode& Subnode::fn() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.Subnode.fn)
  return _internal_fn();
}
inline ::clojureRT::protobuf::FnNode* Subnode::unsafe_arena_release_fn() {
  // @@protoc_insertion_point(field_unsafe_arena_release:clojureRT.protobuf.Subnode.fn)
  if (_internal_has_fn()) {
    clear_has_types();
    ::clojureRT::protobuf::FnNode* temp = _impl_.types_.fn_;
    _impl_.types_.fn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Subnode::unsafe_arena_set_allocated_fn(::clojureRT::protobuf::FnNode* fn) {
  clear_types();
  if (fn) {
    set_has_fn();
    _impl_.types_.fn_ = fn;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.Subnode.fn)
}
inline ::clojureRT::protobuf::FnNode* Subnode::_internal_mutable_fn() {
  if (!_internal_has_fn()) {
    clear_types();
    set_has_fn();
    _impl_.types_.fn_ = CreateMaybeMessage< ::clojureRT::protobuf::FnNode >(GetArenaForAllocation());
  }
  return _impl_.types_.fn_;
}
inline ::clojureRT::protobuf::FnNode* Subnode::mutable_fn() {
  ::clojureRT::protobuf::FnNode* _msg = _internal_mutable_fn();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.Subnode.fn)
  return _msg;
}

// .clojureRT.protobuf.FnMethodNode fnMethod = 11;
inline bool Subnode::_internal_has_fnmethod() const {
  return types_case() == kFnMethod;
}
inline bool Subnode::has_fnmethod() const {
  return _internal_has_fnmethod();
}
inline void Subnode::set_has_fnmethod() {
  _impl_._oneof_case_[0] = kFnMethod;
}
inline void Subnode::clear_fnmethod() {
  if (_internal_has_fnmethod()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.types_.fnmethod_;
    }
    clear_has_types();
  }
}
inline ::clojureRT::protobuf::FnMethodNode* Subnode::release_fnmethod() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.Subnode.fnMethod)
  if (_internal_has_fnmethod()) {
    clear_has_types();
    ::clojureRT::protobuf::FnMethodNode* temp = _impl_.types_.fnmethod_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.types_.fnmethod_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clojureRT::protobuf::FnMethodNode& Subnode::_internal_fnmethod() const {
  return _internal_has_fnmethod()
      ? *_impl_.types_.fnmethod_
      : reinterpret_cast< ::clojureRT::protobuf::FnMethodNode&>(::clojureRT::protobuf::_FnMethodNode_default_instance_);
}
inline const ::clojureRT::protobuf::FnMethodNode& Subnode::fnmethod() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.Subnode.fnMethod)
  return _internal_fnmethod();
}
inline ::clojureRT::protobuf::FnMethodNode* Subnode::unsafe_arena_release_fnmethod() {
  // @@protoc_insertion_point(field_unsafe_arena_release:clojureRT.protobuf.Subnode.fnMethod)
  if (_internal_has_fnmethod()) {
    clear_has_types();
    ::clojureRT::protobuf::FnMethodNode* temp = _impl_.types_.fnmethod_;
    _impl_.types_.fnmethod_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Subnode::unsafe_arena_set_allocated_fnmethod(::clojureRT::protobuf::FnMethodNode* fnmethod) {
  clear_types();
  if (fnmethod) {
    set_has_fnmethod();
    _impl_.types_.fnmethod_ = fnmethod;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.Subnode.fnMethod)
}
inline ::clojureRT::protobuf::FnMethodNode* Subnode::_internal_mutable_fnmethod() {
  if (!_internal_has_fnmethod()) {
    clear_types();
    set_has_fnmethod();
    _impl_.types_.fnmethod_ = CreateMaybeMessage< ::clojureRT::protobuf::FnMethodNode >(GetArenaForAllocation());
  }
  return _impl_.types_.fnmethod_;
}
inline ::clojureRT::protobuf::FnMethodNode* Subnode::mutable_fnmethod() {
  ::clojureRT::protobuf::FnMethodNode* _msg = _internal_mutable_fnmethod();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.Subnode.fnMethod)
  return _msg;
}

// .clojureRT.protobuf.HostInteropNode hostInterop = 12;
inline bool Subnode::_internal_has_hostinterop() const {
  return types_case() == kHostInterop;
}
inline bool Subnode::has_hostinterop() const {
  return _internal_has_hostinterop();
}
inline void Subnode::set_has_hostinterop() {
  _impl_._oneof_case_[0] = kHostInterop;
}
inline void Subnode::clear_hostinterop() {
  if (_internal_has_hostinterop()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.types_.hostinterop_;
    }
    clear_has_types();
  }
}
inline ::clojureRT::protobuf::HostInteropNode* Subnode::release_hostinterop() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.Subnode.hostInterop)
  if (_internal_has_hostinterop()) {
    clear_has_types();
    ::clojureRT::protobuf::HostInteropNode* temp = _impl_.types_.hostinterop_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.types_.hostinterop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clojureRT::protobuf::HostInteropNode& Subnode::_internal_hostinterop() const {
  return _internal_has_hostinterop()
      ? *_impl_.types_.hostinterop_
      : reinterpret_cast< ::clojureRT::protobuf::HostInteropNode&>(::clojureRT::protobuf::_HostInteropNode_default_instance_);
}
inline const ::clojureRT::protobuf::HostInteropNode& Subnode::hostinterop() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.Subnode.hostInterop)
  return _internal_hostinterop();
}
inline ::clojureRT::protobuf::HostInteropNode* Subnode::unsafe_arena_release_hostinterop() {
  // @@protoc_insertion_point(field_unsafe_arena_release:clojureRT.protobuf.Subnode.hostInterop)
  if (_internal_has_hostinterop()) {
    clear_has_types();
    ::clojureRT::protobuf::HostInteropNode* temp = _impl_.types_.hostinterop_;
    _impl_.types_.hostinterop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Subnode::unsafe_arena_set_allocated_hostinterop(::clojureRT::protobuf::HostInteropNode* hostinterop) {
  clear_types();
  if (hostinterop) {
    set_has_hostinterop();
    _impl_.types_.hostinterop_ = hostinterop;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.Subnode.hostInterop)
}
inline ::clojureRT::protobuf::HostInteropNode* Subnode::_internal_mutable_hostinterop() {
  if (!_internal_has_hostinterop()) {
    clear_types();
    set_has_hostinterop();
    _impl_.types_.hostinterop_ = CreateMaybeMessage< ::clojureRT::protobuf::HostInteropNode >(GetArenaForAllocation());
  }
  return _impl_.types_.hostinterop_;
}
inline ::clojureRT::protobuf::HostInteropNode* Subnode::mutable_hostinterop() {
  ::clojureRT::protobuf::HostInteropNode* _msg = _internal_mutable_hostinterop();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.Subnode.hostInterop)
  return _msg;
}

// .clojureRT.protobuf.IfNode if = 13;
inline bool Subnode::_internal_has_if_() const {
  return types_case() == kIf;
}
inline bool Subnode::has_if_() const {
  return _internal_has_if_();
}
inline void Subnode::set_has_if_() {
  _impl_._oneof_case_[0] = kIf;
}
inline void Subnode::clear_if_() {
  if (_internal_has_if_()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.types_.if__;
    }
    clear_has_types();
  }
}
inline ::clojureRT::protobuf::IfNode* Subnode::release_if_() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.Subnode.if)
  if (_internal_has_if_()) {
    clear_has_types();
    ::clojureRT::protobuf::IfNode* temp = _impl_.types_.if__;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.types_.if__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clojureRT::protobuf::IfNode& Subnode::_internal_if_() const {
  return _internal_has_if_()
      ? *_impl_.types_.if__
      : reinterpret_cast< ::clojureRT::protobuf::IfNode&>(::clojureRT::protobuf::_IfNode_default_instance_);
}
inline const ::clojureRT::protobuf::IfNode& Subnode::if_() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.Subnode.if)
  return _internal_if_();
}
inline ::clojureRT::protobuf::IfNode* Subnode::unsafe_arena_release_if_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:clojureRT.protobuf.Subnode.if)
  if (_internal_has_if_()) {
    clear_has_types();
    ::clojureRT::protobuf::IfNode* temp = _impl_.types_.if__;
    _impl_.types_.if__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Subnode::unsafe_arena_set_allocated_if_(::clojureRT::protobuf::IfNode* if_) {
  clear_types();
  if (if_) {
    set_has_if_();
    _impl_.types_.if__ = if_;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.Subnode.if)
}
inline ::clojureRT::protobuf::IfNode* Subnode::_internal_mutable_if_() {
  if (!_internal_has_if_()) {
    clear_types();
    set_has_if_();
    _impl_.types_.if__ = CreateMaybeMessage< ::clojureRT::protobuf::IfNode >(GetArenaForAllocation());
  }
  return _impl_.types_.if__;
}
inline ::clojureRT::protobuf::IfNode* Subnode::mutable_if_() {
  ::clojureRT::protobuf::IfNode* _msg = _internal_mutable_if_();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.Subnode.if)
  return _msg;
}

// .clojureRT.protobuf.ImportNode import = 14;
inline bool Subnode::_internal_has_import() const {
  return types_case() == kImport;
}
inline bool Subnode::has_import() const {
  return _internal_has_import();
}
inline void Subnode::set_has_import() {
  _impl_._oneof_case_[0] = kImport;
}
inline void Subnode::clear_import() {
  if (_internal_has_import()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.types_.import_;
    }
    clear_has_types();
  }
}
inline ::clojureRT::protobuf::ImportNode* Subnode::release_import() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.Subnode.import)
  if (_internal_has_import()) {
    clear_has_types();
    ::clojureRT::protobuf::ImportNode* temp = _impl_.types_.import_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.types_.import_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clojureRT::protobuf::ImportNode& Subnode::_internal_import() const {
  return _internal_has_import()
      ? *_impl_.types_.import_
      : reinterpret_cast< ::clojureRT::protobuf::ImportNode&>(::clojureRT::protobuf::_ImportNode_default_instance_);
}
inline const ::clojureRT::protobuf::ImportNode& Subnode::import() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.Subnode.import)
  return _internal_import();
}
inline ::clojureRT::protobuf::ImportNode* Subnode::unsafe_arena_release_import() {
  // @@protoc_insertion_point(field_unsafe_arena_release:clojureRT.protobuf.Subnode.import)
  if (_internal_has_import()) {
    clear_has_types();
    ::clojureRT::protobuf::ImportNode* temp = _impl_.types_.import_;
    _impl_.types_.import_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Subnode::unsafe_arena_set_allocated_import(::clojureRT::protobuf::ImportNode* import) {
  clear_types();
  if (import) {
    set_has_import();
    _impl_.types_.import_ = import;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.Subnode.import)
}
inline ::clojureRT::protobuf::ImportNode* Subnode::_internal_mutable_import() {
  if (!_internal_has_import()) {
    clear_types();
    set_has_import();
    _impl_.types_.import_ = CreateMaybeMessage< ::clojureRT::protobuf::ImportNode >(GetArenaForAllocation());
  }
  return _impl_.types_.import_;
}
inline ::clojureRT::protobuf::ImportNode* Subnode::mutable_import() {
  ::clojureRT::protobuf::ImportNode* _msg = _internal_mutable_import();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.Subnode.import)
  return _msg;
}

// .clojureRT.protobuf.InstanceCallNode instanceCall = 15;
inline bool Subnode::_internal_has_instancecall() const {
  return types_case() == kInstanceCall;
}
inline bool Subnode::has_instancecall() const {
  return _internal_has_instancecall();
}
inline void Subnode::set_has_instancecall() {
  _impl_._oneof_case_[0] = kInstanceCall;
}
inline void Subnode::clear_instancecall() {
  if (_internal_has_instancecall()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.types_.instancecall_;
    }
    clear_has_types();
  }
}
inline ::clojureRT::protobuf::InstanceCallNode* Subnode::release_instancecall() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.Subnode.instanceCall)
  if (_internal_has_instancecall()) {
    clear_has_types();
    ::clojureRT::protobuf::InstanceCallNode* temp = _impl_.types_.instancecall_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.types_.instancecall_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clojureRT::protobuf::InstanceCallNode& Subnode::_internal_instancecall() const {
  return _internal_has_instancecall()
      ? *_impl_.types_.instancecall_
      : reinterpret_cast< ::clojureRT::protobuf::InstanceCallNode&>(::clojureRT::protobuf::_InstanceCallNode_default_instance_);
}
inline const ::clojureRT::protobuf::InstanceCallNode& Subnode::instancecall() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.Subnode.instanceCall)
  return _internal_instancecall();
}
inline ::clojureRT::protobuf::InstanceCallNode* Subnode::unsafe_arena_release_instancecall() {
  // @@protoc_insertion_point(field_unsafe_arena_release:clojureRT.protobuf.Subnode.instanceCall)
  if (_internal_has_instancecall()) {
    clear_has_types();
    ::clojureRT::protobuf::InstanceCallNode* temp = _impl_.types_.instancecall_;
    _impl_.types_.instancecall_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Subnode::unsafe_arena_set_allocated_instancecall(::clojureRT::protobuf::InstanceCallNode* instancecall) {
  clear_types();
  if (instancecall) {
    set_has_instancecall();
    _impl_.types_.instancecall_ = instancecall;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.Subnode.instanceCall)
}
inline ::clojureRT::protobuf::InstanceCallNode* Subnode::_internal_mutable_instancecall() {
  if (!_internal_has_instancecall()) {
    clear_types();
    set_has_instancecall();
    _impl_.types_.instancecall_ = CreateMaybeMessage< ::clojureRT::protobuf::InstanceCallNode >(GetArenaForAllocation());
  }
  return _impl_.types_.instancecall_;
}
inline ::clojureRT::protobuf::InstanceCallNode* Subnode::mutable_instancecall() {
  ::clojureRT::protobuf::InstanceCallNode* _msg = _internal_mutable_instancecall();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.Subnode.instanceCall)
  return _msg;
}

// .clojureRT.protobuf.InstanceFieldNode instanceField = 16;
inline bool Subnode::_internal_has_instancefield() const {
  return types_case() == kInstanceField;
}
inline bool Subnode::has_instancefield() const {
  return _internal_has_instancefield();
}
inline void Subnode::set_has_instancefield() {
  _impl_._oneof_case_[0] = kInstanceField;
}
inline void Subnode::clear_instancefield() {
  if (_internal_has_instancefield()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.types_.instancefield_;
    }
    clear_has_types();
  }
}
inline ::clojureRT::protobuf::InstanceFieldNode* Subnode::release_instancefield() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.Subnode.instanceField)
  if (_internal_has_instancefield()) {
    clear_has_types();
    ::clojureRT::protobuf::InstanceFieldNode* temp = _impl_.types_.instancefield_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.types_.instancefield_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clojureRT::protobuf::InstanceFieldNode& Subnode::_internal_instancefield() const {
  return _internal_has_instancefield()
      ? *_impl_.types_.instancefield_
      : reinterpret_cast< ::clojureRT::protobuf::InstanceFieldNode&>(::clojureRT::protobuf::_InstanceFieldNode_default_instance_);
}
inline const ::clojureRT::protobuf::InstanceFieldNode& Subnode::instancefield() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.Subnode.instanceField)
  return _internal_instancefield();
}
inline ::clojureRT::protobuf::InstanceFieldNode* Subnode::unsafe_arena_release_instancefield() {
  // @@protoc_insertion_point(field_unsafe_arena_release:clojureRT.protobuf.Subnode.instanceField)
  if (_internal_has_instancefield()) {
    clear_has_types();
    ::clojureRT::protobuf::InstanceFieldNode* temp = _impl_.types_.instancefield_;
    _impl_.types_.instancefield_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Subnode::unsafe_arena_set_allocated_instancefield(::clojureRT::protobuf::InstanceFieldNode* instancefield) {
  clear_types();
  if (instancefield) {
    set_has_instancefield();
    _impl_.types_.instancefield_ = instancefield;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.Subnode.instanceField)
}
inline ::clojureRT::protobuf::InstanceFieldNode* Subnode::_internal_mutable_instancefield() {
  if (!_internal_has_instancefield()) {
    clear_types();
    set_has_instancefield();
    _impl_.types_.instancefield_ = CreateMaybeMessage< ::clojureRT::protobuf::InstanceFieldNode >(GetArenaForAllocation());
  }
  return _impl_.types_.instancefield_;
}
inline ::clojureRT::protobuf::InstanceFieldNode* Subnode::mutable_instancefield() {
  ::clojureRT::protobuf::InstanceFieldNode* _msg = _internal_mutable_instancefield();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.Subnode.instanceField)
  return _msg;
}

// .clojureRT.protobuf.IsInstanceNode isInstance = 17;
inline bool Subnode::_internal_has_isinstance() const {
  return types_case() == kIsInstance;
}
inline bool Subnode::has_isinstance() const {
  return _internal_has_isinstance();
}
inline void Subnode::set_has_isinstance() {
  _impl_._oneof_case_[0] = kIsInstance;
}
inline void Subnode::clear_isinstance() {
  if (_internal_has_isinstance()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.types_.isinstance_;
    }
    clear_has_types();
  }
}
inline ::clojureRT::protobuf::IsInstanceNode* Subnode::release_isinstance() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.Subnode.isInstance)
  if (_internal_has_isinstance()) {
    clear_has_types();
    ::clojureRT::protobuf::IsInstanceNode* temp = _impl_.types_.isinstance_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.types_.isinstance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clojureRT::protobuf::IsInstanceNode& Subnode::_internal_isinstance() const {
  return _internal_has_isinstance()
      ? *_impl_.types_.isinstance_
      : reinterpret_cast< ::clojureRT::protobuf::IsInstanceNode&>(::clojureRT::protobuf::_IsInstanceNode_default_instance_);
}
inline const ::clojureRT::protobuf::IsInstanceNode& Subnode::isinstance() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.Subnode.isInstance)
  return _internal_isinstance();
}
inline ::clojureRT::protobuf::IsInstanceNode* Subnode::unsafe_arena_release_isinstance() {
  // @@protoc_insertion_point(field_unsafe_arena_release:clojureRT.protobuf.Subnode.isInstance)
  if (_internal_has_isinstance()) {
    clear_has_types();
    ::clojureRT::protobuf::IsInstanceNode* temp = _impl_.types_.isinstance_;
    _impl_.types_.isinstance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Subnode::unsafe_arena_set_allocated_isinstance(::clojureRT::protobuf::IsInstanceNode* isinstance) {
  clear_types();
  if (isinstance) {
    set_has_isinstance();
    _impl_.types_.isinstance_ = isinstance;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.Subnode.isInstance)
}
inline ::clojureRT::protobuf::IsInstanceNode* Subnode::_internal_mutable_isinstance() {
  if (!_internal_has_isinstance()) {
    clear_types();
    set_has_isinstance();
    _impl_.types_.isinstance_ = CreateMaybeMessage< ::clojureRT::protobuf::IsInstanceNode >(GetArenaForAllocation());
  }
  return _impl_.types_.isinstance_;
}
inline ::clojureRT::protobuf::IsInstanceNode* Subnode::mutable_isinstance() {
  ::clojureRT::protobuf::IsInstanceNode* _msg = _internal_mutable_isinstance();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.Subnode.isInstance)
  return _msg;
}

// .clojureRT.protobuf.InvokeNode invoke = 18;
inline bool Subnode::_internal_has_invoke() const {
  return types_case() == kInvoke;
}
inline bool Subnode::has_invoke() const {
  return _internal_has_invoke();
}
inline void Subnode::set_has_invoke() {
  _impl_._oneof_case_[0] = kInvoke;
}
inline void Subnode::clear_invoke() {
  if (_internal_has_invoke()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.types_.invoke_;
    }
    clear_has_types();
  }
}
inline ::clojureRT::protobuf::InvokeNode* Subnode::release_invoke() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.Subnode.invoke)
  if (_internal_has_invoke()) {
    clear_has_types();
    ::clojureRT::protobuf::InvokeNode* temp = _impl_.types_.invoke_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.types_.invoke_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clojureRT::protobuf::InvokeNode& Subnode::_internal_invoke() const {
  return _internal_has_invoke()
      ? *_impl_.types_.invoke_
      : reinterpret_cast< ::clojureRT::protobuf::InvokeNode&>(::clojureRT::protobuf::_InvokeNode_default_instance_);
}
inline const ::clojureRT::protobuf::InvokeNode& Subnode::invoke() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.Subnode.invoke)
  return _internal_invoke();
}
inline ::clojureRT::protobuf::InvokeNode* Subnode::unsafe_arena_release_invoke() {
  // @@protoc_insertion_point(field_unsafe_arena_release:clojureRT.protobuf.Subnode.invoke)
  if (_internal_has_invoke()) {
    clear_has_types();
    ::clojureRT::protobuf::InvokeNode* temp = _impl_.types_.invoke_;
    _impl_.types_.invoke_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Subnode::unsafe_arena_set_allocated_invoke(::clojureRT::protobuf::InvokeNode* invoke) {
  clear_types();
  if (invoke) {
    set_has_invoke();
    _impl_.types_.invoke_ = invoke;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.Subnode.invoke)
}
inline ::clojureRT::protobuf::InvokeNode* Subnode::_internal_mutable_invoke() {
  if (!_internal_has_invoke()) {
    clear_types();
    set_has_invoke();
    _impl_.types_.invoke_ = CreateMaybeMessage< ::clojureRT::protobuf::InvokeNode >(GetArenaForAllocation());
  }
  return _impl_.types_.invoke_;
}
inline ::clojureRT::protobuf::InvokeNode* Subnode::mutable_invoke() {
  ::clojureRT::protobuf::InvokeNode* _msg = _internal_mutable_invoke();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.Subnode.invoke)
  return _msg;
}

// .clojureRT.protobuf.KeywordInvokeNode keywordInvoke = 19;
inline bool Subnode::_internal_has_keywordinvoke() const {
  return types_case() == kKeywordInvoke;
}
inline bool Subnode::has_keywordinvoke() const {
  return _internal_has_keywordinvoke();
}
inline void Subnode::set_has_keywordinvoke() {
  _impl_._oneof_case_[0] = kKeywordInvoke;
}
inline void Subnode::clear_keywordinvoke() {
  if (_internal_has_keywordinvoke()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.types_.keywordinvoke_;
    }
    clear_has_types();
  }
}
inline ::clojureRT::protobuf::KeywordInvokeNode* Subnode::release_keywordinvoke() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.Subnode.keywordInvoke)
  if (_internal_has_keywordinvoke()) {
    clear_has_types();
    ::clojureRT::protobuf::KeywordInvokeNode* temp = _impl_.types_.keywordinvoke_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.types_.keywordinvoke_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clojureRT::protobuf::KeywordInvokeNode& Subnode::_internal_keywordinvoke() const {
  return _internal_has_keywordinvoke()
      ? *_impl_.types_.keywordinvoke_
      : reinterpret_cast< ::clojureRT::protobuf::KeywordInvokeNode&>(::clojureRT::protobuf::_KeywordInvokeNode_default_instance_);
}
inline const ::clojureRT::protobuf::KeywordInvokeNode& Subnode::keywordinvoke() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.Subnode.keywordInvoke)
  return _internal_keywordinvoke();
}
inline ::clojureRT::protobuf::KeywordInvokeNode* Subnode::unsafe_arena_release_keywordinvoke() {
  // @@protoc_insertion_point(field_unsafe_arena_release:clojureRT.protobuf.Subnode.keywordInvoke)
  if (_internal_has_keywordinvoke()) {
    clear_has_types();
    ::clojureRT::protobuf::KeywordInvokeNode* temp = _impl_.types_.keywordinvoke_;
    _impl_.types_.keywordinvoke_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Subnode::unsafe_arena_set_allocated_keywordinvoke(::clojureRT::protobuf::KeywordInvokeNode* keywordinvoke) {
  clear_types();
  if (keywordinvoke) {
    set_has_keywordinvoke();
    _impl_.types_.keywordinvoke_ = keywordinvoke;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.Subnode.keywordInvoke)
}
inline ::clojureRT::protobuf::KeywordInvokeNode* Subnode::_internal_mutable_keywordinvoke() {
  if (!_internal_has_keywordinvoke()) {
    clear_types();
    set_has_keywordinvoke();
    _impl_.types_.keywordinvoke_ = CreateMaybeMessage< ::clojureRT::protobuf::KeywordInvokeNode >(GetArenaForAllocation());
  }
  return _impl_.types_.keywordinvoke_;
}
inline ::clojureRT::protobuf::KeywordInvokeNode* Subnode::mutable_keywordinvoke() {
  ::clojureRT::protobuf::KeywordInvokeNode* _msg = _internal_mutable_keywordinvoke();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.Subnode.keywordInvoke)
  return _msg;
}

// .clojureRT.protobuf.LetNode let = 20;
inline bool Subnode::_internal_has_let() const {
  return types_case() == kLet;
}
inline bool Subnode::has_let() const {
  return _internal_has_let();
}
inline void Subnode::set_has_let() {
  _impl_._oneof_case_[0] = kLet;
}
inline void Subnode::clear_let() {
  if (_internal_has_let()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.types_.let_;
    }
    clear_has_types();
  }
}
inline ::clojureRT::protobuf::LetNode* Subnode::release_let() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.Subnode.let)
  if (_internal_has_let()) {
    clear_has_types();
    ::clojureRT::protobuf::LetNode* temp = _impl_.types_.let_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.types_.let_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clojureRT::protobuf::LetNode& Subnode::_internal_let() const {
  return _internal_has_let()
      ? *_impl_.types_.let_
      : reinterpret_cast< ::clojureRT::protobuf::LetNode&>(::clojureRT::protobuf::_LetNode_default_instance_);
}
inline const ::clojureRT::protobuf::LetNode& Subnode::let() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.Subnode.let)
  return _internal_let();
}
inline ::clojureRT::protobuf::LetNode* Subnode::unsafe_arena_release_let() {
  // @@protoc_insertion_point(field_unsafe_arena_release:clojureRT.protobuf.Subnode.let)
  if (_internal_has_let()) {
    clear_has_types();
    ::clojureRT::protobuf::LetNode* temp = _impl_.types_.let_;
    _impl_.types_.let_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Subnode::unsafe_arena_set_allocated_let(::clojureRT::protobuf::LetNode* let) {
  clear_types();
  if (let) {
    set_has_let();
    _impl_.types_.let_ = let;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.Subnode.let)
}
inline ::clojureRT::protobuf::LetNode* Subnode::_internal_mutable_let() {
  if (!_internal_has_let()) {
    clear_types();
    set_has_let();
    _impl_.types_.let_ = CreateMaybeMessage< ::clojureRT::protobuf::LetNode >(GetArenaForAllocation());
  }
  return _impl_.types_.let_;
}
inline ::clojureRT::protobuf::LetNode* Subnode::mutable_let() {
  ::clojureRT::protobuf::LetNode* _msg = _internal_mutable_let();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.Subnode.let)
  return _msg;
}

// .clojureRT.protobuf.LetfnNode letfn = 21;
inline bool Subnode::_internal_has_letfn() const {
  return types_case() == kLetfn;
}
inline bool Subnode::has_letfn() const {
  return _internal_has_letfn();
}
inline void Subnode::set_has_letfn() {
  _impl_._oneof_case_[0] = kLetfn;
}
inline void Subnode::clear_letfn() {
  if (_internal_has_letfn()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.types_.letfn_;
    }
    clear_has_types();
  }
}
inline ::clojureRT::protobuf::LetfnNode* Subnode::release_letfn() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.Subnode.letfn)
  if (_internal_has_letfn()) {
    clear_has_types();
    ::clojureRT::protobuf::LetfnNode* temp = _impl_.types_.letfn_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.types_.letfn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clojureRT::protobuf::LetfnNode& Subnode::_internal_letfn() const {
  return _internal_has_letfn()
      ? *_impl_.types_.letfn_
      : reinterpret_cast< ::clojureRT::protobuf::LetfnNode&>(::clojureRT::protobuf::_LetfnNode_default_instance_);
}
inline const ::clojureRT::protobuf::LetfnNode& Subnode::letfn() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.Subnode.letfn)
  return _internal_letfn();
}
inline ::clojureRT::protobuf::LetfnNode* Subnode::unsafe_arena_release_letfn() {
  // @@protoc_insertion_point(field_unsafe_arena_release:clojureRT.protobuf.Subnode.letfn)
  if (_internal_has_letfn()) {
    clear_has_types();
    ::clojureRT::protobuf::LetfnNode* temp = _impl_.types_.letfn_;
    _impl_.types_.letfn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Subnode::unsafe_arena_set_allocated_letfn(::clojureRT::protobuf::LetfnNode* letfn) {
  clear_types();
  if (letfn) {
    set_has_letfn();
    _impl_.types_.letfn_ = letfn;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.Subnode.letfn)
}
inline ::clojureRT::protobuf::LetfnNode* Subnode::_internal_mutable_letfn() {
  if (!_internal_has_letfn()) {
    clear_types();
    set_has_letfn();
    _impl_.types_.letfn_ = CreateMaybeMessage< ::clojureRT::protobuf::LetfnNode >(GetArenaForAllocation());
  }
  return _impl_.types_.letfn_;
}
inline ::clojureRT::protobuf::LetfnNode* Subnode::mutable_letfn() {
  ::clojureRT::protobuf::LetfnNode* _msg = _internal_mutable_letfn();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.Subnode.letfn)
  return _msg;
}

// .clojureRT.protobuf.LocalNode local = 22;
inline bool Subnode::_internal_has_local() const {
  return types_case() == kLocal;
}
inline bool Subnode::has_local() const {
  return _internal_has_local();
}
inline void Subnode::set_has_local() {
  _impl_._oneof_case_[0] = kLocal;
}
inline void Subnode::clear_local() {
  if (_internal_has_local()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.types_.local_;
    }
    clear_has_types();
  }
}
inline ::clojureRT::protobuf::LocalNode* Subnode::release_local() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.Subnode.local)
  if (_internal_has_local()) {
    clear_has_types();
    ::clojureRT::protobuf::LocalNode* temp = _impl_.types_.local_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.types_.local_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clojureRT::protobuf::LocalNode& Subnode::_internal_local() const {
  return _internal_has_local()
      ? *_impl_.types_.local_
      : reinterpret_cast< ::clojureRT::protobuf::LocalNode&>(::clojureRT::protobuf::_LocalNode_default_instance_);
}
inline const ::clojureRT::protobuf::LocalNode& Subnode::local() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.Subnode.local)
  return _internal_local();
}
inline ::clojureRT::protobuf::LocalNode* Subnode::unsafe_arena_release_local() {
  // @@protoc_insertion_point(field_unsafe_arena_release:clojureRT.protobuf.Subnode.local)
  if (_internal_has_local()) {
    clear_has_types();
    ::clojureRT::protobuf::LocalNode* temp = _impl_.types_.local_;
    _impl_.types_.local_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Subnode::unsafe_arena_set_allocated_local(::clojureRT::protobuf::LocalNode* local) {
  clear_types();
  if (local) {
    set_has_local();
    _impl_.types_.local_ = local;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.Subnode.local)
}
inline ::clojureRT::protobuf::LocalNode* Subnode::_internal_mutable_local() {
  if (!_internal_has_local()) {
    clear_types();
    set_has_local();
    _impl_.types_.local_ = CreateMaybeMessage< ::clojureRT::protobuf::LocalNode >(GetArenaForAllocation());
  }
  return _impl_.types_.local_;
}
inline ::clojureRT::protobuf::LocalNode* Subnode::mutable_local() {
  ::clojureRT::protobuf::LocalNode* _msg = _internal_mutable_local();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.Subnode.local)
  return _msg;
}

// .clojureRT.protobuf.LoopNode loop = 23;
inline bool Subnode::_internal_has_loop() const {
  return types_case() == kLoop;
}
inline bool Subnode::has_loop() const {
  return _internal_has_loop();
}
inline void Subnode::set_has_loop() {
  _impl_._oneof_case_[0] = kLoop;
}
inline void Subnode::clear_loop() {
  if (_internal_has_loop()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.types_.loop_;
    }
    clear_has_types();
  }
}
inline ::clojureRT::protobuf::LoopNode* Subnode::release_loop() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.Subnode.loop)
  if (_internal_has_loop()) {
    clear_has_types();
    ::clojureRT::protobuf::LoopNode* temp = _impl_.types_.loop_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.types_.loop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clojureRT::protobuf::LoopNode& Subnode::_internal_loop() const {
  return _internal_has_loop()
      ? *_impl_.types_.loop_
      : reinterpret_cast< ::clojureRT::protobuf::LoopNode&>(::clojureRT::protobuf::_LoopNode_default_instance_);
}
inline const ::clojureRT::protobuf::LoopNode& Subnode::loop() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.Subnode.loop)
  return _internal_loop();
}
inline ::clojureRT::protobuf::LoopNode* Subnode::unsafe_arena_release_loop() {
  // @@protoc_insertion_point(field_unsafe_arena_release:clojureRT.protobuf.Subnode.loop)
  if (_internal_has_loop()) {
    clear_has_types();
    ::clojureRT::protobuf::LoopNode* temp = _impl_.types_.loop_;
    _impl_.types_.loop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Subnode::unsafe_arena_set_allocated_loop(::clojureRT::protobuf::LoopNode* loop) {
  clear_types();
  if (loop) {
    set_has_loop();
    _impl_.types_.loop_ = loop;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.Subnode.loop)
}
inline ::clojureRT::protobuf::LoopNode* Subnode::_internal_mutable_loop() {
  if (!_internal_has_loop()) {
    clear_types();
    set_has_loop();
    _impl_.types_.loop_ = CreateMaybeMessage< ::clojureRT::protobuf::LoopNode >(GetArenaForAllocation());
  }
  return _impl_.types_.loop_;
}
inline ::clojureRT::protobuf::LoopNode* Subnode::mutable_loop() {
  ::clojureRT::protobuf::LoopNode* _msg = _internal_mutable_loop();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.Subnode.loop)
  return _msg;
}

// .clojureRT.protobuf.MapNode map = 24;
inline bool Subnode::_internal_has_map() const {
  return types_case() == kMap;
}
inline bool Subnode::has_map() const {
  return _internal_has_map();
}
inline void Subnode::set_has_map() {
  _impl_._oneof_case_[0] = kMap;
}
inline void Subnode::clear_map() {
  if (_internal_has_map()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.types_.map_;
    }
    clear_has_types();
  }
}
inline ::clojureRT::protobuf::MapNode* Subnode::release_map() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.Subnode.map)
  if (_internal_has_map()) {
    clear_has_types();
    ::clojureRT::protobuf::MapNode* temp = _impl_.types_.map_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.types_.map_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clojureRT::protobuf::MapNode& Subnode::_internal_map() const {
  return _internal_has_map()
      ? *_impl_.types_.map_
      : reinterpret_cast< ::clojureRT::protobuf::MapNode&>(::clojureRT::protobuf::_MapNode_default_instance_);
}
inline const ::clojureRT::protobuf::MapNode& Subnode::map() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.Subnode.map)
  return _internal_map();
}
inline ::clojureRT::protobuf::MapNode* Subnode::unsafe_arena_release_map() {
  // @@protoc_insertion_point(field_unsafe_arena_release:clojureRT.protobuf.Subnode.map)
  if (_internal_has_map()) {
    clear_has_types();
    ::clojureRT::protobuf::MapNode* temp = _impl_.types_.map_;
    _impl_.types_.map_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Subnode::unsafe_arena_set_allocated_map(::clojureRT::protobuf::MapNode* map) {
  clear_types();
  if (map) {
    set_has_map();
    _impl_.types_.map_ = map;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.Subnode.map)
}
inline ::clojureRT::protobuf::MapNode* Subnode::_internal_mutable_map() {
  if (!_internal_has_map()) {
    clear_types();
    set_has_map();
    _impl_.types_.map_ = CreateMaybeMessage< ::clojureRT::protobuf::MapNode >(GetArenaForAllocation());
  }
  return _impl_.types_.map_;
}
inline ::clojureRT::protobuf::MapNode* Subnode::mutable_map() {
  ::clojureRT::protobuf::MapNode* _msg = _internal_mutable_map();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.Subnode.map)
  return _msg;
}

// .clojureRT.protobuf.MethodNode method = 25;
inline bool Subnode::_internal_has_method() const {
  return types_case() == kMethod;
}
inline bool Subnode::has_method() const {
  return _internal_has_method();
}
inline void Subnode::set_has_method() {
  _impl_._oneof_case_[0] = kMethod;
}
inline void Subnode::clear_method() {
  if (_internal_has_method()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.types_.method_;
    }
    clear_has_types();
  }
}
inline ::clojureRT::protobuf::MethodNode* Subnode::release_method() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.Subnode.method)
  if (_internal_has_method()) {
    clear_has_types();
    ::clojureRT::protobuf::MethodNode* temp = _impl_.types_.method_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.types_.method_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clojureRT::protobuf::MethodNode& Subnode::_internal_method() const {
  return _internal_has_method()
      ? *_impl_.types_.method_
      : reinterpret_cast< ::clojureRT::protobuf::MethodNode&>(::clojureRT::protobuf::_MethodNode_default_instance_);
}
inline const ::clojureRT::protobuf::MethodNode& Subnode::method() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.Subnode.method)
  return _internal_method();
}
inline ::clojureRT::protobuf::MethodNode* Subnode::unsafe_arena_release_method() {
  // @@protoc_insertion_point(field_unsafe_arena_release:clojureRT.protobuf.Subnode.method)
  if (_internal_has_method()) {
    clear_has_types();
    ::clojureRT::protobuf::MethodNode* temp = _impl_.types_.method_;
    _impl_.types_.method_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Subnode::unsafe_arena_set_allocated_method(::clojureRT::protobuf::MethodNode* method) {
  clear_types();
  if (method) {
    set_has_method();
    _impl_.types_.method_ = method;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.Subnode.method)
}
inline ::clojureRT::protobuf::MethodNode* Subnode::_internal_mutable_method() {
  if (!_internal_has_method()) {
    clear_types();
    set_has_method();
    _impl_.types_.method_ = CreateMaybeMessage< ::clojureRT::protobuf::MethodNode >(GetArenaForAllocation());
  }
  return _impl_.types_.method_;
}
inline ::clojureRT::protobuf::MethodNode* Subnode::mutable_method() {
  ::clojureRT::protobuf::MethodNode* _msg = _internal_mutable_method();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.Subnode.method)
  return _msg;
}

// .clojureRT.protobuf.MonitorEnterNode monitorEnter = 26;
inline bool Subnode::_internal_has_monitorenter() const {
  return types_case() == kMonitorEnter;
}
inline bool Subnode::has_monitorenter() const {
  return _internal_has_monitorenter();
}
inline void Subnode::set_has_monitorenter() {
  _impl_._oneof_case_[0] = kMonitorEnter;
}
inline void Subnode::clear_monitorenter() {
  if (_internal_has_monitorenter()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.types_.monitorenter_;
    }
    clear_has_types();
  }
}
inline ::clojureRT::protobuf::MonitorEnterNode* Subnode::release_monitorenter() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.Subnode.monitorEnter)
  if (_internal_has_monitorenter()) {
    clear_has_types();
    ::clojureRT::protobuf::MonitorEnterNode* temp = _impl_.types_.monitorenter_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.types_.monitorenter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clojureRT::protobuf::MonitorEnterNode& Subnode::_internal_monitorenter() const {
  return _internal_has_monitorenter()
      ? *_impl_.types_.monitorenter_
      : reinterpret_cast< ::clojureRT::protobuf::MonitorEnterNode&>(::clojureRT::protobuf::_MonitorEnterNode_default_instance_);
}
inline const ::clojureRT::protobuf::MonitorEnterNode& Subnode::monitorenter() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.Subnode.monitorEnter)
  return _internal_monitorenter();
}
inline ::clojureRT::protobuf::MonitorEnterNode* Subnode::unsafe_arena_release_monitorenter() {
  // @@protoc_insertion_point(field_unsafe_arena_release:clojureRT.protobuf.Subnode.monitorEnter)
  if (_internal_has_monitorenter()) {
    clear_has_types();
    ::clojureRT::protobuf::MonitorEnterNode* temp = _impl_.types_.monitorenter_;
    _impl_.types_.monitorenter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Subnode::unsafe_arena_set_allocated_monitorenter(::clojureRT::protobuf::MonitorEnterNode* monitorenter) {
  clear_types();
  if (monitorenter) {
    set_has_monitorenter();
    _impl_.types_.monitorenter_ = monitorenter;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.Subnode.monitorEnter)
}
inline ::clojureRT::protobuf::MonitorEnterNode* Subnode::_internal_mutable_monitorenter() {
  if (!_internal_has_monitorenter()) {
    clear_types();
    set_has_monitorenter();
    _impl_.types_.monitorenter_ = CreateMaybeMessage< ::clojureRT::protobuf::MonitorEnterNode >(GetArenaForAllocation());
  }
  return _impl_.types_.monitorenter_;
}
inline ::clojureRT::protobuf::MonitorEnterNode* Subnode::mutable_monitorenter() {
  ::clojureRT::protobuf::MonitorEnterNode* _msg = _internal_mutable_monitorenter();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.Subnode.monitorEnter)
  return _msg;
}

// .clojureRT.protobuf.MonitorExitNode monitorExit = 27;
inline bool Subnode::_internal_has_monitorexit() const {
  return types_case() == kMonitorExit;
}
inline bool Subnode::has_monitorexit() const {
  return _internal_has_monitorexit();
}
inline void Subnode::set_has_monitorexit() {
  _impl_._oneof_case_[0] = kMonitorExit;
}
inline void Subnode::clear_monitorexit() {
  if (_internal_has_monitorexit()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.types_.monitorexit_;
    }
    clear_has_types();
  }
}
inline ::clojureRT::protobuf::MonitorExitNode* Subnode::release_monitorexit() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.Subnode.monitorExit)
  if (_internal_has_monitorexit()) {
    clear_has_types();
    ::clojureRT::protobuf::MonitorExitNode* temp = _impl_.types_.monitorexit_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.types_.monitorexit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clojureRT::protobuf::MonitorExitNode& Subnode::_internal_monitorexit() const {
  return _internal_has_monitorexit()
      ? *_impl_.types_.monitorexit_
      : reinterpret_cast< ::clojureRT::protobuf::MonitorExitNode&>(::clojureRT::protobuf::_MonitorExitNode_default_instance_);
}
inline const ::clojureRT::protobuf::MonitorExitNode& Subnode::monitorexit() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.Subnode.monitorExit)
  return _internal_monitorexit();
}
inline ::clojureRT::protobuf::MonitorExitNode* Subnode::unsafe_arena_release_monitorexit() {
  // @@protoc_insertion_point(field_unsafe_arena_release:clojureRT.protobuf.Subnode.monitorExit)
  if (_internal_has_monitorexit()) {
    clear_has_types();
    ::clojureRT::protobuf::MonitorExitNode* temp = _impl_.types_.monitorexit_;
    _impl_.types_.monitorexit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Subnode::unsafe_arena_set_allocated_monitorexit(::clojureRT::protobuf::MonitorExitNode* monitorexit) {
  clear_types();
  if (monitorexit) {
    set_has_monitorexit();
    _impl_.types_.monitorexit_ = monitorexit;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.Subnode.monitorExit)
}
inline ::clojureRT::protobuf::MonitorExitNode* Subnode::_internal_mutable_monitorexit() {
  if (!_internal_has_monitorexit()) {
    clear_types();
    set_has_monitorexit();
    _impl_.types_.monitorexit_ = CreateMaybeMessage< ::clojureRT::protobuf::MonitorExitNode >(GetArenaForAllocation());
  }
  return _impl_.types_.monitorexit_;
}
inline ::clojureRT::protobuf::MonitorExitNode* Subnode::mutable_monitorexit() {
  ::clojureRT::protobuf::MonitorExitNode* _msg = _internal_mutable_monitorexit();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.Subnode.monitorExit)
  return _msg;
}

// .clojureRT.protobuf.NewNode new = 28;
inline bool Subnode::_internal_has_new_() const {
  return types_case() == kNew;
}
inline bool Subnode::has_new_() const {
  return _internal_has_new_();
}
inline void Subnode::set_has_new_() {
  _impl_._oneof_case_[0] = kNew;
}
inline void Subnode::clear_new_() {
  if (_internal_has_new_()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.types_.new__;
    }
    clear_has_types();
  }
}
inline ::clojureRT::protobuf::NewNode* Subnode::release_new_() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.Subnode.new)
  if (_internal_has_new_()) {
    clear_has_types();
    ::clojureRT::protobuf::NewNode* temp = _impl_.types_.new__;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.types_.new__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clojureRT::protobuf::NewNode& Subnode::_internal_new_() const {
  return _internal_has_new_()
      ? *_impl_.types_.new__
      : reinterpret_cast< ::clojureRT::protobuf::NewNode&>(::clojureRT::protobuf::_NewNode_default_instance_);
}
inline const ::clojureRT::protobuf::NewNode& Subnode::new_() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.Subnode.new)
  return _internal_new_();
}
inline ::clojureRT::protobuf::NewNode* Subnode::unsafe_arena_release_new_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:clojureRT.protobuf.Subnode.new)
  if (_internal_has_new_()) {
    clear_has_types();
    ::clojureRT::protobuf::NewNode* temp = _impl_.types_.new__;
    _impl_.types_.new__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Subnode::unsafe_arena_set_allocated_new_(::clojureRT::protobuf::NewNode* new_) {
  clear_types();
  if (new_) {
    set_has_new_();
    _impl_.types_.new__ = new_;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.Subnode.new)
}
inline ::clojureRT::protobuf::NewNode* Subnode::_internal_mutable_new_() {
  if (!_internal_has_new_()) {
    clear_types();
    set_has_new_();
    _impl_.types_.new__ = CreateMaybeMessage< ::clojureRT::protobuf::NewNode >(GetArenaForAllocation());
  }
  return _impl_.types_.new__;
}
inline ::clojureRT::protobuf::NewNode* Subnode::mutable_new_() {
  ::clojureRT::protobuf::NewNode* _msg = _internal_mutable_new_();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.Subnode.new)
  return _msg;
}

// .clojureRT.protobuf.PrimInvokeNode primInvoke = 29;
inline bool Subnode::_internal_has_priminvoke() const {
  return types_case() == kPrimInvoke;
}
inline bool Subnode::has_priminvoke() const {
  return _internal_has_priminvoke();
}
inline void Subnode::set_has_priminvoke() {
  _impl_._oneof_case_[0] = kPrimInvoke;
}
inline void Subnode::clear_priminvoke() {
  if (_internal_has_priminvoke()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.types_.priminvoke_;
    }
    clear_has_types();
  }
}
inline ::clojureRT::protobuf::PrimInvokeNode* Subnode::release_priminvoke() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.Subnode.primInvoke)
  if (_internal_has_priminvoke()) {
    clear_has_types();
    ::clojureRT::protobuf::PrimInvokeNode* temp = _impl_.types_.priminvoke_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.types_.priminvoke_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clojureRT::protobuf::PrimInvokeNode& Subnode::_internal_priminvoke() const {
  return _internal_has_priminvoke()
      ? *_impl_.types_.priminvoke_
      : reinterpret_cast< ::clojureRT::protobuf::PrimInvokeNode&>(::clojureRT::protobuf::_PrimInvokeNode_default_instance_);
}
inline const ::clojureRT::protobuf::PrimInvokeNode& Subnode::priminvoke() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.Subnode.primInvoke)
  return _internal_priminvoke();
}
inline ::clojureRT::protobuf::PrimInvokeNode* Subnode::unsafe_arena_release_priminvoke() {
  // @@protoc_insertion_point(field_unsafe_arena_release:clojureRT.protobuf.Subnode.primInvoke)
  if (_internal_has_priminvoke()) {
    clear_has_types();
    ::clojureRT::protobuf::PrimInvokeNode* temp = _impl_.types_.priminvoke_;
    _impl_.types_.priminvoke_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Subnode::unsafe_arena_set_allocated_priminvoke(::clojureRT::protobuf::PrimInvokeNode* priminvoke) {
  clear_types();
  if (priminvoke) {
    set_has_priminvoke();
    _impl_.types_.priminvoke_ = priminvoke;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.Subnode.primInvoke)
}
inline ::clojureRT::protobuf::PrimInvokeNode* Subnode::_internal_mutable_priminvoke() {
  if (!_internal_has_priminvoke()) {
    clear_types();
    set_has_priminvoke();
    _impl_.types_.priminvoke_ = CreateMaybeMessage< ::clojureRT::protobuf::PrimInvokeNode >(GetArenaForAllocation());
  }
  return _impl_.types_.priminvoke_;
}
inline ::clojureRT::protobuf::PrimInvokeNode* Subnode::mutable_priminvoke() {
  ::clojureRT::protobuf::PrimInvokeNode* _msg = _internal_mutable_priminvoke();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.Subnode.primInvoke)
  return _msg;
}

// .clojureRT.protobuf.ProtocolInvokeNode protocolInvoke = 30;
inline bool Subnode::_internal_has_protocolinvoke() const {
  return types_case() == kProtocolInvoke;
}
inline bool Subnode::has_protocolinvoke() const {
  return _internal_has_protocolinvoke();
}
inline void Subnode::set_has_protocolinvoke() {
  _impl_._oneof_case_[0] = kProtocolInvoke;
}
inline void Subnode::clear_protocolinvoke() {
  if (_internal_has_protocolinvoke()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.types_.protocolinvoke_;
    }
    clear_has_types();
  }
}
inline ::clojureRT::protobuf::ProtocolInvokeNode* Subnode::release_protocolinvoke() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.Subnode.protocolInvoke)
  if (_internal_has_protocolinvoke()) {
    clear_has_types();
    ::clojureRT::protobuf::ProtocolInvokeNode* temp = _impl_.types_.protocolinvoke_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.types_.protocolinvoke_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clojureRT::protobuf::ProtocolInvokeNode& Subnode::_internal_protocolinvoke() const {
  return _internal_has_protocolinvoke()
      ? *_impl_.types_.protocolinvoke_
      : reinterpret_cast< ::clojureRT::protobuf::ProtocolInvokeNode&>(::clojureRT::protobuf::_ProtocolInvokeNode_default_instance_);
}
inline const ::clojureRT::protobuf::ProtocolInvokeNode& Subnode::protocolinvoke() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.Subnode.protocolInvoke)
  return _internal_protocolinvoke();
}
inline ::clojureRT::protobuf::ProtocolInvokeNode* Subnode::unsafe_arena_release_protocolinvoke() {
  // @@protoc_insertion_point(field_unsafe_arena_release:clojureRT.protobuf.Subnode.protocolInvoke)
  if (_internal_has_protocolinvoke()) {
    clear_has_types();
    ::clojureRT::protobuf::ProtocolInvokeNode* temp = _impl_.types_.protocolinvoke_;
    _impl_.types_.protocolinvoke_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Subnode::unsafe_arena_set_allocated_protocolinvoke(::clojureRT::protobuf::ProtocolInvokeNode* protocolinvoke) {
  clear_types();
  if (protocolinvoke) {
    set_has_protocolinvoke();
    _impl_.types_.protocolinvoke_ = protocolinvoke;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.Subnode.protocolInvoke)
}
inline ::clojureRT::protobuf::ProtocolInvokeNode* Subnode::_internal_mutable_protocolinvoke() {
  if (!_internal_has_protocolinvoke()) {
    clear_types();
    set_has_protocolinvoke();
    _impl_.types_.protocolinvoke_ = CreateMaybeMessage< ::clojureRT::protobuf::ProtocolInvokeNode >(GetArenaForAllocation());
  }
  return _impl_.types_.protocolinvoke_;
}
inline ::clojureRT::protobuf::ProtocolInvokeNode* Subnode::mutable_protocolinvoke() {
  ::clojureRT::protobuf::ProtocolInvokeNode* _msg = _internal_mutable_protocolinvoke();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.Subnode.protocolInvoke)
  return _msg;
}

// .clojureRT.protobuf.QuoteNode quote = 31;
inline bool Subnode::_internal_has_quote() const {
  return types_case() == kQuote;
}
inline bool Subnode::has_quote() const {
  return _internal_has_quote();
}
inline void Subnode::set_has_quote() {
  _impl_._oneof_case_[0] = kQuote;
}
inline void Subnode::clear_quote() {
  if (_internal_has_quote()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.types_.quote_;
    }
    clear_has_types();
  }
}
inline ::clojureRT::protobuf::QuoteNode* Subnode::release_quote() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.Subnode.quote)
  if (_internal_has_quote()) {
    clear_has_types();
    ::clojureRT::protobuf::QuoteNode* temp = _impl_.types_.quote_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.types_.quote_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clojureRT::protobuf::QuoteNode& Subnode::_internal_quote() const {
  return _internal_has_quote()
      ? *_impl_.types_.quote_
      : reinterpret_cast< ::clojureRT::protobuf::QuoteNode&>(::clojureRT::protobuf::_QuoteNode_default_instance_);
}
inline const ::clojureRT::protobuf::QuoteNode& Subnode::quote() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.Subnode.quote)
  return _internal_quote();
}
inline ::clojureRT::protobuf::QuoteNode* Subnode::unsafe_arena_release_quote() {
  // @@protoc_insertion_point(field_unsafe_arena_release:clojureRT.protobuf.Subnode.quote)
  if (_internal_has_quote()) {
    clear_has_types();
    ::clojureRT::protobuf::QuoteNode* temp = _impl_.types_.quote_;
    _impl_.types_.quote_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Subnode::unsafe_arena_set_allocated_quote(::clojureRT::protobuf::QuoteNode* quote) {
  clear_types();
  if (quote) {
    set_has_quote();
    _impl_.types_.quote_ = quote;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.Subnode.quote)
}
inline ::clojureRT::protobuf::QuoteNode* Subnode::_internal_mutable_quote() {
  if (!_internal_has_quote()) {
    clear_types();
    set_has_quote();
    _impl_.types_.quote_ = CreateMaybeMessage< ::clojureRT::protobuf::QuoteNode >(GetArenaForAllocation());
  }
  return _impl_.types_.quote_;
}
inline ::clojureRT::protobuf::QuoteNode* Subnode::mutable_quote() {
  ::clojureRT::protobuf::QuoteNode* _msg = _internal_mutable_quote();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.Subnode.quote)
  return _msg;
}

// .clojureRT.protobuf.RecurNode recur = 32;
inline bool Subnode::_internal_has_recur() const {
  return types_case() == kRecur;
}
inline bool Subnode::has_recur() const {
  return _internal_has_recur();
}
inline void Subnode::set_has_recur() {
  _impl_._oneof_case_[0] = kRecur;
}
inline void Subnode::clear_recur() {
  if (_internal_has_recur()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.types_.recur_;
    }
    clear_has_types();
  }
}
inline ::clojureRT::protobuf::RecurNode* Subnode::release_recur() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.Subnode.recur)
  if (_internal_has_recur()) {
    clear_has_types();
    ::clojureRT::protobuf::RecurNode* temp = _impl_.types_.recur_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.types_.recur_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clojureRT::protobuf::RecurNode& Subnode::_internal_recur() const {
  return _internal_has_recur()
      ? *_impl_.types_.recur_
      : reinterpret_cast< ::clojureRT::protobuf::RecurNode&>(::clojureRT::protobuf::_RecurNode_default_instance_);
}
inline const ::clojureRT::protobuf::RecurNode& Subnode::recur() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.Subnode.recur)
  return _internal_recur();
}
inline ::clojureRT::protobuf::RecurNode* Subnode::unsafe_arena_release_recur() {
  // @@protoc_insertion_point(field_unsafe_arena_release:clojureRT.protobuf.Subnode.recur)
  if (_internal_has_recur()) {
    clear_has_types();
    ::clojureRT::protobuf::RecurNode* temp = _impl_.types_.recur_;
    _impl_.types_.recur_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Subnode::unsafe_arena_set_allocated_recur(::clojureRT::protobuf::RecurNode* recur) {
  clear_types();
  if (recur) {
    set_has_recur();
    _impl_.types_.recur_ = recur;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.Subnode.recur)
}
inline ::clojureRT::protobuf::RecurNode* Subnode::_internal_mutable_recur() {
  if (!_internal_has_recur()) {
    clear_types();
    set_has_recur();
    _impl_.types_.recur_ = CreateMaybeMessage< ::clojureRT::protobuf::RecurNode >(GetArenaForAllocation());
  }
  return _impl_.types_.recur_;
}
inline ::clojureRT::protobuf::RecurNode* Subnode::mutable_recur() {
  ::clojureRT::protobuf::RecurNode* _msg = _internal_mutable_recur();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.Subnode.recur)
  return _msg;
}

// .clojureRT.protobuf.ReifyNode reify = 33;
inline bool Subnode::_internal_has_reify() const {
  return types_case() == kReify;
}
inline bool Subnode::has_reify() const {
  return _internal_has_reify();
}
inline void Subnode::set_has_reify() {
  _impl_._oneof_case_[0] = kReify;
}
inline void Subnode::clear_reify() {
  if (_internal_has_reify()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.types_.reify_;
    }
    clear_has_types();
  }
}
inline ::clojureRT::protobuf::ReifyNode* Subnode::release_reify() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.Subnode.reify)
  if (_internal_has_reify()) {
    clear_has_types();
    ::clojureRT::protobuf::ReifyNode* temp = _impl_.types_.reify_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.types_.reify_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clojureRT::protobuf::ReifyNode& Subnode::_internal_reify() const {
  return _internal_has_reify()
      ? *_impl_.types_.reify_
      : reinterpret_cast< ::clojureRT::protobuf::ReifyNode&>(::clojureRT::protobuf::_ReifyNode_default_instance_);
}
inline const ::clojureRT::protobuf::ReifyNode& Subnode::reify() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.Subnode.reify)
  return _internal_reify();
}
inline ::clojureRT::protobuf::ReifyNode* Subnode::unsafe_arena_release_reify() {
  // @@protoc_insertion_point(field_unsafe_arena_release:clojureRT.protobuf.Subnode.reify)
  if (_internal_has_reify()) {
    clear_has_types();
    ::clojureRT::protobuf::ReifyNode* temp = _impl_.types_.reify_;
    _impl_.types_.reify_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Subnode::unsafe_arena_set_allocated_reify(::clojureRT::protobuf::ReifyNode* reify) {
  clear_types();
  if (reify) {
    set_has_reify();
    _impl_.types_.reify_ = reify;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.Subnode.reify)
}
inline ::clojureRT::protobuf::ReifyNode* Subnode::_internal_mutable_reify() {
  if (!_internal_has_reify()) {
    clear_types();
    set_has_reify();
    _impl_.types_.reify_ = CreateMaybeMessage< ::clojureRT::protobuf::ReifyNode >(GetArenaForAllocation());
  }
  return _impl_.types_.reify_;
}
inline ::clojureRT::protobuf::ReifyNode* Subnode::mutable_reify() {
  ::clojureRT::protobuf::ReifyNode* _msg = _internal_mutable_reify();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.Subnode.reify)
  return _msg;
}

// .clojureRT.protobuf.SetNode set = 34;
inline bool Subnode::_internal_has_set() const {
  return types_case() == kSet;
}
inline bool Subnode::has_set() const {
  return _internal_has_set();
}
inline void Subnode::set_has_set() {
  _impl_._oneof_case_[0] = kSet;
}
inline void Subnode::clear_set() {
  if (_internal_has_set()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.types_.set_;
    }
    clear_has_types();
  }
}
inline ::clojureRT::protobuf::SetNode* Subnode::release_set() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.Subnode.set)
  if (_internal_has_set()) {
    clear_has_types();
    ::clojureRT::protobuf::SetNode* temp = _impl_.types_.set_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.types_.set_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clojureRT::protobuf::SetNode& Subnode::_internal_set() const {
  return _internal_has_set()
      ? *_impl_.types_.set_
      : reinterpret_cast< ::clojureRT::protobuf::SetNode&>(::clojureRT::protobuf::_SetNode_default_instance_);
}
inline const ::clojureRT::protobuf::SetNode& Subnode::set() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.Subnode.set)
  return _internal_set();
}
inline ::clojureRT::protobuf::SetNode* Subnode::unsafe_arena_release_set() {
  // @@protoc_insertion_point(field_unsafe_arena_release:clojureRT.protobuf.Subnode.set)
  if (_internal_has_set()) {
    clear_has_types();
    ::clojureRT::protobuf::SetNode* temp = _impl_.types_.set_;
    _impl_.types_.set_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Subnode::unsafe_arena_set_allocated_set(::clojureRT::protobuf::SetNode* set) {
  clear_types();
  if (set) {
    set_has_set();
    _impl_.types_.set_ = set;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.Subnode.set)
}
inline ::clojureRT::protobuf::SetNode* Subnode::_internal_mutable_set() {
  if (!_internal_has_set()) {
    clear_types();
    set_has_set();
    _impl_.types_.set_ = CreateMaybeMessage< ::clojureRT::protobuf::SetNode >(GetArenaForAllocation());
  }
  return _impl_.types_.set_;
}
inline ::clojureRT::protobuf::SetNode* Subnode::mutable_set() {
  ::clojureRT::protobuf::SetNode* _msg = _internal_mutable_set();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.Subnode.set)
  return _msg;
}

// .clojureRT.protobuf.MutateSetNode mutateSet = 35;
inline bool Subnode::_internal_has_mutateset() const {
  return types_case() == kMutateSet;
}
inline bool Subnode::has_mutateset() const {
  return _internal_has_mutateset();
}
inline void Subnode::set_has_mutateset() {
  _impl_._oneof_case_[0] = kMutateSet;
}
inline void Subnode::clear_mutateset() {
  if (_internal_has_mutateset()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.types_.mutateset_;
    }
    clear_has_types();
  }
}
inline ::clojureRT::protobuf::MutateSetNode* Subnode::release_mutateset() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.Subnode.mutateSet)
  if (_internal_has_mutateset()) {
    clear_has_types();
    ::clojureRT::protobuf::MutateSetNode* temp = _impl_.types_.mutateset_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.types_.mutateset_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clojureRT::protobuf::MutateSetNode& Subnode::_internal_mutateset() const {
  return _internal_has_mutateset()
      ? *_impl_.types_.mutateset_
      : reinterpret_cast< ::clojureRT::protobuf::MutateSetNode&>(::clojureRT::protobuf::_MutateSetNode_default_instance_);
}
inline const ::clojureRT::protobuf::MutateSetNode& Subnode::mutateset() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.Subnode.mutateSet)
  return _internal_mutateset();
}
inline ::clojureRT::protobuf::MutateSetNode* Subnode::unsafe_arena_release_mutateset() {
  // @@protoc_insertion_point(field_unsafe_arena_release:clojureRT.protobuf.Subnode.mutateSet)
  if (_internal_has_mutateset()) {
    clear_has_types();
    ::clojureRT::protobuf::MutateSetNode* temp = _impl_.types_.mutateset_;
    _impl_.types_.mutateset_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Subnode::unsafe_arena_set_allocated_mutateset(::clojureRT::protobuf::MutateSetNode* mutateset) {
  clear_types();
  if (mutateset) {
    set_has_mutateset();
    _impl_.types_.mutateset_ = mutateset;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.Subnode.mutateSet)
}
inline ::clojureRT::protobuf::MutateSetNode* Subnode::_internal_mutable_mutateset() {
  if (!_internal_has_mutateset()) {
    clear_types();
    set_has_mutateset();
    _impl_.types_.mutateset_ = CreateMaybeMessage< ::clojureRT::protobuf::MutateSetNode >(GetArenaForAllocation());
  }
  return _impl_.types_.mutateset_;
}
inline ::clojureRT::protobuf::MutateSetNode* Subnode::mutable_mutateset() {
  ::clojureRT::protobuf::MutateSetNode* _msg = _internal_mutable_mutateset();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.Subnode.mutateSet)
  return _msg;
}

// .clojureRT.protobuf.StaticCallNode staticCall = 36;
inline bool Subnode::_internal_has_staticcall() const {
  return types_case() == kStaticCall;
}
inline bool Subnode::has_staticcall() const {
  return _internal_has_staticcall();
}
inline void Subnode::set_has_staticcall() {
  _impl_._oneof_case_[0] = kStaticCall;
}
inline void Subnode::clear_staticcall() {
  if (_internal_has_staticcall()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.types_.staticcall_;
    }
    clear_has_types();
  }
}
inline ::clojureRT::protobuf::StaticCallNode* Subnode::release_staticcall() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.Subnode.staticCall)
  if (_internal_has_staticcall()) {
    clear_has_types();
    ::clojureRT::protobuf::StaticCallNode* temp = _impl_.types_.staticcall_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.types_.staticcall_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clojureRT::protobuf::StaticCallNode& Subnode::_internal_staticcall() const {
  return _internal_has_staticcall()
      ? *_impl_.types_.staticcall_
      : reinterpret_cast< ::clojureRT::protobuf::StaticCallNode&>(::clojureRT::protobuf::_StaticCallNode_default_instance_);
}
inline const ::clojureRT::protobuf::StaticCallNode& Subnode::staticcall() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.Subnode.staticCall)
  return _internal_staticcall();
}
inline ::clojureRT::protobuf::StaticCallNode* Subnode::unsafe_arena_release_staticcall() {
  // @@protoc_insertion_point(field_unsafe_arena_release:clojureRT.protobuf.Subnode.staticCall)
  if (_internal_has_staticcall()) {
    clear_has_types();
    ::clojureRT::protobuf::StaticCallNode* temp = _impl_.types_.staticcall_;
    _impl_.types_.staticcall_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Subnode::unsafe_arena_set_allocated_staticcall(::clojureRT::protobuf::StaticCallNode* staticcall) {
  clear_types();
  if (staticcall) {
    set_has_staticcall();
    _impl_.types_.staticcall_ = staticcall;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.Subnode.staticCall)
}
inline ::clojureRT::protobuf::StaticCallNode* Subnode::_internal_mutable_staticcall() {
  if (!_internal_has_staticcall()) {
    clear_types();
    set_has_staticcall();
    _impl_.types_.staticcall_ = CreateMaybeMessage< ::clojureRT::protobuf::StaticCallNode >(GetArenaForAllocation());
  }
  return _impl_.types_.staticcall_;
}
inline ::clojureRT::protobuf::StaticCallNode* Subnode::mutable_staticcall() {
  ::clojureRT::protobuf::StaticCallNode* _msg = _internal_mutable_staticcall();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.Subnode.staticCall)
  return _msg;
}

// .clojureRT.protobuf.StaticFieldNode staticField = 37;
inline bool Subnode::_internal_has_staticfield() const {
  return types_case() == kStaticField;
}
inline bool Subnode::has_staticfield() const {
  return _internal_has_staticfield();
}
inline void Subnode::set_has_staticfield() {
  _impl_._oneof_case_[0] = kStaticField;
}
inline void Subnode::clear_staticfield() {
  if (_internal_has_staticfield()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.types_.staticfield_;
    }
    clear_has_types();
  }
}
inline ::clojureRT::protobuf::StaticFieldNode* Subnode::release_staticfield() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.Subnode.staticField)
  if (_internal_has_staticfield()) {
    clear_has_types();
    ::clojureRT::protobuf::StaticFieldNode* temp = _impl_.types_.staticfield_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.types_.staticfield_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clojureRT::protobuf::StaticFieldNode& Subnode::_internal_staticfield() const {
  return _internal_has_staticfield()
      ? *_impl_.types_.staticfield_
      : reinterpret_cast< ::clojureRT::protobuf::StaticFieldNode&>(::clojureRT::protobuf::_StaticFieldNode_default_instance_);
}
inline const ::clojureRT::protobuf::StaticFieldNode& Subnode::staticfield() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.Subnode.staticField)
  return _internal_staticfield();
}
inline ::clojureRT::protobuf::StaticFieldNode* Subnode::unsafe_arena_release_staticfield() {
  // @@protoc_insertion_point(field_unsafe_arena_release:clojureRT.protobuf.Subnode.staticField)
  if (_internal_has_staticfield()) {
    clear_has_types();
    ::clojureRT::protobuf::StaticFieldNode* temp = _impl_.types_.staticfield_;
    _impl_.types_.staticfield_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Subnode::unsafe_arena_set_allocated_staticfield(::clojureRT::protobuf::StaticFieldNode* staticfield) {
  clear_types();
  if (staticfield) {
    set_has_staticfield();
    _impl_.types_.staticfield_ = staticfield;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.Subnode.staticField)
}
inline ::clojureRT::protobuf::StaticFieldNode* Subnode::_internal_mutable_staticfield() {
  if (!_internal_has_staticfield()) {
    clear_types();
    set_has_staticfield();
    _impl_.types_.staticfield_ = CreateMaybeMessage< ::clojureRT::protobuf::StaticFieldNode >(GetArenaForAllocation());
  }
  return _impl_.types_.staticfield_;
}
inline ::clojureRT::protobuf::StaticFieldNode* Subnode::mutable_staticfield() {
  ::clojureRT::protobuf::StaticFieldNode* _msg = _internal_mutable_staticfield();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.Subnode.staticField)
  return _msg;
}

// .clojureRT.protobuf.TheVarNode theVar = 38;
inline bool Subnode::_internal_has_thevar() const {
  return types_case() == kTheVar;
}
inline bool Subnode::has_thevar() const {
  return _internal_has_thevar();
}
inline void Subnode::set_has_thevar() {
  _impl_._oneof_case_[0] = kTheVar;
}
inline void Subnode::clear_thevar() {
  if (_internal_has_thevar()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.types_.thevar_;
    }
    clear_has_types();
  }
}
inline ::clojureRT::protobuf::TheVarNode* Subnode::release_thevar() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.Subnode.theVar)
  if (_internal_has_thevar()) {
    clear_has_types();
    ::clojureRT::protobuf::TheVarNode* temp = _impl_.types_.thevar_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.types_.thevar_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clojureRT::protobuf::TheVarNode& Subnode::_internal_thevar() const {
  return _internal_has_thevar()
      ? *_impl_.types_.thevar_
      : reinterpret_cast< ::clojureRT::protobuf::TheVarNode&>(::clojureRT::protobuf::_TheVarNode_default_instance_);
}
inline const ::clojureRT::protobuf::TheVarNode& Subnode::thevar() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.Subnode.theVar)
  return _internal_thevar();
}
inline ::clojureRT::protobuf::TheVarNode* Subnode::unsafe_arena_release_thevar() {
  // @@protoc_insertion_point(field_unsafe_arena_release:clojureRT.protobuf.Subnode.theVar)
  if (_internal_has_thevar()) {
    clear_has_types();
    ::clojureRT::protobuf::TheVarNode* temp = _impl_.types_.thevar_;
    _impl_.types_.thevar_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Subnode::unsafe_arena_set_allocated_thevar(::clojureRT::protobuf::TheVarNode* thevar) {
  clear_types();
  if (thevar) {
    set_has_thevar();
    _impl_.types_.thevar_ = thevar;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.Subnode.theVar)
}
inline ::clojureRT::protobuf::TheVarNode* Subnode::_internal_mutable_thevar() {
  if (!_internal_has_thevar()) {
    clear_types();
    set_has_thevar();
    _impl_.types_.thevar_ = CreateMaybeMessage< ::clojureRT::protobuf::TheVarNode >(GetArenaForAllocation());
  }
  return _impl_.types_.thevar_;
}
inline ::clojureRT::protobuf::TheVarNode* Subnode::mutable_thevar() {
  ::clojureRT::protobuf::TheVarNode* _msg = _internal_mutable_thevar();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.Subnode.theVar)
  return _msg;
}

// .clojureRT.protobuf.ThrowNode throw = 39;
inline bool Subnode::_internal_has_throw_() const {
  return types_case() == kThrow;
}
inline bool Subnode::has_throw_() const {
  return _internal_has_throw_();
}
inline void Subnode::set_has_throw_() {
  _impl_._oneof_case_[0] = kThrow;
}
inline void Subnode::clear_throw_() {
  if (_internal_has_throw_()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.types_.throw__;
    }
    clear_has_types();
  }
}
inline ::clojureRT::protobuf::ThrowNode* Subnode::release_throw_() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.Subnode.throw)
  if (_internal_has_throw_()) {
    clear_has_types();
    ::clojureRT::protobuf::ThrowNode* temp = _impl_.types_.throw__;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.types_.throw__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clojureRT::protobuf::ThrowNode& Subnode::_internal_throw_() const {
  return _internal_has_throw_()
      ? *_impl_.types_.throw__
      : reinterpret_cast< ::clojureRT::protobuf::ThrowNode&>(::clojureRT::protobuf::_ThrowNode_default_instance_);
}
inline const ::clojureRT::protobuf::ThrowNode& Subnode::throw_() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.Subnode.throw)
  return _internal_throw_();
}
inline ::clojureRT::protobuf::ThrowNode* Subnode::unsafe_arena_release_throw_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:clojureRT.protobuf.Subnode.throw)
  if (_internal_has_throw_()) {
    clear_has_types();
    ::clojureRT::protobuf::ThrowNode* temp = _impl_.types_.throw__;
    _impl_.types_.throw__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Subnode::unsafe_arena_set_allocated_throw_(::clojureRT::protobuf::ThrowNode* throw_) {
  clear_types();
  if (throw_) {
    set_has_throw_();
    _impl_.types_.throw__ = throw_;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.Subnode.throw)
}
inline ::clojureRT::protobuf::ThrowNode* Subnode::_internal_mutable_throw_() {
  if (!_internal_has_throw_()) {
    clear_types();
    set_has_throw_();
    _impl_.types_.throw__ = CreateMaybeMessage< ::clojureRT::protobuf::ThrowNode >(GetArenaForAllocation());
  }
  return _impl_.types_.throw__;
}
inline ::clojureRT::protobuf::ThrowNode* Subnode::mutable_throw_() {
  ::clojureRT::protobuf::ThrowNode* _msg = _internal_mutable_throw_();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.Subnode.throw)
  return _msg;
}

// .clojureRT.protobuf.TryNode try = 40;
inline bool Subnode::_internal_has_try_() const {
  return types_case() == kTry;
}
inline bool Subnode::has_try_() const {
  return _internal_has_try_();
}
inline void Subnode::set_has_try_() {
  _impl_._oneof_case_[0] = kTry;
}
inline void Subnode::clear_try_() {
  if (_internal_has_try_()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.types_.try__;
    }
    clear_has_types();
  }
}
inline ::clojureRT::protobuf::TryNode* Subnode::release_try_() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.Subnode.try)
  if (_internal_has_try_()) {
    clear_has_types();
    ::clojureRT::protobuf::TryNode* temp = _impl_.types_.try__;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.types_.try__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clojureRT::protobuf::TryNode& Subnode::_internal_try_() const {
  return _internal_has_try_()
      ? *_impl_.types_.try__
      : reinterpret_cast< ::clojureRT::protobuf::TryNode&>(::clojureRT::protobuf::_TryNode_default_instance_);
}
inline const ::clojureRT::protobuf::TryNode& Subnode::try_() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.Subnode.try)
  return _internal_try_();
}
inline ::clojureRT::protobuf::TryNode* Subnode::unsafe_arena_release_try_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:clojureRT.protobuf.Subnode.try)
  if (_internal_has_try_()) {
    clear_has_types();
    ::clojureRT::protobuf::TryNode* temp = _impl_.types_.try__;
    _impl_.types_.try__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Subnode::unsafe_arena_set_allocated_try_(::clojureRT::protobuf::TryNode* try_) {
  clear_types();
  if (try_) {
    set_has_try_();
    _impl_.types_.try__ = try_;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.Subnode.try)
}
inline ::clojureRT::protobuf::TryNode* Subnode::_internal_mutable_try_() {
  if (!_internal_has_try_()) {
    clear_types();
    set_has_try_();
    _impl_.types_.try__ = CreateMaybeMessage< ::clojureRT::protobuf::TryNode >(GetArenaForAllocation());
  }
  return _impl_.types_.try__;
}
inline ::clojureRT::protobuf::TryNode* Subnode::mutable_try_() {
  ::clojureRT::protobuf::TryNode* _msg = _internal_mutable_try_();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.Subnode.try)
  return _msg;
}

// .clojureRT.protobuf.VarNode var = 41;
inline bool Subnode::_internal_has_var() const {
  return types_case() == kVar;
}
inline bool Subnode::has_var() const {
  return _internal_has_var();
}
inline void Subnode::set_has_var() {
  _impl_._oneof_case_[0] = kVar;
}
inline void Subnode::clear_var() {
  if (_internal_has_var()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.types_.var_;
    }
    clear_has_types();
  }
}
inline ::clojureRT::protobuf::VarNode* Subnode::release_var() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.Subnode.var)
  if (_internal_has_var()) {
    clear_has_types();
    ::clojureRT::protobuf::VarNode* temp = _impl_.types_.var_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.types_.var_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clojureRT::protobuf::VarNode& Subnode::_internal_var() const {
  return _internal_has_var()
      ? *_impl_.types_.var_
      : reinterpret_cast< ::clojureRT::protobuf::VarNode&>(::clojureRT::protobuf::_VarNode_default_instance_);
}
inline const ::clojureRT::protobuf::VarNode& Subnode::var() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.Subnode.var)
  return _internal_var();
}
inline ::clojureRT::protobuf::VarNode* Subnode::unsafe_arena_release_var() {
  // @@protoc_insertion_point(field_unsafe_arena_release:clojureRT.protobuf.Subnode.var)
  if (_internal_has_var()) {
    clear_has_types();
    ::clojureRT::protobuf::VarNode* temp = _impl_.types_.var_;
    _impl_.types_.var_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Subnode::unsafe_arena_set_allocated_var(::clojureRT::protobuf::VarNode* var) {
  clear_types();
  if (var) {
    set_has_var();
    _impl_.types_.var_ = var;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.Subnode.var)
}
inline ::clojureRT::protobuf::VarNode* Subnode::_internal_mutable_var() {
  if (!_internal_has_var()) {
    clear_types();
    set_has_var();
    _impl_.types_.var_ = CreateMaybeMessage< ::clojureRT::protobuf::VarNode >(GetArenaForAllocation());
  }
  return _impl_.types_.var_;
}
inline ::clojureRT::protobuf::VarNode* Subnode::mutable_var() {
  ::clojureRT::protobuf::VarNode* _msg = _internal_mutable_var();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.Subnode.var)
  return _msg;
}

// .clojureRT.protobuf.VectorNode vector = 42;
inline bool Subnode::_internal_has_vector() const {
  return types_case() == kVector;
}
inline bool Subnode::has_vector() const {
  return _internal_has_vector();
}
inline void Subnode::set_has_vector() {
  _impl_._oneof_case_[0] = kVector;
}
inline void Subnode::clear_vector() {
  if (_internal_has_vector()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.types_.vector_;
    }
    clear_has_types();
  }
}
inline ::clojureRT::protobuf::VectorNode* Subnode::release_vector() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.Subnode.vector)
  if (_internal_has_vector()) {
    clear_has_types();
    ::clojureRT::protobuf::VectorNode* temp = _impl_.types_.vector_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.types_.vector_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clojureRT::protobuf::VectorNode& Subnode::_internal_vector() const {
  return _internal_has_vector()
      ? *_impl_.types_.vector_
      : reinterpret_cast< ::clojureRT::protobuf::VectorNode&>(::clojureRT::protobuf::_VectorNode_default_instance_);
}
inline const ::clojureRT::protobuf::VectorNode& Subnode::vector() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.Subnode.vector)
  return _internal_vector();
}
inline ::clojureRT::protobuf::VectorNode* Subnode::unsafe_arena_release_vector() {
  // @@protoc_insertion_point(field_unsafe_arena_release:clojureRT.protobuf.Subnode.vector)
  if (_internal_has_vector()) {
    clear_has_types();
    ::clojureRT::protobuf::VectorNode* temp = _impl_.types_.vector_;
    _impl_.types_.vector_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Subnode::unsafe_arena_set_allocated_vector(::clojureRT::protobuf::VectorNode* vector) {
  clear_types();
  if (vector) {
    set_has_vector();
    _impl_.types_.vector_ = vector;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.Subnode.vector)
}
inline ::clojureRT::protobuf::VectorNode* Subnode::_internal_mutable_vector() {
  if (!_internal_has_vector()) {
    clear_types();
    set_has_vector();
    _impl_.types_.vector_ = CreateMaybeMessage< ::clojureRT::protobuf::VectorNode >(GetArenaForAllocation());
  }
  return _impl_.types_.vector_;
}
inline ::clojureRT::protobuf::VectorNode* Subnode::mutable_vector() {
  ::clojureRT::protobuf::VectorNode* _msg = _internal_mutable_vector();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.Subnode.vector)
  return _msg;
}

// .clojureRT.protobuf.WithMetaNode withMeta = 43;
inline bool Subnode::_internal_has_withmeta() const {
  return types_case() == kWithMeta;
}
inline bool Subnode::has_withmeta() const {
  return _internal_has_withmeta();
}
inline void Subnode::set_has_withmeta() {
  _impl_._oneof_case_[0] = kWithMeta;
}
inline void Subnode::clear_withmeta() {
  if (_internal_has_withmeta()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.types_.withmeta_;
    }
    clear_has_types();
  }
}
inline ::clojureRT::protobuf::WithMetaNode* Subnode::release_withmeta() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.Subnode.withMeta)
  if (_internal_has_withmeta()) {
    clear_has_types();
    ::clojureRT::protobuf::WithMetaNode* temp = _impl_.types_.withmeta_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.types_.withmeta_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clojureRT::protobuf::WithMetaNode& Subnode::_internal_withmeta() const {
  return _internal_has_withmeta()
      ? *_impl_.types_.withmeta_
      : reinterpret_cast< ::clojureRT::protobuf::WithMetaNode&>(::clojureRT::protobuf::_WithMetaNode_default_instance_);
}
inline const ::clojureRT::protobuf::WithMetaNode& Subnode::withmeta() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.Subnode.withMeta)
  return _internal_withmeta();
}
inline ::clojureRT::protobuf::WithMetaNode* Subnode::unsafe_arena_release_withmeta() {
  // @@protoc_insertion_point(field_unsafe_arena_release:clojureRT.protobuf.Subnode.withMeta)
  if (_internal_has_withmeta()) {
    clear_has_types();
    ::clojureRT::protobuf::WithMetaNode* temp = _impl_.types_.withmeta_;
    _impl_.types_.withmeta_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Subnode::unsafe_arena_set_allocated_withmeta(::clojureRT::protobuf::WithMetaNode* withmeta) {
  clear_types();
  if (withmeta) {
    set_has_withmeta();
    _impl_.types_.withmeta_ = withmeta;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.Subnode.withMeta)
}
inline ::clojureRT::protobuf::WithMetaNode* Subnode::_internal_mutable_withmeta() {
  if (!_internal_has_withmeta()) {
    clear_types();
    set_has_withmeta();
    _impl_.types_.withmeta_ = CreateMaybeMessage< ::clojureRT::protobuf::WithMetaNode >(GetArenaForAllocation());
  }
  return _impl_.types_.withmeta_;
}
inline ::clojureRT::protobuf::WithMetaNode* Subnode::mutable_withmeta() {
  ::clojureRT::protobuf::WithMetaNode* _msg = _internal_mutable_withmeta();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.Subnode.withMeta)
  return _msg;
}

inline bool Subnode::has_types() const {
  return types_case() != TYPES_NOT_SET;
}
inline void Subnode::clear_has_types() {
  _impl_._oneof_case_[0] = TYPES_NOT_SET;
}
inline Subnode::TypesCase Subnode::types_case() const {
  return Subnode::TypesCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// BindingNode

// optional uint32 argId = 1;
inline bool BindingNode::_internal_has_argid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BindingNode::has_argid() const {
  return _internal_has_argid();
}
inline void BindingNode::clear_argid() {
  _impl_.argid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t BindingNode::_internal_argid() const {
  return _impl_.argid_;
}
inline uint32_t BindingNode::argid() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.BindingNode.argId)
  return _internal_argid();
}
inline void BindingNode::_internal_set_argid(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.argid_ = value;
}
inline void BindingNode::set_argid(uint32_t value) {
  _internal_set_argid(value);
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.BindingNode.argId)
}

// optional .clojureRT.protobuf.Node init = 2;
inline bool BindingNode::_internal_has_init() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.init_ != nullptr);
  return value;
}
inline bool BindingNode::has_init() const {
  return _internal_has_init();
}
inline void BindingNode::clear_init() {
  if (_impl_.init_ != nullptr) _impl_.init_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::clojureRT::protobuf::Node& BindingNode::_internal_init() const {
  const ::clojureRT::protobuf::Node* p = _impl_.init_;
  return p != nullptr ? *p : reinterpret_cast<const ::clojureRT::protobuf::Node&>(
      ::clojureRT::protobuf::_Node_default_instance_);
}
inline const ::clojureRT::protobuf::Node& BindingNode::init() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.BindingNode.init)
  return _internal_init();
}
inline void BindingNode::unsafe_arena_set_allocated_init(
    ::clojureRT::protobuf::Node* init) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.init_);
  }
  _impl_.init_ = init;
  if (init) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.BindingNode.init)
}
inline ::clojureRT::protobuf::Node* BindingNode::release_init() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::clojureRT::protobuf::Node* temp = _impl_.init_;
  _impl_.init_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clojureRT::protobuf::Node* BindingNode::unsafe_arena_release_init() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.BindingNode.init)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::clojureRT::protobuf::Node* temp = _impl_.init_;
  _impl_.init_ = nullptr;
  return temp;
}
inline ::clojureRT::protobuf::Node* BindingNode::_internal_mutable_init() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.init_ == nullptr) {
    auto* p = CreateMaybeMessage<::clojureRT::protobuf::Node>(GetArenaForAllocation());
    _impl_.init_ = p;
  }
  return _impl_.init_;
}
inline ::clojureRT::protobuf::Node* BindingNode::mutable_init() {
  ::clojureRT::protobuf::Node* _msg = _internal_mutable_init();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.BindingNode.init)
  return _msg;
}
inline void BindingNode::set_allocated_init(::clojureRT::protobuf::Node* init) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.init_;
  }
  if (init) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(init);
    if (message_arena != submessage_arena) {
      init = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, init, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.init_ = init;
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.BindingNode.init)
}

// .clojureRT.protobuf.LocalType local = 3;
inline void BindingNode::clear_local() {
  _impl_.local_ = 0;
}
inline ::clojureRT::protobuf::LocalType BindingNode::_internal_local() const {
  return static_cast< ::clojureRT::protobuf::LocalType >(_impl_.local_);
}
inline ::clojureRT::protobuf::LocalType BindingNode::local() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.BindingNode.local)
  return _internal_local();
}
inline void BindingNode::_internal_set_local(::clojureRT::protobuf::LocalType value) {
  
  _impl_.local_ = value;
}
inline void BindingNode::set_local(::clojureRT::protobuf::LocalType value) {
  _internal_set_local(value);
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.BindingNode.local)
}

// string name = 4;
inline void BindingNode::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& BindingNode::name() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.BindingNode.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BindingNode::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.BindingNode.name)
}
inline std::string* BindingNode::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.BindingNode.name)
  return _s;
}
inline const std::string& BindingNode::_internal_name() const {
  return _impl_.name_.Get();
}
inline void BindingNode::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* BindingNode::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* BindingNode::release_name() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.BindingNode.name)
  return _impl_.name_.Release();
}
inline void BindingNode::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.BindingNode.name)
}

// optional bool isVariadic = 5;
inline bool BindingNode::_internal_has_isvariadic() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool BindingNode::has_isvariadic() const {
  return _internal_has_isvariadic();
}
inline void BindingNode::clear_isvariadic() {
  _impl_.isvariadic_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool BindingNode::_internal_isvariadic() const {
  return _impl_.isvariadic_;
}
inline bool BindingNode::isvariadic() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.BindingNode.isVariadic)
  return _internal_isvariadic();
}
inline void BindingNode::_internal_set_isvariadic(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.isvariadic_ = value;
}
inline void BindingNode::set_isvariadic(bool value) {
  _internal_set_isvariadic(value);
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.BindingNode.isVariadic)
}

// -------------------------------------------------------------------

// CaseNode

// .clojureRT.protobuf.Node default = 1;
inline bool CaseNode::_internal_has_default_() const {
  return this != internal_default_instance() && _impl_.default__ != nullptr;
}
inline bool CaseNode::has_default_() const {
  return _internal_has_default_();
}
inline void CaseNode::clear_default_() {
  if (GetArenaForAllocation() == nullptr && _impl_.default__ != nullptr) {
    delete _impl_.default__;
  }
  _impl_.default__ = nullptr;
}
inline const ::clojureRT::protobuf::Node& CaseNode::_internal_default_() const {
  const ::clojureRT::protobuf::Node* p = _impl_.default__;
  return p != nullptr ? *p : reinterpret_cast<const ::clojureRT::protobuf::Node&>(
      ::clojureRT::protobuf::_Node_default_instance_);
}
inline const ::clojureRT::protobuf::Node& CaseNode::default_() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.CaseNode.default)
  return _internal_default_();
}
inline void CaseNode::unsafe_arena_set_allocated_default_(
    ::clojureRT::protobuf::Node* default_) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.default__);
  }
  _impl_.default__ = default_;
  if (default_) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.CaseNode.default)
}
inline ::clojureRT::protobuf::Node* CaseNode::release_default_() {
  
  ::clojureRT::protobuf::Node* temp = _impl_.default__;
  _impl_.default__ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clojureRT::protobuf::Node* CaseNode::unsafe_arena_release_default_() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.CaseNode.default)
  
  ::clojureRT::protobuf::Node* temp = _impl_.default__;
  _impl_.default__ = nullptr;
  return temp;
}
inline ::clojureRT::protobuf::Node* CaseNode::_internal_mutable_default_() {
  
  if (_impl_.default__ == nullptr) {
    auto* p = CreateMaybeMessage<::clojureRT::protobuf::Node>(GetArenaForAllocation());
    _impl_.default__ = p;
  }
  return _impl_.default__;
}
inline ::clojureRT::protobuf::Node* CaseNode::mutable_default_() {
  ::clojureRT::protobuf::Node* _msg = _internal_mutable_default_();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.CaseNode.default)
  return _msg;
}
inline void CaseNode::set_allocated_default_(::clojureRT::protobuf::Node* default_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.default__;
  }
  if (default_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(default_);
    if (message_arena != submessage_arena) {
      default_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, default_, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.default__ = default_;
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.CaseNode.default)
}

// string high = 2;
inline void CaseNode::clear_high() {
  _impl_.high_.ClearToEmpty();
}
inline const std::string& CaseNode::high() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.CaseNode.high)
  return _internal_high();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CaseNode::set_high(ArgT0&& arg0, ArgT... args) {
 
 _impl_.high_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.CaseNode.high)
}
inline std::string* CaseNode::mutable_high() {
  std::string* _s = _internal_mutable_high();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.CaseNode.high)
  return _s;
}
inline const std::string& CaseNode::_internal_high() const {
  return _impl_.high_.Get();
}
inline void CaseNode::_internal_set_high(const std::string& value) {
  
  _impl_.high_.Set(value, GetArenaForAllocation());
}
inline std::string* CaseNode::_internal_mutable_high() {
  
  return _impl_.high_.Mutable(GetArenaForAllocation());
}
inline std::string* CaseNode::release_high() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.CaseNode.high)
  return _impl_.high_.Release();
}
inline void CaseNode::set_allocated_high(std::string* high) {
  if (high != nullptr) {
    
  } else {
    
  }
  _impl_.high_.SetAllocated(high, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.high_.IsDefault()) {
    _impl_.high_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.CaseNode.high)
}

// string low = 3;
inline void CaseNode::clear_low() {
  _impl_.low_.ClearToEmpty();
}
inline const std::string& CaseNode::low() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.CaseNode.low)
  return _internal_low();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CaseNode::set_low(ArgT0&& arg0, ArgT... args) {
 
 _impl_.low_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.CaseNode.low)
}
inline std::string* CaseNode::mutable_low() {
  std::string* _s = _internal_mutable_low();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.CaseNode.low)
  return _s;
}
inline const std::string& CaseNode::_internal_low() const {
  return _impl_.low_.Get();
}
inline void CaseNode::_internal_set_low(const std::string& value) {
  
  _impl_.low_.Set(value, GetArenaForAllocation());
}
inline std::string* CaseNode::_internal_mutable_low() {
  
  return _impl_.low_.Mutable(GetArenaForAllocation());
}
inline std::string* CaseNode::release_low() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.CaseNode.low)
  return _impl_.low_.Release();
}
inline void CaseNode::set_allocated_low(std::string* low) {
  if (low != nullptr) {
    
  } else {
    
  }
  _impl_.low_.SetAllocated(low, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.low_.IsDefault()) {
    _impl_.low_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.CaseNode.low)
}

// uint32 mask = 4;
inline void CaseNode::clear_mask() {
  _impl_.mask_ = 0u;
}
inline uint32_t CaseNode::_internal_mask() const {
  return _impl_.mask_;
}
inline uint32_t CaseNode::mask() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.CaseNode.mask)
  return _internal_mask();
}
inline void CaseNode::_internal_set_mask(uint32_t value) {
  
  _impl_.mask_ = value;
}
inline void CaseNode::set_mask(uint32_t value) {
  _internal_set_mask(value);
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.CaseNode.mask)
}

// uint32 shift = 5;
inline void CaseNode::clear_shift() {
  _impl_.shift_ = 0u;
}
inline uint32_t CaseNode::_internal_shift() const {
  return _impl_.shift_;
}
inline uint32_t CaseNode::shift() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.CaseNode.shift)
  return _internal_shift();
}
inline void CaseNode::_internal_set_shift(uint32_t value) {
  
  _impl_.shift_ = value;
}
inline void CaseNode::set_shift(uint32_t value) {
  _internal_set_shift(value);
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.CaseNode.shift)
}

// string isSkipCheck = 6;
inline void CaseNode::clear_isskipcheck() {
  _impl_.isskipcheck_.ClearToEmpty();
}
inline const std::string& CaseNode::isskipcheck() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.CaseNode.isSkipCheck)
  return _internal_isskipcheck();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CaseNode::set_isskipcheck(ArgT0&& arg0, ArgT... args) {
 
 _impl_.isskipcheck_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.CaseNode.isSkipCheck)
}
inline std::string* CaseNode::mutable_isskipcheck() {
  std::string* _s = _internal_mutable_isskipcheck();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.CaseNode.isSkipCheck)
  return _s;
}
inline const std::string& CaseNode::_internal_isskipcheck() const {
  return _impl_.isskipcheck_.Get();
}
inline void CaseNode::_internal_set_isskipcheck(const std::string& value) {
  
  _impl_.isskipcheck_.Set(value, GetArenaForAllocation());
}
inline std::string* CaseNode::_internal_mutable_isskipcheck() {
  
  return _impl_.isskipcheck_.Mutable(GetArenaForAllocation());
}
inline std::string* CaseNode::release_isskipcheck() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.CaseNode.isSkipCheck)
  return _impl_.isskipcheck_.Release();
}
inline void CaseNode::set_allocated_isskipcheck(std::string* isskipcheck) {
  if (isskipcheck != nullptr) {
    
  } else {
    
  }
  _impl_.isskipcheck_.SetAllocated(isskipcheck, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.isskipcheck_.IsDefault()) {
    _impl_.isskipcheck_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.CaseNode.isSkipCheck)
}

// .clojureRT.protobuf.CaseNode.SwitchType switchType = 7;
inline void CaseNode::clear_switchtype() {
  _impl_.switchtype_ = 0;
}
inline ::clojureRT::protobuf::CaseNode_SwitchType CaseNode::_internal_switchtype() const {
  return static_cast< ::clojureRT::protobuf::CaseNode_SwitchType >(_impl_.switchtype_);
}
inline ::clojureRT::protobuf::CaseNode_SwitchType CaseNode::switchtype() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.CaseNode.switchType)
  return _internal_switchtype();
}
inline void CaseNode::_internal_set_switchtype(::clojureRT::protobuf::CaseNode_SwitchType value) {
  
  _impl_.switchtype_ = value;
}
inline void CaseNode::set_switchtype(::clojureRT::protobuf::CaseNode_SwitchType value) {
  _internal_set_switchtype(value);
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.CaseNode.switchType)
}

// .clojureRT.protobuf.Node test = 8;
inline bool CaseNode::_internal_has_test() const {
  return this != internal_default_instance() && _impl_.test_ != nullptr;
}
inline bool CaseNode::has_test() const {
  return _internal_has_test();
}
inline void CaseNode::clear_test() {
  if (GetArenaForAllocation() == nullptr && _impl_.test_ != nullptr) {
    delete _impl_.test_;
  }
  _impl_.test_ = nullptr;
}
inline const ::clojureRT::protobuf::Node& CaseNode::_internal_test() const {
  const ::clojureRT::protobuf::Node* p = _impl_.test_;
  return p != nullptr ? *p : reinterpret_cast<const ::clojureRT::protobuf::Node&>(
      ::clojureRT::protobuf::_Node_default_instance_);
}
inline const ::clojureRT::protobuf::Node& CaseNode::test() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.CaseNode.test)
  return _internal_test();
}
inline void CaseNode::unsafe_arena_set_allocated_test(
    ::clojureRT::protobuf::Node* test) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.test_);
  }
  _impl_.test_ = test;
  if (test) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.CaseNode.test)
}
inline ::clojureRT::protobuf::Node* CaseNode::release_test() {
  
  ::clojureRT::protobuf::Node* temp = _impl_.test_;
  _impl_.test_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clojureRT::protobuf::Node* CaseNode::unsafe_arena_release_test() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.CaseNode.test)
  
  ::clojureRT::protobuf::Node* temp = _impl_.test_;
  _impl_.test_ = nullptr;
  return temp;
}
inline ::clojureRT::protobuf::Node* CaseNode::_internal_mutable_test() {
  
  if (_impl_.test_ == nullptr) {
    auto* p = CreateMaybeMessage<::clojureRT::protobuf::Node>(GetArenaForAllocation());
    _impl_.test_ = p;
  }
  return _impl_.test_;
}
inline ::clojureRT::protobuf::Node* CaseNode::mutable_test() {
  ::clojureRT::protobuf::Node* _msg = _internal_mutable_test();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.CaseNode.test)
  return _msg;
}
inline void CaseNode::set_allocated_test(::clojureRT::protobuf::Node* test) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.test_;
  }
  if (test) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(test);
    if (message_arena != submessage_arena) {
      test = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, test, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.test_ = test;
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.CaseNode.test)
}

// .clojureRT.protobuf.CaseNode.TestType testType = 9;
inline void CaseNode::clear_testtype() {
  _impl_.testtype_ = 0;
}
inline ::clojureRT::protobuf::CaseNode_TestType CaseNode::_internal_testtype() const {
  return static_cast< ::clojureRT::protobuf::CaseNode_TestType >(_impl_.testtype_);
}
inline ::clojureRT::protobuf::CaseNode_TestType CaseNode::testtype() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.CaseNode.testType)
  return _internal_testtype();
}
inline void CaseNode::_internal_set_testtype(::clojureRT::protobuf::CaseNode_TestType value) {
  
  _impl_.testtype_ = value;
}
inline void CaseNode::set_testtype(::clojureRT::protobuf::CaseNode_TestType value) {
  _internal_set_testtype(value);
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.CaseNode.testType)
}

// repeated .clojureRT.protobuf.Node tests = 10;
inline int CaseNode::_internal_tests_size() const {
  return _impl_.tests_.size();
}
inline int CaseNode::tests_size() const {
  return _internal_tests_size();
}
inline void CaseNode::clear_tests() {
  _impl_.tests_.Clear();
}
inline ::clojureRT::protobuf::Node* CaseNode::mutable_tests(int index) {
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.CaseNode.tests)
  return _impl_.tests_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >*
CaseNode::mutable_tests() {
  // @@protoc_insertion_point(field_mutable_list:clojureRT.protobuf.CaseNode.tests)
  return &_impl_.tests_;
}
inline const ::clojureRT::protobuf::Node& CaseNode::_internal_tests(int index) const {
  return _impl_.tests_.Get(index);
}
inline const ::clojureRT::protobuf::Node& CaseNode::tests(int index) const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.CaseNode.tests)
  return _internal_tests(index);
}
inline ::clojureRT::protobuf::Node* CaseNode::_internal_add_tests() {
  return _impl_.tests_.Add();
}
inline ::clojureRT::protobuf::Node* CaseNode::add_tests() {
  ::clojureRT::protobuf::Node* _add = _internal_add_tests();
  // @@protoc_insertion_point(field_add:clojureRT.protobuf.CaseNode.tests)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >&
CaseNode::tests() const {
  // @@protoc_insertion_point(field_list:clojureRT.protobuf.CaseNode.tests)
  return _impl_.tests_;
}

// repeated .clojureRT.protobuf.Node thens = 11;
inline int CaseNode::_internal_thens_size() const {
  return _impl_.thens_.size();
}
inline int CaseNode::thens_size() const {
  return _internal_thens_size();
}
inline void CaseNode::clear_thens() {
  _impl_.thens_.Clear();
}
inline ::clojureRT::protobuf::Node* CaseNode::mutable_thens(int index) {
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.CaseNode.thens)
  return _impl_.thens_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >*
CaseNode::mutable_thens() {
  // @@protoc_insertion_point(field_mutable_list:clojureRT.protobuf.CaseNode.thens)
  return &_impl_.thens_;
}
inline const ::clojureRT::protobuf::Node& CaseNode::_internal_thens(int index) const {
  return _impl_.thens_.Get(index);
}
inline const ::clojureRT::protobuf::Node& CaseNode::thens(int index) const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.CaseNode.thens)
  return _internal_thens(index);
}
inline ::clojureRT::protobuf::Node* CaseNode::_internal_add_thens() {
  return _impl_.thens_.Add();
}
inline ::clojureRT::protobuf::Node* CaseNode::add_thens() {
  ::clojureRT::protobuf::Node* _add = _internal_add_thens();
  // @@protoc_insertion_point(field_add:clojureRT.protobuf.CaseNode.thens)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >&
CaseNode::thens() const {
  // @@protoc_insertion_point(field_list:clojureRT.protobuf.CaseNode.thens)
  return _impl_.thens_;
}

// -------------------------------------------------------------------

// CaseTestNode

// uint32 hash = 1;
inline void CaseTestNode::clear_hash() {
  _impl_.hash_ = 0u;
}
inline uint32_t CaseTestNode::_internal_hash() const {
  return _impl_.hash_;
}
inline uint32_t CaseTestNode::hash() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.CaseTestNode.hash)
  return _internal_hash();
}
inline void CaseTestNode::_internal_set_hash(uint32_t value) {
  
  _impl_.hash_ = value;
}
inline void CaseTestNode::set_hash(uint32_t value) {
  _internal_set_hash(value);
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.CaseTestNode.hash)
}

// .clojureRT.protobuf.Node test = 2;
inline bool CaseTestNode::_internal_has_test() const {
  return this != internal_default_instance() && _impl_.test_ != nullptr;
}
inline bool CaseTestNode::has_test() const {
  return _internal_has_test();
}
inline void CaseTestNode::clear_test() {
  if (GetArenaForAllocation() == nullptr && _impl_.test_ != nullptr) {
    delete _impl_.test_;
  }
  _impl_.test_ = nullptr;
}
inline const ::clojureRT::protobuf::Node& CaseTestNode::_internal_test() const {
  const ::clojureRT::protobuf::Node* p = _impl_.test_;
  return p != nullptr ? *p : reinterpret_cast<const ::clojureRT::protobuf::Node&>(
      ::clojureRT::protobuf::_Node_default_instance_);
}
inline const ::clojureRT::protobuf::Node& CaseTestNode::test() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.CaseTestNode.test)
  return _internal_test();
}
inline void CaseTestNode::unsafe_arena_set_allocated_test(
    ::clojureRT::protobuf::Node* test) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.test_);
  }
  _impl_.test_ = test;
  if (test) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.CaseTestNode.test)
}
inline ::clojureRT::protobuf::Node* CaseTestNode::release_test() {
  
  ::clojureRT::protobuf::Node* temp = _impl_.test_;
  _impl_.test_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clojureRT::protobuf::Node* CaseTestNode::unsafe_arena_release_test() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.CaseTestNode.test)
  
  ::clojureRT::protobuf::Node* temp = _impl_.test_;
  _impl_.test_ = nullptr;
  return temp;
}
inline ::clojureRT::protobuf::Node* CaseTestNode::_internal_mutable_test() {
  
  if (_impl_.test_ == nullptr) {
    auto* p = CreateMaybeMessage<::clojureRT::protobuf::Node>(GetArenaForAllocation());
    _impl_.test_ = p;
  }
  return _impl_.test_;
}
inline ::clojureRT::protobuf::Node* CaseTestNode::mutable_test() {
  ::clojureRT::protobuf::Node* _msg = _internal_mutable_test();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.CaseTestNode.test)
  return _msg;
}
inline void CaseTestNode::set_allocated_test(::clojureRT::protobuf::Node* test) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.test_;
  }
  if (test) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(test);
    if (message_arena != submessage_arena) {
      test = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, test, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.test_ = test;
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.CaseTestNode.test)
}

// -------------------------------------------------------------------

// CaseThenNode

// uint32 hash = 1;
inline void CaseThenNode::clear_hash() {
  _impl_.hash_ = 0u;
}
inline uint32_t CaseThenNode::_internal_hash() const {
  return _impl_.hash_;
}
inline uint32_t CaseThenNode::hash() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.CaseThenNode.hash)
  return _internal_hash();
}
inline void CaseThenNode::_internal_set_hash(uint32_t value) {
  
  _impl_.hash_ = value;
}
inline void CaseThenNode::set_hash(uint32_t value) {
  _internal_set_hash(value);
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.CaseThenNode.hash)
}

// .clojureRT.protobuf.Node then = 2;
inline bool CaseThenNode::_internal_has_then() const {
  return this != internal_default_instance() && _impl_.then_ != nullptr;
}
inline bool CaseThenNode::has_then() const {
  return _internal_has_then();
}
inline void CaseThenNode::clear_then() {
  if (GetArenaForAllocation() == nullptr && _impl_.then_ != nullptr) {
    delete _impl_.then_;
  }
  _impl_.then_ = nullptr;
}
inline const ::clojureRT::protobuf::Node& CaseThenNode::_internal_then() const {
  const ::clojureRT::protobuf::Node* p = _impl_.then_;
  return p != nullptr ? *p : reinterpret_cast<const ::clojureRT::protobuf::Node&>(
      ::clojureRT::protobuf::_Node_default_instance_);
}
inline const ::clojureRT::protobuf::Node& CaseThenNode::then() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.CaseThenNode.then)
  return _internal_then();
}
inline void CaseThenNode::unsafe_arena_set_allocated_then(
    ::clojureRT::protobuf::Node* then) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.then_);
  }
  _impl_.then_ = then;
  if (then) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.CaseThenNode.then)
}
inline ::clojureRT::protobuf::Node* CaseThenNode::release_then() {
  
  ::clojureRT::protobuf::Node* temp = _impl_.then_;
  _impl_.then_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clojureRT::protobuf::Node* CaseThenNode::unsafe_arena_release_then() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.CaseThenNode.then)
  
  ::clojureRT::protobuf::Node* temp = _impl_.then_;
  _impl_.then_ = nullptr;
  return temp;
}
inline ::clojureRT::protobuf::Node* CaseThenNode::_internal_mutable_then() {
  
  if (_impl_.then_ == nullptr) {
    auto* p = CreateMaybeMessage<::clojureRT::protobuf::Node>(GetArenaForAllocation());
    _impl_.then_ = p;
  }
  return _impl_.then_;
}
inline ::clojureRT::protobuf::Node* CaseThenNode::mutable_then() {
  ::clojureRT::protobuf::Node* _msg = _internal_mutable_then();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.CaseThenNode.then)
  return _msg;
}
inline void CaseThenNode::set_allocated_then(::clojureRT::protobuf::Node* then) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.then_;
  }
  if (then) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(then);
    if (message_arena != submessage_arena) {
      then = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, then, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.then_ = then;
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.CaseThenNode.then)
}

// -------------------------------------------------------------------

// CatchNode

// .clojureRT.protobuf.Node body = 1;
inline bool CatchNode::_internal_has_body() const {
  return this != internal_default_instance() && _impl_.body_ != nullptr;
}
inline bool CatchNode::has_body() const {
  return _internal_has_body();
}
inline void CatchNode::clear_body() {
  if (GetArenaForAllocation() == nullptr && _impl_.body_ != nullptr) {
    delete _impl_.body_;
  }
  _impl_.body_ = nullptr;
}
inline const ::clojureRT::protobuf::Node& CatchNode::_internal_body() const {
  const ::clojureRT::protobuf::Node* p = _impl_.body_;
  return p != nullptr ? *p : reinterpret_cast<const ::clojureRT::protobuf::Node&>(
      ::clojureRT::protobuf::_Node_default_instance_);
}
inline const ::clojureRT::protobuf::Node& CatchNode::body() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.CatchNode.body)
  return _internal_body();
}
inline void CatchNode::unsafe_arena_set_allocated_body(
    ::clojureRT::protobuf::Node* body) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.body_);
  }
  _impl_.body_ = body;
  if (body) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.CatchNode.body)
}
inline ::clojureRT::protobuf::Node* CatchNode::release_body() {
  
  ::clojureRT::protobuf::Node* temp = _impl_.body_;
  _impl_.body_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clojureRT::protobuf::Node* CatchNode::unsafe_arena_release_body() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.CatchNode.body)
  
  ::clojureRT::protobuf::Node* temp = _impl_.body_;
  _impl_.body_ = nullptr;
  return temp;
}
inline ::clojureRT::protobuf::Node* CatchNode::_internal_mutable_body() {
  
  if (_impl_.body_ == nullptr) {
    auto* p = CreateMaybeMessage<::clojureRT::protobuf::Node>(GetArenaForAllocation());
    _impl_.body_ = p;
  }
  return _impl_.body_;
}
inline ::clojureRT::protobuf::Node* CatchNode::mutable_body() {
  ::clojureRT::protobuf::Node* _msg = _internal_mutable_body();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.CatchNode.body)
  return _msg;
}
inline void CatchNode::set_allocated_body(::clojureRT::protobuf::Node* body) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.body_;
  }
  if (body) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(body);
    if (message_arena != submessage_arena) {
      body = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, body, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.body_ = body;
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.CatchNode.body)
}

// .clojureRT.protobuf.Node class = 2;
inline bool CatchNode::_internal_has_class_() const {
  return this != internal_default_instance() && _impl_.class__ != nullptr;
}
inline bool CatchNode::has_class_() const {
  return _internal_has_class_();
}
inline void CatchNode::clear_class_() {
  if (GetArenaForAllocation() == nullptr && _impl_.class__ != nullptr) {
    delete _impl_.class__;
  }
  _impl_.class__ = nullptr;
}
inline const ::clojureRT::protobuf::Node& CatchNode::_internal_class_() const {
  const ::clojureRT::protobuf::Node* p = _impl_.class__;
  return p != nullptr ? *p : reinterpret_cast<const ::clojureRT::protobuf::Node&>(
      ::clojureRT::protobuf::_Node_default_instance_);
}
inline const ::clojureRT::protobuf::Node& CatchNode::class_() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.CatchNode.class)
  return _internal_class_();
}
inline void CatchNode::unsafe_arena_set_allocated_class_(
    ::clojureRT::protobuf::Node* class_) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.class__);
  }
  _impl_.class__ = class_;
  if (class_) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.CatchNode.class)
}
inline ::clojureRT::protobuf::Node* CatchNode::release_class_() {
  
  ::clojureRT::protobuf::Node* temp = _impl_.class__;
  _impl_.class__ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clojureRT::protobuf::Node* CatchNode::unsafe_arena_release_class_() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.CatchNode.class)
  
  ::clojureRT::protobuf::Node* temp = _impl_.class__;
  _impl_.class__ = nullptr;
  return temp;
}
inline ::clojureRT::protobuf::Node* CatchNode::_internal_mutable_class_() {
  
  if (_impl_.class__ == nullptr) {
    auto* p = CreateMaybeMessage<::clojureRT::protobuf::Node>(GetArenaForAllocation());
    _impl_.class__ = p;
  }
  return _impl_.class__;
}
inline ::clojureRT::protobuf::Node* CatchNode::mutable_class_() {
  ::clojureRT::protobuf::Node* _msg = _internal_mutable_class_();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.CatchNode.class)
  return _msg;
}
inline void CatchNode::set_allocated_class_(::clojureRT::protobuf::Node* class_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.class__;
  }
  if (class_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(class_);
    if (message_arena != submessage_arena) {
      class_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, class_, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.class__ = class_;
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.CatchNode.class)
}

// .clojureRT.protobuf.Node local = 3;
inline bool CatchNode::_internal_has_local() const {
  return this != internal_default_instance() && _impl_.local_ != nullptr;
}
inline bool CatchNode::has_local() const {
  return _internal_has_local();
}
inline void CatchNode::clear_local() {
  if (GetArenaForAllocation() == nullptr && _impl_.local_ != nullptr) {
    delete _impl_.local_;
  }
  _impl_.local_ = nullptr;
}
inline const ::clojureRT::protobuf::Node& CatchNode::_internal_local() const {
  const ::clojureRT::protobuf::Node* p = _impl_.local_;
  return p != nullptr ? *p : reinterpret_cast<const ::clojureRT::protobuf::Node&>(
      ::clojureRT::protobuf::_Node_default_instance_);
}
inline const ::clojureRT::protobuf::Node& CatchNode::local() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.CatchNode.local)
  return _internal_local();
}
inline void CatchNode::unsafe_arena_set_allocated_local(
    ::clojureRT::protobuf::Node* local) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.local_);
  }
  _impl_.local_ = local;
  if (local) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.CatchNode.local)
}
inline ::clojureRT::protobuf::Node* CatchNode::release_local() {
  
  ::clojureRT::protobuf::Node* temp = _impl_.local_;
  _impl_.local_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clojureRT::protobuf::Node* CatchNode::unsafe_arena_release_local() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.CatchNode.local)
  
  ::clojureRT::protobuf::Node* temp = _impl_.local_;
  _impl_.local_ = nullptr;
  return temp;
}
inline ::clojureRT::protobuf::Node* CatchNode::_internal_mutable_local() {
  
  if (_impl_.local_ == nullptr) {
    auto* p = CreateMaybeMessage<::clojureRT::protobuf::Node>(GetArenaForAllocation());
    _impl_.local_ = p;
  }
  return _impl_.local_;
}
inline ::clojureRT::protobuf::Node* CatchNode::mutable_local() {
  ::clojureRT::protobuf::Node* _msg = _internal_mutable_local();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.CatchNode.local)
  return _msg;
}
inline void CatchNode::set_allocated_local(::clojureRT::protobuf::Node* local) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.local_;
  }
  if (local) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(local);
    if (message_arena != submessage_arena) {
      local = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, local, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.local_ = local;
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.CatchNode.local)
}

// -------------------------------------------------------------------

// ConstNode

// bool isLiteral = 1;
inline void ConstNode::clear_isliteral() {
  _impl_.isliteral_ = false;
}
inline bool ConstNode::_internal_isliteral() const {
  return _impl_.isliteral_;
}
inline bool ConstNode::isliteral() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.ConstNode.isLiteral)
  return _internal_isliteral();
}
inline void ConstNode::_internal_set_isliteral(bool value) {
  
  _impl_.isliteral_ = value;
}
inline void ConstNode::set_isliteral(bool value) {
  _internal_set_isliteral(value);
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.ConstNode.isLiteral)
}

// optional .clojureRT.protobuf.Node meta = 2;
inline bool ConstNode::_internal_has_meta() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.meta_ != nullptr);
  return value;
}
inline bool ConstNode::has_meta() const {
  return _internal_has_meta();
}
inline void ConstNode::clear_meta() {
  if (_impl_.meta_ != nullptr) _impl_.meta_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::clojureRT::protobuf::Node& ConstNode::_internal_meta() const {
  const ::clojureRT::protobuf::Node* p = _impl_.meta_;
  return p != nullptr ? *p : reinterpret_cast<const ::clojureRT::protobuf::Node&>(
      ::clojureRT::protobuf::_Node_default_instance_);
}
inline const ::clojureRT::protobuf::Node& ConstNode::meta() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.ConstNode.meta)
  return _internal_meta();
}
inline void ConstNode::unsafe_arena_set_allocated_meta(
    ::clojureRT::protobuf::Node* meta) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.meta_);
  }
  _impl_.meta_ = meta;
  if (meta) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.ConstNode.meta)
}
inline ::clojureRT::protobuf::Node* ConstNode::release_meta() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::clojureRT::protobuf::Node* temp = _impl_.meta_;
  _impl_.meta_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clojureRT::protobuf::Node* ConstNode::unsafe_arena_release_meta() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.ConstNode.meta)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::clojureRT::protobuf::Node* temp = _impl_.meta_;
  _impl_.meta_ = nullptr;
  return temp;
}
inline ::clojureRT::protobuf::Node* ConstNode::_internal_mutable_meta() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.meta_ == nullptr) {
    auto* p = CreateMaybeMessage<::clojureRT::protobuf::Node>(GetArenaForAllocation());
    _impl_.meta_ = p;
  }
  return _impl_.meta_;
}
inline ::clojureRT::protobuf::Node* ConstNode::mutable_meta() {
  ::clojureRT::protobuf::Node* _msg = _internal_mutable_meta();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.ConstNode.meta)
  return _msg;
}
inline void ConstNode::set_allocated_meta(::clojureRT::protobuf::Node* meta) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.meta_;
  }
  if (meta) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(meta);
    if (message_arena != submessage_arena) {
      meta = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, meta, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.meta_ = meta;
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.ConstNode.meta)
}

// .clojureRT.protobuf.ConstNode.ConstType type = 3;
inline void ConstNode::clear_type() {
  _impl_.type_ = 0;
}
inline ::clojureRT::protobuf::ConstNode_ConstType ConstNode::_internal_type() const {
  return static_cast< ::clojureRT::protobuf::ConstNode_ConstType >(_impl_.type_);
}
inline ::clojureRT::protobuf::ConstNode_ConstType ConstNode::type() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.ConstNode.type)
  return _internal_type();
}
inline void ConstNode::_internal_set_type(::clojureRT::protobuf::ConstNode_ConstType value) {
  
  _impl_.type_ = value;
}
inline void ConstNode::set_type(::clojureRT::protobuf::ConstNode_ConstType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.ConstNode.type)
}

// string val = 4;
inline void ConstNode::clear_val() {
  _impl_.val_.ClearToEmpty();
}
inline const std::string& ConstNode::val() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.ConstNode.val)
  return _internal_val();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConstNode::set_val(ArgT0&& arg0, ArgT... args) {
 
 _impl_.val_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.ConstNode.val)
}
inline std::string* ConstNode::mutable_val() {
  std::string* _s = _internal_mutable_val();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.ConstNode.val)
  return _s;
}
inline const std::string& ConstNode::_internal_val() const {
  return _impl_.val_.Get();
}
inline void ConstNode::_internal_set_val(const std::string& value) {
  
  _impl_.val_.Set(value, GetArenaForAllocation());
}
inline std::string* ConstNode::_internal_mutable_val() {
  
  return _impl_.val_.Mutable(GetArenaForAllocation());
}
inline std::string* ConstNode::release_val() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.ConstNode.val)
  return _impl_.val_.Release();
}
inline void ConstNode::set_allocated_val(std::string* val) {
  if (val != nullptr) {
    
  } else {
    
  }
  _impl_.val_.SetAllocated(val, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.val_.IsDefault()) {
    _impl_.val_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.ConstNode.val)
}

// -------------------------------------------------------------------

// DefNode

// optional string doc = 1;
inline bool DefNode::_internal_has_doc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DefNode::has_doc() const {
  return _internal_has_doc();
}
inline void DefNode::clear_doc() {
  _impl_.doc_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DefNode::doc() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.DefNode.doc)
  return _internal_doc();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DefNode::set_doc(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.doc_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.DefNode.doc)
}
inline std::string* DefNode::mutable_doc() {
  std::string* _s = _internal_mutable_doc();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.DefNode.doc)
  return _s;
}
inline const std::string& DefNode::_internal_doc() const {
  return _impl_.doc_.Get();
}
inline void DefNode::_internal_set_doc(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.doc_.Set(value, GetArenaForAllocation());
}
inline std::string* DefNode::_internal_mutable_doc() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.doc_.Mutable(GetArenaForAllocation());
}
inline std::string* DefNode::release_doc() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.DefNode.doc)
  if (!_internal_has_doc()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.doc_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.doc_.IsDefault()) {
    _impl_.doc_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DefNode::set_allocated_doc(std::string* doc) {
  if (doc != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.doc_.SetAllocated(doc, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.doc_.IsDefault()) {
    _impl_.doc_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.DefNode.doc)
}

// optional .clojureRT.protobuf.Node init = 2;
inline bool DefNode::_internal_has_init() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.init_ != nullptr);
  return value;
}
inline bool DefNode::has_init() const {
  return _internal_has_init();
}
inline void DefNode::clear_init() {
  if (_impl_.init_ != nullptr) _impl_.init_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::clojureRT::protobuf::Node& DefNode::_internal_init() const {
  const ::clojureRT::protobuf::Node* p = _impl_.init_;
  return p != nullptr ? *p : reinterpret_cast<const ::clojureRT::protobuf::Node&>(
      ::clojureRT::protobuf::_Node_default_instance_);
}
inline const ::clojureRT::protobuf::Node& DefNode::init() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.DefNode.init)
  return _internal_init();
}
inline void DefNode::unsafe_arena_set_allocated_init(
    ::clojureRT::protobuf::Node* init) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.init_);
  }
  _impl_.init_ = init;
  if (init) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.DefNode.init)
}
inline ::clojureRT::protobuf::Node* DefNode::release_init() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::clojureRT::protobuf::Node* temp = _impl_.init_;
  _impl_.init_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clojureRT::protobuf::Node* DefNode::unsafe_arena_release_init() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.DefNode.init)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::clojureRT::protobuf::Node* temp = _impl_.init_;
  _impl_.init_ = nullptr;
  return temp;
}
inline ::clojureRT::protobuf::Node* DefNode::_internal_mutable_init() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.init_ == nullptr) {
    auto* p = CreateMaybeMessage<::clojureRT::protobuf::Node>(GetArenaForAllocation());
    _impl_.init_ = p;
  }
  return _impl_.init_;
}
inline ::clojureRT::protobuf::Node* DefNode::mutable_init() {
  ::clojureRT::protobuf::Node* _msg = _internal_mutable_init();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.DefNode.init)
  return _msg;
}
inline void DefNode::set_allocated_init(::clojureRT::protobuf::Node* init) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.init_;
  }
  if (init) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(init);
    if (message_arena != submessage_arena) {
      init = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, init, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.init_ = init;
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.DefNode.init)
}

// optional .clojureRT.protobuf.Node meta = 3;
inline bool DefNode::_internal_has_meta() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.meta_ != nullptr);
  return value;
}
inline bool DefNode::has_meta() const {
  return _internal_has_meta();
}
inline void DefNode::clear_meta() {
  if (_impl_.meta_ != nullptr) _impl_.meta_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::clojureRT::protobuf::Node& DefNode::_internal_meta() const {
  const ::clojureRT::protobuf::Node* p = _impl_.meta_;
  return p != nullptr ? *p : reinterpret_cast<const ::clojureRT::protobuf::Node&>(
      ::clojureRT::protobuf::_Node_default_instance_);
}
inline const ::clojureRT::protobuf::Node& DefNode::meta() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.DefNode.meta)
  return _internal_meta();
}
inline void DefNode::unsafe_arena_set_allocated_meta(
    ::clojureRT::protobuf::Node* meta) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.meta_);
  }
  _impl_.meta_ = meta;
  if (meta) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.DefNode.meta)
}
inline ::clojureRT::protobuf::Node* DefNode::release_meta() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::clojureRT::protobuf::Node* temp = _impl_.meta_;
  _impl_.meta_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clojureRT::protobuf::Node* DefNode::unsafe_arena_release_meta() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.DefNode.meta)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::clojureRT::protobuf::Node* temp = _impl_.meta_;
  _impl_.meta_ = nullptr;
  return temp;
}
inline ::clojureRT::protobuf::Node* DefNode::_internal_mutable_meta() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.meta_ == nullptr) {
    auto* p = CreateMaybeMessage<::clojureRT::protobuf::Node>(GetArenaForAllocation());
    _impl_.meta_ = p;
  }
  return _impl_.meta_;
}
inline ::clojureRT::protobuf::Node* DefNode::mutable_meta() {
  ::clojureRT::protobuf::Node* _msg = _internal_mutable_meta();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.DefNode.meta)
  return _msg;
}
inline void DefNode::set_allocated_meta(::clojureRT::protobuf::Node* meta) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.meta_;
  }
  if (meta) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(meta);
    if (message_arena != submessage_arena) {
      meta = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, meta, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.meta_ = meta;
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.DefNode.meta)
}

// string name = 4;
inline void DefNode::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& DefNode::name() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.DefNode.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DefNode::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.DefNode.name)
}
inline std::string* DefNode::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.DefNode.name)
  return _s;
}
inline const std::string& DefNode::_internal_name() const {
  return _impl_.name_.Get();
}
inline void DefNode::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* DefNode::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* DefNode::release_name() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.DefNode.name)
  return _impl_.name_.Release();
}
inline void DefNode::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.DefNode.name)
}

// string var = 5;
inline void DefNode::clear_var() {
  _impl_.var_.ClearToEmpty();
}
inline const std::string& DefNode::var() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.DefNode.var)
  return _internal_var();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DefNode::set_var(ArgT0&& arg0, ArgT... args) {
 
 _impl_.var_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.DefNode.var)
}
inline std::string* DefNode::mutable_var() {
  std::string* _s = _internal_mutable_var();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.DefNode.var)
  return _s;
}
inline const std::string& DefNode::_internal_var() const {
  return _impl_.var_.Get();
}
inline void DefNode::_internal_set_var(const std::string& value) {
  
  _impl_.var_.Set(value, GetArenaForAllocation());
}
inline std::string* DefNode::_internal_mutable_var() {
  
  return _impl_.var_.Mutable(GetArenaForAllocation());
}
inline std::string* DefNode::release_var() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.DefNode.var)
  return _impl_.var_.Release();
}
inline void DefNode::set_allocated_var(std::string* var) {
  if (var != nullptr) {
    
  } else {
    
  }
  _impl_.var_.SetAllocated(var, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.var_.IsDefault()) {
    _impl_.var_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.DefNode.var)
}

// -------------------------------------------------------------------

// DeftypeNode

// string className = 1;
inline void DeftypeNode::clear_classname() {
  _impl_.classname_.ClearToEmpty();
}
inline const std::string& DeftypeNode::classname() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.DeftypeNode.className)
  return _internal_classname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeftypeNode::set_classname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.classname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.DeftypeNode.className)
}
inline std::string* DeftypeNode::mutable_classname() {
  std::string* _s = _internal_mutable_classname();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.DeftypeNode.className)
  return _s;
}
inline const std::string& DeftypeNode::_internal_classname() const {
  return _impl_.classname_.Get();
}
inline void DeftypeNode::_internal_set_classname(const std::string& value) {
  
  _impl_.classname_.Set(value, GetArenaForAllocation());
}
inline std::string* DeftypeNode::_internal_mutable_classname() {
  
  return _impl_.classname_.Mutable(GetArenaForAllocation());
}
inline std::string* DeftypeNode::release_classname() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.DeftypeNode.className)
  return _impl_.classname_.Release();
}
inline void DeftypeNode::set_allocated_classname(std::string* classname) {
  if (classname != nullptr) {
    
  } else {
    
  }
  _impl_.classname_.SetAllocated(classname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.classname_.IsDefault()) {
    _impl_.classname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.DeftypeNode.className)
}

// repeated .clojureRT.protobuf.Node fields = 2;
inline int DeftypeNode::_internal_fields_size() const {
  return _impl_.fields_.size();
}
inline int DeftypeNode::fields_size() const {
  return _internal_fields_size();
}
inline void DeftypeNode::clear_fields() {
  _impl_.fields_.Clear();
}
inline ::clojureRT::protobuf::Node* DeftypeNode::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.DeftypeNode.fields)
  return _impl_.fields_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >*
DeftypeNode::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:clojureRT.protobuf.DeftypeNode.fields)
  return &_impl_.fields_;
}
inline const ::clojureRT::protobuf::Node& DeftypeNode::_internal_fields(int index) const {
  return _impl_.fields_.Get(index);
}
inline const ::clojureRT::protobuf::Node& DeftypeNode::fields(int index) const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.DeftypeNode.fields)
  return _internal_fields(index);
}
inline ::clojureRT::protobuf::Node* DeftypeNode::_internal_add_fields() {
  return _impl_.fields_.Add();
}
inline ::clojureRT::protobuf::Node* DeftypeNode::add_fields() {
  ::clojureRT::protobuf::Node* _add = _internal_add_fields();
  // @@protoc_insertion_point(field_add:clojureRT.protobuf.DeftypeNode.fields)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >&
DeftypeNode::fields() const {
  // @@protoc_insertion_point(field_list:clojureRT.protobuf.DeftypeNode.fields)
  return _impl_.fields_;
}

// repeated string interfaces = 3;
inline int DeftypeNode::_internal_interfaces_size() const {
  return _impl_.interfaces_.size();
}
inline int DeftypeNode::interfaces_size() const {
  return _internal_interfaces_size();
}
inline void DeftypeNode::clear_interfaces() {
  _impl_.interfaces_.Clear();
}
inline std::string* DeftypeNode::add_interfaces() {
  std::string* _s = _internal_add_interfaces();
  // @@protoc_insertion_point(field_add_mutable:clojureRT.protobuf.DeftypeNode.interfaces)
  return _s;
}
inline const std::string& DeftypeNode::_internal_interfaces(int index) const {
  return _impl_.interfaces_.Get(index);
}
inline const std::string& DeftypeNode::interfaces(int index) const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.DeftypeNode.interfaces)
  return _internal_interfaces(index);
}
inline std::string* DeftypeNode::mutable_interfaces(int index) {
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.DeftypeNode.interfaces)
  return _impl_.interfaces_.Mutable(index);
}
inline void DeftypeNode::set_interfaces(int index, const std::string& value) {
  _impl_.interfaces_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.DeftypeNode.interfaces)
}
inline void DeftypeNode::set_interfaces(int index, std::string&& value) {
  _impl_.interfaces_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.DeftypeNode.interfaces)
}
inline void DeftypeNode::set_interfaces(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.interfaces_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:clojureRT.protobuf.DeftypeNode.interfaces)
}
inline void DeftypeNode::set_interfaces(int index, const char* value, size_t size) {
  _impl_.interfaces_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:clojureRT.protobuf.DeftypeNode.interfaces)
}
inline std::string* DeftypeNode::_internal_add_interfaces() {
  return _impl_.interfaces_.Add();
}
inline void DeftypeNode::add_interfaces(const std::string& value) {
  _impl_.interfaces_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:clojureRT.protobuf.DeftypeNode.interfaces)
}
inline void DeftypeNode::add_interfaces(std::string&& value) {
  _impl_.interfaces_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:clojureRT.protobuf.DeftypeNode.interfaces)
}
inline void DeftypeNode::add_interfaces(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.interfaces_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:clojureRT.protobuf.DeftypeNode.interfaces)
}
inline void DeftypeNode::add_interfaces(const char* value, size_t size) {
  _impl_.interfaces_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:clojureRT.protobuf.DeftypeNode.interfaces)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DeftypeNode::interfaces() const {
  // @@protoc_insertion_point(field_list:clojureRT.protobuf.DeftypeNode.interfaces)
  return _impl_.interfaces_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DeftypeNode::mutable_interfaces() {
  // @@protoc_insertion_point(field_mutable_list:clojureRT.protobuf.DeftypeNode.interfaces)
  return &_impl_.interfaces_;
}

// repeated .clojureRT.protobuf.Node methods = 4;
inline int DeftypeNode::_internal_methods_size() const {
  return _impl_.methods_.size();
}
inline int DeftypeNode::methods_size() const {
  return _internal_methods_size();
}
inline void DeftypeNode::clear_methods() {
  _impl_.methods_.Clear();
}
inline ::clojureRT::protobuf::Node* DeftypeNode::mutable_methods(int index) {
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.DeftypeNode.methods)
  return _impl_.methods_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >*
DeftypeNode::mutable_methods() {
  // @@protoc_insertion_point(field_mutable_list:clojureRT.protobuf.DeftypeNode.methods)
  return &_impl_.methods_;
}
inline const ::clojureRT::protobuf::Node& DeftypeNode::_internal_methods(int index) const {
  return _impl_.methods_.Get(index);
}
inline const ::clojureRT::protobuf::Node& DeftypeNode::methods(int index) const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.DeftypeNode.methods)
  return _internal_methods(index);
}
inline ::clojureRT::protobuf::Node* DeftypeNode::_internal_add_methods() {
  return _impl_.methods_.Add();
}
inline ::clojureRT::protobuf::Node* DeftypeNode::add_methods() {
  ::clojureRT::protobuf::Node* _add = _internal_add_methods();
  // @@protoc_insertion_point(field_add:clojureRT.protobuf.DeftypeNode.methods)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >&
DeftypeNode::methods() const {
  // @@protoc_insertion_point(field_list:clojureRT.protobuf.DeftypeNode.methods)
  return _impl_.methods_;
}

// string name = 5;
inline void DeftypeNode::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& DeftypeNode::name() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.DeftypeNode.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeftypeNode::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.DeftypeNode.name)
}
inline std::string* DeftypeNode::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.DeftypeNode.name)
  return _s;
}
inline const std::string& DeftypeNode::_internal_name() const {
  return _impl_.name_.Get();
}
inline void DeftypeNode::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* DeftypeNode::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* DeftypeNode::release_name() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.DeftypeNode.name)
  return _impl_.name_.Release();
}
inline void DeftypeNode::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.DeftypeNode.name)
}

// -------------------------------------------------------------------

// DoNode

// optional bool isBody = 1;
inline bool DoNode::_internal_has_isbody() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DoNode::has_isbody() const {
  return _internal_has_isbody();
}
inline void DoNode::clear_isbody() {
  _impl_.isbody_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool DoNode::_internal_isbody() const {
  return _impl_.isbody_;
}
inline bool DoNode::isbody() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.DoNode.isBody)
  return _internal_isbody();
}
inline void DoNode::_internal_set_isbody(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.isbody_ = value;
}
inline void DoNode::set_isbody(bool value) {
  _internal_set_isbody(value);
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.DoNode.isBody)
}

// .clojureRT.protobuf.Node ret = 2;
inline bool DoNode::_internal_has_ret() const {
  return this != internal_default_instance() && _impl_.ret_ != nullptr;
}
inline bool DoNode::has_ret() const {
  return _internal_has_ret();
}
inline void DoNode::clear_ret() {
  if (GetArenaForAllocation() == nullptr && _impl_.ret_ != nullptr) {
    delete _impl_.ret_;
  }
  _impl_.ret_ = nullptr;
}
inline const ::clojureRT::protobuf::Node& DoNode::_internal_ret() const {
  const ::clojureRT::protobuf::Node* p = _impl_.ret_;
  return p != nullptr ? *p : reinterpret_cast<const ::clojureRT::protobuf::Node&>(
      ::clojureRT::protobuf::_Node_default_instance_);
}
inline const ::clojureRT::protobuf::Node& DoNode::ret() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.DoNode.ret)
  return _internal_ret();
}
inline void DoNode::unsafe_arena_set_allocated_ret(
    ::clojureRT::protobuf::Node* ret) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ret_);
  }
  _impl_.ret_ = ret;
  if (ret) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.DoNode.ret)
}
inline ::clojureRT::protobuf::Node* DoNode::release_ret() {
  
  ::clojureRT::protobuf::Node* temp = _impl_.ret_;
  _impl_.ret_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clojureRT::protobuf::Node* DoNode::unsafe_arena_release_ret() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.DoNode.ret)
  
  ::clojureRT::protobuf::Node* temp = _impl_.ret_;
  _impl_.ret_ = nullptr;
  return temp;
}
inline ::clojureRT::protobuf::Node* DoNode::_internal_mutable_ret() {
  
  if (_impl_.ret_ == nullptr) {
    auto* p = CreateMaybeMessage<::clojureRT::protobuf::Node>(GetArenaForAllocation());
    _impl_.ret_ = p;
  }
  return _impl_.ret_;
}
inline ::clojureRT::protobuf::Node* DoNode::mutable_ret() {
  ::clojureRT::protobuf::Node* _msg = _internal_mutable_ret();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.DoNode.ret)
  return _msg;
}
inline void DoNode::set_allocated_ret(::clojureRT::protobuf::Node* ret) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ret_;
  }
  if (ret) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ret);
    if (message_arena != submessage_arena) {
      ret = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ret, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.ret_ = ret;
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.DoNode.ret)
}

// repeated .clojureRT.protobuf.Node statements = 3;
inline int DoNode::_internal_statements_size() const {
  return _impl_.statements_.size();
}
inline int DoNode::statements_size() const {
  return _internal_statements_size();
}
inline void DoNode::clear_statements() {
  _impl_.statements_.Clear();
}
inline ::clojureRT::protobuf::Node* DoNode::mutable_statements(int index) {
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.DoNode.statements)
  return _impl_.statements_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >*
DoNode::mutable_statements() {
  // @@protoc_insertion_point(field_mutable_list:clojureRT.protobuf.DoNode.statements)
  return &_impl_.statements_;
}
inline const ::clojureRT::protobuf::Node& DoNode::_internal_statements(int index) const {
  return _impl_.statements_.Get(index);
}
inline const ::clojureRT::protobuf::Node& DoNode::statements(int index) const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.DoNode.statements)
  return _internal_statements(index);
}
inline ::clojureRT::protobuf::Node* DoNode::_internal_add_statements() {
  return _impl_.statements_.Add();
}
inline ::clojureRT::protobuf::Node* DoNode::add_statements() {
  ::clojureRT::protobuf::Node* _add = _internal_add_statements();
  // @@protoc_insertion_point(field_add:clojureRT.protobuf.DoNode.statements)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >&
DoNode::statements() const {
  // @@protoc_insertion_point(field_list:clojureRT.protobuf.DoNode.statements)
  return _impl_.statements_;
}

// -------------------------------------------------------------------

// FnNode

// optional .clojureRT.protobuf.Node local = 1;
inline bool FnNode::_internal_has_local() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.local_ != nullptr);
  return value;
}
inline bool FnNode::has_local() const {
  return _internal_has_local();
}
inline void FnNode::clear_local() {
  if (_impl_.local_ != nullptr) _impl_.local_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::clojureRT::protobuf::Node& FnNode::_internal_local() const {
  const ::clojureRT::protobuf::Node* p = _impl_.local_;
  return p != nullptr ? *p : reinterpret_cast<const ::clojureRT::protobuf::Node&>(
      ::clojureRT::protobuf::_Node_default_instance_);
}
inline const ::clojureRT::protobuf::Node& FnNode::local() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.FnNode.local)
  return _internal_local();
}
inline void FnNode::unsafe_arena_set_allocated_local(
    ::clojureRT::protobuf::Node* local) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.local_);
  }
  _impl_.local_ = local;
  if (local) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.FnNode.local)
}
inline ::clojureRT::protobuf::Node* FnNode::release_local() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::clojureRT::protobuf::Node* temp = _impl_.local_;
  _impl_.local_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clojureRT::protobuf::Node* FnNode::unsafe_arena_release_local() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.FnNode.local)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::clojureRT::protobuf::Node* temp = _impl_.local_;
  _impl_.local_ = nullptr;
  return temp;
}
inline ::clojureRT::protobuf::Node* FnNode::_internal_mutable_local() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.local_ == nullptr) {
    auto* p = CreateMaybeMessage<::clojureRT::protobuf::Node>(GetArenaForAllocation());
    _impl_.local_ = p;
  }
  return _impl_.local_;
}
inline ::clojureRT::protobuf::Node* FnNode::mutable_local() {
  ::clojureRT::protobuf::Node* _msg = _internal_mutable_local();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.FnNode.local)
  return _msg;
}
inline void FnNode::set_allocated_local(::clojureRT::protobuf::Node* local) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.local_;
  }
  if (local) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(local);
    if (message_arena != submessage_arena) {
      local = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, local, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.local_ = local;
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.FnNode.local)
}

// uint32 maxFixedArity = 2;
inline void FnNode::clear_maxfixedarity() {
  _impl_.maxfixedarity_ = 0u;
}
inline uint32_t FnNode::_internal_maxfixedarity() const {
  return _impl_.maxfixedarity_;
}
inline uint32_t FnNode::maxfixedarity() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.FnNode.maxFixedArity)
  return _internal_maxfixedarity();
}
inline void FnNode::_internal_set_maxfixedarity(uint32_t value) {
  
  _impl_.maxfixedarity_ = value;
}
inline void FnNode::set_maxfixedarity(uint32_t value) {
  _internal_set_maxfixedarity(value);
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.FnNode.maxFixedArity)
}

// repeated .clojureRT.protobuf.Node methods = 3;
inline int FnNode::_internal_methods_size() const {
  return _impl_.methods_.size();
}
inline int FnNode::methods_size() const {
  return _internal_methods_size();
}
inline void FnNode::clear_methods() {
  _impl_.methods_.Clear();
}
inline ::clojureRT::protobuf::Node* FnNode::mutable_methods(int index) {
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.FnNode.methods)
  return _impl_.methods_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >*
FnNode::mutable_methods() {
  // @@protoc_insertion_point(field_mutable_list:clojureRT.protobuf.FnNode.methods)
  return &_impl_.methods_;
}
inline const ::clojureRT::protobuf::Node& FnNode::_internal_methods(int index) const {
  return _impl_.methods_.Get(index);
}
inline const ::clojureRT::protobuf::Node& FnNode::methods(int index) const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.FnNode.methods)
  return _internal_methods(index);
}
inline ::clojureRT::protobuf::Node* FnNode::_internal_add_methods() {
  return _impl_.methods_.Add();
}
inline ::clojureRT::protobuf::Node* FnNode::add_methods() {
  ::clojureRT::protobuf::Node* _add = _internal_add_methods();
  // @@protoc_insertion_point(field_add:clojureRT.protobuf.FnNode.methods)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >&
FnNode::methods() const {
  // @@protoc_insertion_point(field_list:clojureRT.protobuf.FnNode.methods)
  return _impl_.methods_;
}

// bool once = 4;
inline void FnNode::clear_once() {
  _impl_.once_ = false;
}
inline bool FnNode::_internal_once() const {
  return _impl_.once_;
}
inline bool FnNode::once() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.FnNode.once)
  return _internal_once();
}
inline void FnNode::_internal_set_once(bool value) {
  
  _impl_.once_ = value;
}
inline void FnNode::set_once(bool value) {
  _internal_set_once(value);
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.FnNode.once)
}

// bool isVariadic = 5;
inline void FnNode::clear_isvariadic() {
  _impl_.isvariadic_ = false;
}
inline bool FnNode::_internal_isvariadic() const {
  return _impl_.isvariadic_;
}
inline bool FnNode::isvariadic() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.FnNode.isVariadic)
  return _internal_isvariadic();
}
inline void FnNode::_internal_set_isvariadic(bool value) {
  
  _impl_.isvariadic_ = value;
}
inline void FnNode::set_isvariadic(bool value) {
  _internal_set_isvariadic(value);
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.FnNode.isVariadic)
}

// -------------------------------------------------------------------

// FnMethodNode

// .clojureRT.protobuf.Node body = 1;
inline bool FnMethodNode::_internal_has_body() const {
  return this != internal_default_instance() && _impl_.body_ != nullptr;
}
inline bool FnMethodNode::has_body() const {
  return _internal_has_body();
}
inline void FnMethodNode::clear_body() {
  if (GetArenaForAllocation() == nullptr && _impl_.body_ != nullptr) {
    delete _impl_.body_;
  }
  _impl_.body_ = nullptr;
}
inline const ::clojureRT::protobuf::Node& FnMethodNode::_internal_body() const {
  const ::clojureRT::protobuf::Node* p = _impl_.body_;
  return p != nullptr ? *p : reinterpret_cast<const ::clojureRT::protobuf::Node&>(
      ::clojureRT::protobuf::_Node_default_instance_);
}
inline const ::clojureRT::protobuf::Node& FnMethodNode::body() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.FnMethodNode.body)
  return _internal_body();
}
inline void FnMethodNode::unsafe_arena_set_allocated_body(
    ::clojureRT::protobuf::Node* body) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.body_);
  }
  _impl_.body_ = body;
  if (body) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.FnMethodNode.body)
}
inline ::clojureRT::protobuf::Node* FnMethodNode::release_body() {
  
  ::clojureRT::protobuf::Node* temp = _impl_.body_;
  _impl_.body_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clojureRT::protobuf::Node* FnMethodNode::unsafe_arena_release_body() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.FnMethodNode.body)
  
  ::clojureRT::protobuf::Node* temp = _impl_.body_;
  _impl_.body_ = nullptr;
  return temp;
}
inline ::clojureRT::protobuf::Node* FnMethodNode::_internal_mutable_body() {
  
  if (_impl_.body_ == nullptr) {
    auto* p = CreateMaybeMessage<::clojureRT::protobuf::Node>(GetArenaForAllocation());
    _impl_.body_ = p;
  }
  return _impl_.body_;
}
inline ::clojureRT::protobuf::Node* FnMethodNode::mutable_body() {
  ::clojureRT::protobuf::Node* _msg = _internal_mutable_body();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.FnMethodNode.body)
  return _msg;
}
inline void FnMethodNode::set_allocated_body(::clojureRT::protobuf::Node* body) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.body_;
  }
  if (body) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(body);
    if (message_arena != submessage_arena) {
      body = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, body, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.body_ = body;
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.FnMethodNode.body)
}

// uint32 fixedArity = 2;
inline void FnMethodNode::clear_fixedarity() {
  _impl_.fixedarity_ = 0u;
}
inline uint32_t FnMethodNode::_internal_fixedarity() const {
  return _impl_.fixedarity_;
}
inline uint32_t FnMethodNode::fixedarity() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.FnMethodNode.fixedArity)
  return _internal_fixedarity();
}
inline void FnMethodNode::_internal_set_fixedarity(uint32_t value) {
  
  _impl_.fixedarity_ = value;
}
inline void FnMethodNode::set_fixedarity(uint32_t value) {
  _internal_set_fixedarity(value);
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.FnMethodNode.fixedArity)
}

// string loopId = 3;
inline void FnMethodNode::clear_loopid() {
  _impl_.loopid_.ClearToEmpty();
}
inline const std::string& FnMethodNode::loopid() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.FnMethodNode.loopId)
  return _internal_loopid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FnMethodNode::set_loopid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.loopid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.FnMethodNode.loopId)
}
inline std::string* FnMethodNode::mutable_loopid() {
  std::string* _s = _internal_mutable_loopid();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.FnMethodNode.loopId)
  return _s;
}
inline const std::string& FnMethodNode::_internal_loopid() const {
  return _impl_.loopid_.Get();
}
inline void FnMethodNode::_internal_set_loopid(const std::string& value) {
  
  _impl_.loopid_.Set(value, GetArenaForAllocation());
}
inline std::string* FnMethodNode::_internal_mutable_loopid() {
  
  return _impl_.loopid_.Mutable(GetArenaForAllocation());
}
inline std::string* FnMethodNode::release_loopid() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.FnMethodNode.loopId)
  return _impl_.loopid_.Release();
}
inline void FnMethodNode::set_allocated_loopid(std::string* loopid) {
  if (loopid != nullptr) {
    
  } else {
    
  }
  _impl_.loopid_.SetAllocated(loopid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.loopid_.IsDefault()) {
    _impl_.loopid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.FnMethodNode.loopId)
}

// repeated .clojureRT.protobuf.Node params = 4;
inline int FnMethodNode::_internal_params_size() const {
  return _impl_.params_.size();
}
inline int FnMethodNode::params_size() const {
  return _internal_params_size();
}
inline void FnMethodNode::clear_params() {
  _impl_.params_.Clear();
}
inline ::clojureRT::protobuf::Node* FnMethodNode::mutable_params(int index) {
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.FnMethodNode.params)
  return _impl_.params_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >*
FnMethodNode::mutable_params() {
  // @@protoc_insertion_point(field_mutable_list:clojureRT.protobuf.FnMethodNode.params)
  return &_impl_.params_;
}
inline const ::clojureRT::protobuf::Node& FnMethodNode::_internal_params(int index) const {
  return _impl_.params_.Get(index);
}
inline const ::clojureRT::protobuf::Node& FnMethodNode::params(int index) const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.FnMethodNode.params)
  return _internal_params(index);
}
inline ::clojureRT::protobuf::Node* FnMethodNode::_internal_add_params() {
  return _impl_.params_.Add();
}
inline ::clojureRT::protobuf::Node* FnMethodNode::add_params() {
  ::clojureRT::protobuf::Node* _add = _internal_add_params();
  // @@protoc_insertion_point(field_add:clojureRT.protobuf.FnMethodNode.params)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >&
FnMethodNode::params() const {
  // @@protoc_insertion_point(field_list:clojureRT.protobuf.FnMethodNode.params)
  return _impl_.params_;
}

// bool isVariadic = 5;
inline void FnMethodNode::clear_isvariadic() {
  _impl_.isvariadic_ = false;
}
inline bool FnMethodNode::_internal_isvariadic() const {
  return _impl_.isvariadic_;
}
inline bool FnMethodNode::isvariadic() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.FnMethodNode.isVariadic)
  return _internal_isvariadic();
}
inline void FnMethodNode::_internal_set_isvariadic(bool value) {
  
  _impl_.isvariadic_ = value;
}
inline void FnMethodNode::set_isvariadic(bool value) {
  _internal_set_isvariadic(value);
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.FnMethodNode.isVariadic)
}

// -------------------------------------------------------------------

// HostInteropNode

// bool isAssignable = 1;
inline void HostInteropNode::clear_isassignable() {
  _impl_.isassignable_ = false;
}
inline bool HostInteropNode::_internal_isassignable() const {
  return _impl_.isassignable_;
}
inline bool HostInteropNode::isassignable() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.HostInteropNode.isAssignable)
  return _internal_isassignable();
}
inline void HostInteropNode::_internal_set_isassignable(bool value) {
  
  _impl_.isassignable_ = value;
}
inline void HostInteropNode::set_isassignable(bool value) {
  _internal_set_isassignable(value);
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.HostInteropNode.isAssignable)
}

// string mOrF = 2;
inline void HostInteropNode::clear_morf() {
  _impl_.morf_.ClearToEmpty();
}
inline const std::string& HostInteropNode::morf() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.HostInteropNode.mOrF)
  return _internal_morf();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HostInteropNode::set_morf(ArgT0&& arg0, ArgT... args) {
 
 _impl_.morf_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.HostInteropNode.mOrF)
}
inline std::string* HostInteropNode::mutable_morf() {
  std::string* _s = _internal_mutable_morf();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.HostInteropNode.mOrF)
  return _s;
}
inline const std::string& HostInteropNode::_internal_morf() const {
  return _impl_.morf_.Get();
}
inline void HostInteropNode::_internal_set_morf(const std::string& value) {
  
  _impl_.morf_.Set(value, GetArenaForAllocation());
}
inline std::string* HostInteropNode::_internal_mutable_morf() {
  
  return _impl_.morf_.Mutable(GetArenaForAllocation());
}
inline std::string* HostInteropNode::release_morf() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.HostInteropNode.mOrF)
  return _impl_.morf_.Release();
}
inline void HostInteropNode::set_allocated_morf(std::string* morf) {
  if (morf != nullptr) {
    
  } else {
    
  }
  _impl_.morf_.SetAllocated(morf, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.morf_.IsDefault()) {
    _impl_.morf_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.HostInteropNode.mOrF)
}

// .clojureRT.protobuf.Node target = 3;
inline bool HostInteropNode::_internal_has_target() const {
  return this != internal_default_instance() && _impl_.target_ != nullptr;
}
inline bool HostInteropNode::has_target() const {
  return _internal_has_target();
}
inline void HostInteropNode::clear_target() {
  if (GetArenaForAllocation() == nullptr && _impl_.target_ != nullptr) {
    delete _impl_.target_;
  }
  _impl_.target_ = nullptr;
}
inline const ::clojureRT::protobuf::Node& HostInteropNode::_internal_target() const {
  const ::clojureRT::protobuf::Node* p = _impl_.target_;
  return p != nullptr ? *p : reinterpret_cast<const ::clojureRT::protobuf::Node&>(
      ::clojureRT::protobuf::_Node_default_instance_);
}
inline const ::clojureRT::protobuf::Node& HostInteropNode::target() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.HostInteropNode.target)
  return _internal_target();
}
inline void HostInteropNode::unsafe_arena_set_allocated_target(
    ::clojureRT::protobuf::Node* target) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.target_);
  }
  _impl_.target_ = target;
  if (target) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.HostInteropNode.target)
}
inline ::clojureRT::protobuf::Node* HostInteropNode::release_target() {
  
  ::clojureRT::protobuf::Node* temp = _impl_.target_;
  _impl_.target_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clojureRT::protobuf::Node* HostInteropNode::unsafe_arena_release_target() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.HostInteropNode.target)
  
  ::clojureRT::protobuf::Node* temp = _impl_.target_;
  _impl_.target_ = nullptr;
  return temp;
}
inline ::clojureRT::protobuf::Node* HostInteropNode::_internal_mutable_target() {
  
  if (_impl_.target_ == nullptr) {
    auto* p = CreateMaybeMessage<::clojureRT::protobuf::Node>(GetArenaForAllocation());
    _impl_.target_ = p;
  }
  return _impl_.target_;
}
inline ::clojureRT::protobuf::Node* HostInteropNode::mutable_target() {
  ::clojureRT::protobuf::Node* _msg = _internal_mutable_target();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.HostInteropNode.target)
  return _msg;
}
inline void HostInteropNode::set_allocated_target(::clojureRT::protobuf::Node* target) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.target_;
  }
  if (target) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(target);
    if (message_arena != submessage_arena) {
      target = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.target_ = target;
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.HostInteropNode.target)
}

// -------------------------------------------------------------------

// IfNode

// .clojureRT.protobuf.Node else = 1;
inline bool IfNode::_internal_has_else_() const {
  return this != internal_default_instance() && _impl_.else__ != nullptr;
}
inline bool IfNode::has_else_() const {
  return _internal_has_else_();
}
inline void IfNode::clear_else_() {
  if (GetArenaForAllocation() == nullptr && _impl_.else__ != nullptr) {
    delete _impl_.else__;
  }
  _impl_.else__ = nullptr;
}
inline const ::clojureRT::protobuf::Node& IfNode::_internal_else_() const {
  const ::clojureRT::protobuf::Node* p = _impl_.else__;
  return p != nullptr ? *p : reinterpret_cast<const ::clojureRT::protobuf::Node&>(
      ::clojureRT::protobuf::_Node_default_instance_);
}
inline const ::clojureRT::protobuf::Node& IfNode::else_() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.IfNode.else)
  return _internal_else_();
}
inline void IfNode::unsafe_arena_set_allocated_else_(
    ::clojureRT::protobuf::Node* else_) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.else__);
  }
  _impl_.else__ = else_;
  if (else_) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.IfNode.else)
}
inline ::clojureRT::protobuf::Node* IfNode::release_else_() {
  
  ::clojureRT::protobuf::Node* temp = _impl_.else__;
  _impl_.else__ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clojureRT::protobuf::Node* IfNode::unsafe_arena_release_else_() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.IfNode.else)
  
  ::clojureRT::protobuf::Node* temp = _impl_.else__;
  _impl_.else__ = nullptr;
  return temp;
}
inline ::clojureRT::protobuf::Node* IfNode::_internal_mutable_else_() {
  
  if (_impl_.else__ == nullptr) {
    auto* p = CreateMaybeMessage<::clojureRT::protobuf::Node>(GetArenaForAllocation());
    _impl_.else__ = p;
  }
  return _impl_.else__;
}
inline ::clojureRT::protobuf::Node* IfNode::mutable_else_() {
  ::clojureRT::protobuf::Node* _msg = _internal_mutable_else_();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.IfNode.else)
  return _msg;
}
inline void IfNode::set_allocated_else_(::clojureRT::protobuf::Node* else_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.else__;
  }
  if (else_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(else_);
    if (message_arena != submessage_arena) {
      else_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, else_, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.else__ = else_;
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.IfNode.else)
}

// .clojureRT.protobuf.Node test = 2;
inline bool IfNode::_internal_has_test() const {
  return this != internal_default_instance() && _impl_.test_ != nullptr;
}
inline bool IfNode::has_test() const {
  return _internal_has_test();
}
inline void IfNode::clear_test() {
  if (GetArenaForAllocation() == nullptr && _impl_.test_ != nullptr) {
    delete _impl_.test_;
  }
  _impl_.test_ = nullptr;
}
inline const ::clojureRT::protobuf::Node& IfNode::_internal_test() const {
  const ::clojureRT::protobuf::Node* p = _impl_.test_;
  return p != nullptr ? *p : reinterpret_cast<const ::clojureRT::protobuf::Node&>(
      ::clojureRT::protobuf::_Node_default_instance_);
}
inline const ::clojureRT::protobuf::Node& IfNode::test() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.IfNode.test)
  return _internal_test();
}
inline void IfNode::unsafe_arena_set_allocated_test(
    ::clojureRT::protobuf::Node* test) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.test_);
  }
  _impl_.test_ = test;
  if (test) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.IfNode.test)
}
inline ::clojureRT::protobuf::Node* IfNode::release_test() {
  
  ::clojureRT::protobuf::Node* temp = _impl_.test_;
  _impl_.test_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clojureRT::protobuf::Node* IfNode::unsafe_arena_release_test() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.IfNode.test)
  
  ::clojureRT::protobuf::Node* temp = _impl_.test_;
  _impl_.test_ = nullptr;
  return temp;
}
inline ::clojureRT::protobuf::Node* IfNode::_internal_mutable_test() {
  
  if (_impl_.test_ == nullptr) {
    auto* p = CreateMaybeMessage<::clojureRT::protobuf::Node>(GetArenaForAllocation());
    _impl_.test_ = p;
  }
  return _impl_.test_;
}
inline ::clojureRT::protobuf::Node* IfNode::mutable_test() {
  ::clojureRT::protobuf::Node* _msg = _internal_mutable_test();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.IfNode.test)
  return _msg;
}
inline void IfNode::set_allocated_test(::clojureRT::protobuf::Node* test) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.test_;
  }
  if (test) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(test);
    if (message_arena != submessage_arena) {
      test = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, test, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.test_ = test;
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.IfNode.test)
}

// .clojureRT.protobuf.Node then = 3;
inline bool IfNode::_internal_has_then() const {
  return this != internal_default_instance() && _impl_.then_ != nullptr;
}
inline bool IfNode::has_then() const {
  return _internal_has_then();
}
inline void IfNode::clear_then() {
  if (GetArenaForAllocation() == nullptr && _impl_.then_ != nullptr) {
    delete _impl_.then_;
  }
  _impl_.then_ = nullptr;
}
inline const ::clojureRT::protobuf::Node& IfNode::_internal_then() const {
  const ::clojureRT::protobuf::Node* p = _impl_.then_;
  return p != nullptr ? *p : reinterpret_cast<const ::clojureRT::protobuf::Node&>(
      ::clojureRT::protobuf::_Node_default_instance_);
}
inline const ::clojureRT::protobuf::Node& IfNode::then() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.IfNode.then)
  return _internal_then();
}
inline void IfNode::unsafe_arena_set_allocated_then(
    ::clojureRT::protobuf::Node* then) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.then_);
  }
  _impl_.then_ = then;
  if (then) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.IfNode.then)
}
inline ::clojureRT::protobuf::Node* IfNode::release_then() {
  
  ::clojureRT::protobuf::Node* temp = _impl_.then_;
  _impl_.then_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clojureRT::protobuf::Node* IfNode::unsafe_arena_release_then() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.IfNode.then)
  
  ::clojureRT::protobuf::Node* temp = _impl_.then_;
  _impl_.then_ = nullptr;
  return temp;
}
inline ::clojureRT::protobuf::Node* IfNode::_internal_mutable_then() {
  
  if (_impl_.then_ == nullptr) {
    auto* p = CreateMaybeMessage<::clojureRT::protobuf::Node>(GetArenaForAllocation());
    _impl_.then_ = p;
  }
  return _impl_.then_;
}
inline ::clojureRT::protobuf::Node* IfNode::mutable_then() {
  ::clojureRT::protobuf::Node* _msg = _internal_mutable_then();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.IfNode.then)
  return _msg;
}
inline void IfNode::set_allocated_then(::clojureRT::protobuf::Node* then) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.then_;
  }
  if (then) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(then);
    if (message_arena != submessage_arena) {
      then = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, then, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.then_ = then;
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.IfNode.then)
}

// -------------------------------------------------------------------

// ImportNode

// string class = 1;
inline void ImportNode::clear_class_() {
  _impl_.class__.ClearToEmpty();
}
inline const std::string& ImportNode::class_() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.ImportNode.class)
  return _internal_class_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImportNode::set_class_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.class__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.ImportNode.class)
}
inline std::string* ImportNode::mutable_class_() {
  std::string* _s = _internal_mutable_class_();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.ImportNode.class)
  return _s;
}
inline const std::string& ImportNode::_internal_class_() const {
  return _impl_.class__.Get();
}
inline void ImportNode::_internal_set_class_(const std::string& value) {
  
  _impl_.class__.Set(value, GetArenaForAllocation());
}
inline std::string* ImportNode::_internal_mutable_class_() {
  
  return _impl_.class__.Mutable(GetArenaForAllocation());
}
inline std::string* ImportNode::release_class_() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.ImportNode.class)
  return _impl_.class__.Release();
}
inline void ImportNode::set_allocated_class_(std::string* class_) {
  if (class_ != nullptr) {
    
  } else {
    
  }
  _impl_.class__.SetAllocated(class_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.class__.IsDefault()) {
    _impl_.class__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.ImportNode.class)
}

// -------------------------------------------------------------------

// InstanceCallNode

// repeated .clojureRT.protobuf.Node args = 1;
inline int InstanceCallNode::_internal_args_size() const {
  return _impl_.args_.size();
}
inline int InstanceCallNode::args_size() const {
  return _internal_args_size();
}
inline void InstanceCallNode::clear_args() {
  _impl_.args_.Clear();
}
inline ::clojureRT::protobuf::Node* InstanceCallNode::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.InstanceCallNode.args)
  return _impl_.args_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >*
InstanceCallNode::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:clojureRT.protobuf.InstanceCallNode.args)
  return &_impl_.args_;
}
inline const ::clojureRT::protobuf::Node& InstanceCallNode::_internal_args(int index) const {
  return _impl_.args_.Get(index);
}
inline const ::clojureRT::protobuf::Node& InstanceCallNode::args(int index) const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.InstanceCallNode.args)
  return _internal_args(index);
}
inline ::clojureRT::protobuf::Node* InstanceCallNode::_internal_add_args() {
  return _impl_.args_.Add();
}
inline ::clojureRT::protobuf::Node* InstanceCallNode::add_args() {
  ::clojureRT::protobuf::Node* _add = _internal_add_args();
  // @@protoc_insertion_point(field_add:clojureRT.protobuf.InstanceCallNode.args)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >&
InstanceCallNode::args() const {
  // @@protoc_insertion_point(field_list:clojureRT.protobuf.InstanceCallNode.args)
  return _impl_.args_;
}

// optional string class = 2;
inline bool InstanceCallNode::_internal_has_class_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool InstanceCallNode::has_class_() const {
  return _internal_has_class_();
}
inline void InstanceCallNode::clear_class_() {
  _impl_.class__.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& InstanceCallNode::class_() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.InstanceCallNode.class)
  return _internal_class_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InstanceCallNode::set_class_(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.class__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.InstanceCallNode.class)
}
inline std::string* InstanceCallNode::mutable_class_() {
  std::string* _s = _internal_mutable_class_();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.InstanceCallNode.class)
  return _s;
}
inline const std::string& InstanceCallNode::_internal_class_() const {
  return _impl_.class__.Get();
}
inline void InstanceCallNode::_internal_set_class_(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.class__.Set(value, GetArenaForAllocation());
}
inline std::string* InstanceCallNode::_internal_mutable_class_() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.class__.Mutable(GetArenaForAllocation());
}
inline std::string* InstanceCallNode::release_class_() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.InstanceCallNode.class)
  if (!_internal_has_class_()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.class__.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.class__.IsDefault()) {
    _impl_.class__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InstanceCallNode::set_allocated_class_(std::string* class_) {
  if (class_ != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.class__.SetAllocated(class_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.class__.IsDefault()) {
    _impl_.class__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.InstanceCallNode.class)
}

// .clojureRT.protobuf.Node instance = 3;
inline bool InstanceCallNode::_internal_has_instance() const {
  return this != internal_default_instance() && _impl_.instance_ != nullptr;
}
inline bool InstanceCallNode::has_instance() const {
  return _internal_has_instance();
}
inline void InstanceCallNode::clear_instance() {
  if (GetArenaForAllocation() == nullptr && _impl_.instance_ != nullptr) {
    delete _impl_.instance_;
  }
  _impl_.instance_ = nullptr;
}
inline const ::clojureRT::protobuf::Node& InstanceCallNode::_internal_instance() const {
  const ::clojureRT::protobuf::Node* p = _impl_.instance_;
  return p != nullptr ? *p : reinterpret_cast<const ::clojureRT::protobuf::Node&>(
      ::clojureRT::protobuf::_Node_default_instance_);
}
inline const ::clojureRT::protobuf::Node& InstanceCallNode::instance() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.InstanceCallNode.instance)
  return _internal_instance();
}
inline void InstanceCallNode::unsafe_arena_set_allocated_instance(
    ::clojureRT::protobuf::Node* instance) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.instance_);
  }
  _impl_.instance_ = instance;
  if (instance) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.InstanceCallNode.instance)
}
inline ::clojureRT::protobuf::Node* InstanceCallNode::release_instance() {
  
  ::clojureRT::protobuf::Node* temp = _impl_.instance_;
  _impl_.instance_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clojureRT::protobuf::Node* InstanceCallNode::unsafe_arena_release_instance() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.InstanceCallNode.instance)
  
  ::clojureRT::protobuf::Node* temp = _impl_.instance_;
  _impl_.instance_ = nullptr;
  return temp;
}
inline ::clojureRT::protobuf::Node* InstanceCallNode::_internal_mutable_instance() {
  
  if (_impl_.instance_ == nullptr) {
    auto* p = CreateMaybeMessage<::clojureRT::protobuf::Node>(GetArenaForAllocation());
    _impl_.instance_ = p;
  }
  return _impl_.instance_;
}
inline ::clojureRT::protobuf::Node* InstanceCallNode::mutable_instance() {
  ::clojureRT::protobuf::Node* _msg = _internal_mutable_instance();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.InstanceCallNode.instance)
  return _msg;
}
inline void InstanceCallNode::set_allocated_instance(::clojureRT::protobuf::Node* instance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.instance_;
  }
  if (instance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(instance);
    if (message_arena != submessage_arena) {
      instance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, instance, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.instance_ = instance;
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.InstanceCallNode.instance)
}

// string method = 4;
inline void InstanceCallNode::clear_method() {
  _impl_.method_.ClearToEmpty();
}
inline const std::string& InstanceCallNode::method() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.InstanceCallNode.method)
  return _internal_method();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InstanceCallNode::set_method(ArgT0&& arg0, ArgT... args) {
 
 _impl_.method_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.InstanceCallNode.method)
}
inline std::string* InstanceCallNode::mutable_method() {
  std::string* _s = _internal_mutable_method();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.InstanceCallNode.method)
  return _s;
}
inline const std::string& InstanceCallNode::_internal_method() const {
  return _impl_.method_.Get();
}
inline void InstanceCallNode::_internal_set_method(const std::string& value) {
  
  _impl_.method_.Set(value, GetArenaForAllocation());
}
inline std::string* InstanceCallNode::_internal_mutable_method() {
  
  return _impl_.method_.Mutable(GetArenaForAllocation());
}
inline std::string* InstanceCallNode::release_method() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.InstanceCallNode.method)
  return _impl_.method_.Release();
}
inline void InstanceCallNode::set_allocated_method(std::string* method) {
  if (method != nullptr) {
    
  } else {
    
  }
  _impl_.method_.SetAllocated(method, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.method_.IsDefault()) {
    _impl_.method_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.InstanceCallNode.method)
}

// optional bool isValidated = 5;
inline bool InstanceCallNode::_internal_has_isvalidated() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool InstanceCallNode::has_isvalidated() const {
  return _internal_has_isvalidated();
}
inline void InstanceCallNode::clear_isvalidated() {
  _impl_.isvalidated_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool InstanceCallNode::_internal_isvalidated() const {
  return _impl_.isvalidated_;
}
inline bool InstanceCallNode::isvalidated() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.InstanceCallNode.isValidated)
  return _internal_isvalidated();
}
inline void InstanceCallNode::_internal_set_isvalidated(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.isvalidated_ = value;
}
inline void InstanceCallNode::set_isvalidated(bool value) {
  _internal_set_isvalidated(value);
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.InstanceCallNode.isValidated)
}

// -------------------------------------------------------------------

// InstanceFieldNode

// bool isAssignable = 1;
inline void InstanceFieldNode::clear_isassignable() {
  _impl_.isassignable_ = false;
}
inline bool InstanceFieldNode::_internal_isassignable() const {
  return _impl_.isassignable_;
}
inline bool InstanceFieldNode::isassignable() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.InstanceFieldNode.isAssignable)
  return _internal_isassignable();
}
inline void InstanceFieldNode::_internal_set_isassignable(bool value) {
  
  _impl_.isassignable_ = value;
}
inline void InstanceFieldNode::set_isassignable(bool value) {
  _internal_set_isassignable(value);
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.InstanceFieldNode.isAssignable)
}

// string class = 2;
inline void InstanceFieldNode::clear_class_() {
  _impl_.class__.ClearToEmpty();
}
inline const std::string& InstanceFieldNode::class_() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.InstanceFieldNode.class)
  return _internal_class_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InstanceFieldNode::set_class_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.class__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.InstanceFieldNode.class)
}
inline std::string* InstanceFieldNode::mutable_class_() {
  std::string* _s = _internal_mutable_class_();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.InstanceFieldNode.class)
  return _s;
}
inline const std::string& InstanceFieldNode::_internal_class_() const {
  return _impl_.class__.Get();
}
inline void InstanceFieldNode::_internal_set_class_(const std::string& value) {
  
  _impl_.class__.Set(value, GetArenaForAllocation());
}
inline std::string* InstanceFieldNode::_internal_mutable_class_() {
  
  return _impl_.class__.Mutable(GetArenaForAllocation());
}
inline std::string* InstanceFieldNode::release_class_() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.InstanceFieldNode.class)
  return _impl_.class__.Release();
}
inline void InstanceFieldNode::set_allocated_class_(std::string* class_) {
  if (class_ != nullptr) {
    
  } else {
    
  }
  _impl_.class__.SetAllocated(class_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.class__.IsDefault()) {
    _impl_.class__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.InstanceFieldNode.class)
}

// string field = 3;
inline void InstanceFieldNode::clear_field() {
  _impl_.field_.ClearToEmpty();
}
inline const std::string& InstanceFieldNode::field() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.InstanceFieldNode.field)
  return _internal_field();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InstanceFieldNode::set_field(ArgT0&& arg0, ArgT... args) {
 
 _impl_.field_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.InstanceFieldNode.field)
}
inline std::string* InstanceFieldNode::mutable_field() {
  std::string* _s = _internal_mutable_field();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.InstanceFieldNode.field)
  return _s;
}
inline const std::string& InstanceFieldNode::_internal_field() const {
  return _impl_.field_.Get();
}
inline void InstanceFieldNode::_internal_set_field(const std::string& value) {
  
  _impl_.field_.Set(value, GetArenaForAllocation());
}
inline std::string* InstanceFieldNode::_internal_mutable_field() {
  
  return _impl_.field_.Mutable(GetArenaForAllocation());
}
inline std::string* InstanceFieldNode::release_field() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.InstanceFieldNode.field)
  return _impl_.field_.Release();
}
inline void InstanceFieldNode::set_allocated_field(std::string* field) {
  if (field != nullptr) {
    
  } else {
    
  }
  _impl_.field_.SetAllocated(field, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field_.IsDefault()) {
    _impl_.field_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.InstanceFieldNode.field)
}

// .clojureRT.protobuf.Node instance = 4;
inline bool InstanceFieldNode::_internal_has_instance() const {
  return this != internal_default_instance() && _impl_.instance_ != nullptr;
}
inline bool InstanceFieldNode::has_instance() const {
  return _internal_has_instance();
}
inline void InstanceFieldNode::clear_instance() {
  if (GetArenaForAllocation() == nullptr && _impl_.instance_ != nullptr) {
    delete _impl_.instance_;
  }
  _impl_.instance_ = nullptr;
}
inline const ::clojureRT::protobuf::Node& InstanceFieldNode::_internal_instance() const {
  const ::clojureRT::protobuf::Node* p = _impl_.instance_;
  return p != nullptr ? *p : reinterpret_cast<const ::clojureRT::protobuf::Node&>(
      ::clojureRT::protobuf::_Node_default_instance_);
}
inline const ::clojureRT::protobuf::Node& InstanceFieldNode::instance() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.InstanceFieldNode.instance)
  return _internal_instance();
}
inline void InstanceFieldNode::unsafe_arena_set_allocated_instance(
    ::clojureRT::protobuf::Node* instance) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.instance_);
  }
  _impl_.instance_ = instance;
  if (instance) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.InstanceFieldNode.instance)
}
inline ::clojureRT::protobuf::Node* InstanceFieldNode::release_instance() {
  
  ::clojureRT::protobuf::Node* temp = _impl_.instance_;
  _impl_.instance_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clojureRT::protobuf::Node* InstanceFieldNode::unsafe_arena_release_instance() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.InstanceFieldNode.instance)
  
  ::clojureRT::protobuf::Node* temp = _impl_.instance_;
  _impl_.instance_ = nullptr;
  return temp;
}
inline ::clojureRT::protobuf::Node* InstanceFieldNode::_internal_mutable_instance() {
  
  if (_impl_.instance_ == nullptr) {
    auto* p = CreateMaybeMessage<::clojureRT::protobuf::Node>(GetArenaForAllocation());
    _impl_.instance_ = p;
  }
  return _impl_.instance_;
}
inline ::clojureRT::protobuf::Node* InstanceFieldNode::mutable_instance() {
  ::clojureRT::protobuf::Node* _msg = _internal_mutable_instance();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.InstanceFieldNode.instance)
  return _msg;
}
inline void InstanceFieldNode::set_allocated_instance(::clojureRT::protobuf::Node* instance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.instance_;
  }
  if (instance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(instance);
    if (message_arena != submessage_arena) {
      instance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, instance, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.instance_ = instance;
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.InstanceFieldNode.instance)
}

// -------------------------------------------------------------------

// IsInstanceNode

// string class = 1;
inline void IsInstanceNode::clear_class_() {
  _impl_.class__.ClearToEmpty();
}
inline const std::string& IsInstanceNode::class_() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.IsInstanceNode.class)
  return _internal_class_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IsInstanceNode::set_class_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.class__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.IsInstanceNode.class)
}
inline std::string* IsInstanceNode::mutable_class_() {
  std::string* _s = _internal_mutable_class_();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.IsInstanceNode.class)
  return _s;
}
inline const std::string& IsInstanceNode::_internal_class_() const {
  return _impl_.class__.Get();
}
inline void IsInstanceNode::_internal_set_class_(const std::string& value) {
  
  _impl_.class__.Set(value, GetArenaForAllocation());
}
inline std::string* IsInstanceNode::_internal_mutable_class_() {
  
  return _impl_.class__.Mutable(GetArenaForAllocation());
}
inline std::string* IsInstanceNode::release_class_() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.IsInstanceNode.class)
  return _impl_.class__.Release();
}
inline void IsInstanceNode::set_allocated_class_(std::string* class_) {
  if (class_ != nullptr) {
    
  } else {
    
  }
  _impl_.class__.SetAllocated(class_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.class__.IsDefault()) {
    _impl_.class__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.IsInstanceNode.class)
}

// .clojureRT.protobuf.Node target = 2;
inline bool IsInstanceNode::_internal_has_target() const {
  return this != internal_default_instance() && _impl_.target_ != nullptr;
}
inline bool IsInstanceNode::has_target() const {
  return _internal_has_target();
}
inline void IsInstanceNode::clear_target() {
  if (GetArenaForAllocation() == nullptr && _impl_.target_ != nullptr) {
    delete _impl_.target_;
  }
  _impl_.target_ = nullptr;
}
inline const ::clojureRT::protobuf::Node& IsInstanceNode::_internal_target() const {
  const ::clojureRT::protobuf::Node* p = _impl_.target_;
  return p != nullptr ? *p : reinterpret_cast<const ::clojureRT::protobuf::Node&>(
      ::clojureRT::protobuf::_Node_default_instance_);
}
inline const ::clojureRT::protobuf::Node& IsInstanceNode::target() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.IsInstanceNode.target)
  return _internal_target();
}
inline void IsInstanceNode::unsafe_arena_set_allocated_target(
    ::clojureRT::protobuf::Node* target) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.target_);
  }
  _impl_.target_ = target;
  if (target) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.IsInstanceNode.target)
}
inline ::clojureRT::protobuf::Node* IsInstanceNode::release_target() {
  
  ::clojureRT::protobuf::Node* temp = _impl_.target_;
  _impl_.target_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clojureRT::protobuf::Node* IsInstanceNode::unsafe_arena_release_target() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.IsInstanceNode.target)
  
  ::clojureRT::protobuf::Node* temp = _impl_.target_;
  _impl_.target_ = nullptr;
  return temp;
}
inline ::clojureRT::protobuf::Node* IsInstanceNode::_internal_mutable_target() {
  
  if (_impl_.target_ == nullptr) {
    auto* p = CreateMaybeMessage<::clojureRT::protobuf::Node>(GetArenaForAllocation());
    _impl_.target_ = p;
  }
  return _impl_.target_;
}
inline ::clojureRT::protobuf::Node* IsInstanceNode::mutable_target() {
  ::clojureRT::protobuf::Node* _msg = _internal_mutable_target();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.IsInstanceNode.target)
  return _msg;
}
inline void IsInstanceNode::set_allocated_target(::clojureRT::protobuf::Node* target) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.target_;
  }
  if (target) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(target);
    if (message_arena != submessage_arena) {
      target = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.target_ = target;
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.IsInstanceNode.target)
}

// -------------------------------------------------------------------

// InvokeNode

// repeated .clojureRT.protobuf.Node args = 1;
inline int InvokeNode::_internal_args_size() const {
  return _impl_.args_.size();
}
inline int InvokeNode::args_size() const {
  return _internal_args_size();
}
inline void InvokeNode::clear_args() {
  _impl_.args_.Clear();
}
inline ::clojureRT::protobuf::Node* InvokeNode::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.InvokeNode.args)
  return _impl_.args_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >*
InvokeNode::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:clojureRT.protobuf.InvokeNode.args)
  return &_impl_.args_;
}
inline const ::clojureRT::protobuf::Node& InvokeNode::_internal_args(int index) const {
  return _impl_.args_.Get(index);
}
inline const ::clojureRT::protobuf::Node& InvokeNode::args(int index) const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.InvokeNode.args)
  return _internal_args(index);
}
inline ::clojureRT::protobuf::Node* InvokeNode::_internal_add_args() {
  return _impl_.args_.Add();
}
inline ::clojureRT::protobuf::Node* InvokeNode::add_args() {
  ::clojureRT::protobuf::Node* _add = _internal_add_args();
  // @@protoc_insertion_point(field_add:clojureRT.protobuf.InvokeNode.args)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >&
InvokeNode::args() const {
  // @@protoc_insertion_point(field_list:clojureRT.protobuf.InvokeNode.args)
  return _impl_.args_;
}

// .clojureRT.protobuf.Node fn = 2;
inline bool InvokeNode::_internal_has_fn() const {
  return this != internal_default_instance() && _impl_.fn_ != nullptr;
}
inline bool InvokeNode::has_fn() const {
  return _internal_has_fn();
}
inline void InvokeNode::clear_fn() {
  if (GetArenaForAllocation() == nullptr && _impl_.fn_ != nullptr) {
    delete _impl_.fn_;
  }
  _impl_.fn_ = nullptr;
}
inline const ::clojureRT::protobuf::Node& InvokeNode::_internal_fn() const {
  const ::clojureRT::protobuf::Node* p = _impl_.fn_;
  return p != nullptr ? *p : reinterpret_cast<const ::clojureRT::protobuf::Node&>(
      ::clojureRT::protobuf::_Node_default_instance_);
}
inline const ::clojureRT::protobuf::Node& InvokeNode::fn() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.InvokeNode.fn)
  return _internal_fn();
}
inline void InvokeNode::unsafe_arena_set_allocated_fn(
    ::clojureRT::protobuf::Node* fn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fn_);
  }
  _impl_.fn_ = fn;
  if (fn) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.InvokeNode.fn)
}
inline ::clojureRT::protobuf::Node* InvokeNode::release_fn() {
  
  ::clojureRT::protobuf::Node* temp = _impl_.fn_;
  _impl_.fn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clojureRT::protobuf::Node* InvokeNode::unsafe_arena_release_fn() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.InvokeNode.fn)
  
  ::clojureRT::protobuf::Node* temp = _impl_.fn_;
  _impl_.fn_ = nullptr;
  return temp;
}
inline ::clojureRT::protobuf::Node* InvokeNode::_internal_mutable_fn() {
  
  if (_impl_.fn_ == nullptr) {
    auto* p = CreateMaybeMessage<::clojureRT::protobuf::Node>(GetArenaForAllocation());
    _impl_.fn_ = p;
  }
  return _impl_.fn_;
}
inline ::clojureRT::protobuf::Node* InvokeNode::mutable_fn() {
  ::clojureRT::protobuf::Node* _msg = _internal_mutable_fn();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.InvokeNode.fn)
  return _msg;
}
inline void InvokeNode::set_allocated_fn(::clojureRT::protobuf::Node* fn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.fn_;
  }
  if (fn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fn);
    if (message_arena != submessage_arena) {
      fn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fn, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.fn_ = fn;
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.InvokeNode.fn)
}

// optional string meta = 3;
inline bool InvokeNode::_internal_has_meta() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool InvokeNode::has_meta() const {
  return _internal_has_meta();
}
inline void InvokeNode::clear_meta() {
  _impl_.meta_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& InvokeNode::meta() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.InvokeNode.meta)
  return _internal_meta();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvokeNode::set_meta(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.meta_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.InvokeNode.meta)
}
inline std::string* InvokeNode::mutable_meta() {
  std::string* _s = _internal_mutable_meta();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.InvokeNode.meta)
  return _s;
}
inline const std::string& InvokeNode::_internal_meta() const {
  return _impl_.meta_.Get();
}
inline void InvokeNode::_internal_set_meta(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.meta_.Set(value, GetArenaForAllocation());
}
inline std::string* InvokeNode::_internal_mutable_meta() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.meta_.Mutable(GetArenaForAllocation());
}
inline std::string* InvokeNode::release_meta() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.InvokeNode.meta)
  if (!_internal_has_meta()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.meta_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.meta_.IsDefault()) {
    _impl_.meta_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InvokeNode::set_allocated_meta(std::string* meta) {
  if (meta != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.meta_.SetAllocated(meta, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.meta_.IsDefault()) {
    _impl_.meta_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.InvokeNode.meta)
}

// -------------------------------------------------------------------

// KeywordInvokeNode

// .clojureRT.protobuf.Node keyword = 1;
inline bool KeywordInvokeNode::_internal_has_keyword() const {
  return this != internal_default_instance() && _impl_.keyword_ != nullptr;
}
inline bool KeywordInvokeNode::has_keyword() const {
  return _internal_has_keyword();
}
inline void KeywordInvokeNode::clear_keyword() {
  if (GetArenaForAllocation() == nullptr && _impl_.keyword_ != nullptr) {
    delete _impl_.keyword_;
  }
  _impl_.keyword_ = nullptr;
}
inline const ::clojureRT::protobuf::Node& KeywordInvokeNode::_internal_keyword() const {
  const ::clojureRT::protobuf::Node* p = _impl_.keyword_;
  return p != nullptr ? *p : reinterpret_cast<const ::clojureRT::protobuf::Node&>(
      ::clojureRT::protobuf::_Node_default_instance_);
}
inline const ::clojureRT::protobuf::Node& KeywordInvokeNode::keyword() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.KeywordInvokeNode.keyword)
  return _internal_keyword();
}
inline void KeywordInvokeNode::unsafe_arena_set_allocated_keyword(
    ::clojureRT::protobuf::Node* keyword) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.keyword_);
  }
  _impl_.keyword_ = keyword;
  if (keyword) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.KeywordInvokeNode.keyword)
}
inline ::clojureRT::protobuf::Node* KeywordInvokeNode::release_keyword() {
  
  ::clojureRT::protobuf::Node* temp = _impl_.keyword_;
  _impl_.keyword_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clojureRT::protobuf::Node* KeywordInvokeNode::unsafe_arena_release_keyword() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.KeywordInvokeNode.keyword)
  
  ::clojureRT::protobuf::Node* temp = _impl_.keyword_;
  _impl_.keyword_ = nullptr;
  return temp;
}
inline ::clojureRT::protobuf::Node* KeywordInvokeNode::_internal_mutable_keyword() {
  
  if (_impl_.keyword_ == nullptr) {
    auto* p = CreateMaybeMessage<::clojureRT::protobuf::Node>(GetArenaForAllocation());
    _impl_.keyword_ = p;
  }
  return _impl_.keyword_;
}
inline ::clojureRT::protobuf::Node* KeywordInvokeNode::mutable_keyword() {
  ::clojureRT::protobuf::Node* _msg = _internal_mutable_keyword();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.KeywordInvokeNode.keyword)
  return _msg;
}
inline void KeywordInvokeNode::set_allocated_keyword(::clojureRT::protobuf::Node* keyword) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.keyword_;
  }
  if (keyword) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(keyword);
    if (message_arena != submessage_arena) {
      keyword = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, keyword, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.keyword_ = keyword;
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.KeywordInvokeNode.keyword)
}

// .clojureRT.protobuf.Node target = 2;
inline bool KeywordInvokeNode::_internal_has_target() const {
  return this != internal_default_instance() && _impl_.target_ != nullptr;
}
inline bool KeywordInvokeNode::has_target() const {
  return _internal_has_target();
}
inline void KeywordInvokeNode::clear_target() {
  if (GetArenaForAllocation() == nullptr && _impl_.target_ != nullptr) {
    delete _impl_.target_;
  }
  _impl_.target_ = nullptr;
}
inline const ::clojureRT::protobuf::Node& KeywordInvokeNode::_internal_target() const {
  const ::clojureRT::protobuf::Node* p = _impl_.target_;
  return p != nullptr ? *p : reinterpret_cast<const ::clojureRT::protobuf::Node&>(
      ::clojureRT::protobuf::_Node_default_instance_);
}
inline const ::clojureRT::protobuf::Node& KeywordInvokeNode::target() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.KeywordInvokeNode.target)
  return _internal_target();
}
inline void KeywordInvokeNode::unsafe_arena_set_allocated_target(
    ::clojureRT::protobuf::Node* target) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.target_);
  }
  _impl_.target_ = target;
  if (target) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.KeywordInvokeNode.target)
}
inline ::clojureRT::protobuf::Node* KeywordInvokeNode::release_target() {
  
  ::clojureRT::protobuf::Node* temp = _impl_.target_;
  _impl_.target_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clojureRT::protobuf::Node* KeywordInvokeNode::unsafe_arena_release_target() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.KeywordInvokeNode.target)
  
  ::clojureRT::protobuf::Node* temp = _impl_.target_;
  _impl_.target_ = nullptr;
  return temp;
}
inline ::clojureRT::protobuf::Node* KeywordInvokeNode::_internal_mutable_target() {
  
  if (_impl_.target_ == nullptr) {
    auto* p = CreateMaybeMessage<::clojureRT::protobuf::Node>(GetArenaForAllocation());
    _impl_.target_ = p;
  }
  return _impl_.target_;
}
inline ::clojureRT::protobuf::Node* KeywordInvokeNode::mutable_target() {
  ::clojureRT::protobuf::Node* _msg = _internal_mutable_target();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.KeywordInvokeNode.target)
  return _msg;
}
inline void KeywordInvokeNode::set_allocated_target(::clojureRT::protobuf::Node* target) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.target_;
  }
  if (target) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(target);
    if (message_arena != submessage_arena) {
      target = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.target_ = target;
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.KeywordInvokeNode.target)
}

// -------------------------------------------------------------------

// LetNode

// repeated .clojureRT.protobuf.Node bindings = 1;
inline int LetNode::_internal_bindings_size() const {
  return _impl_.bindings_.size();
}
inline int LetNode::bindings_size() const {
  return _internal_bindings_size();
}
inline void LetNode::clear_bindings() {
  _impl_.bindings_.Clear();
}
inline ::clojureRT::protobuf::Node* LetNode::mutable_bindings(int index) {
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.LetNode.bindings)
  return _impl_.bindings_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >*
LetNode::mutable_bindings() {
  // @@protoc_insertion_point(field_mutable_list:clojureRT.protobuf.LetNode.bindings)
  return &_impl_.bindings_;
}
inline const ::clojureRT::protobuf::Node& LetNode::_internal_bindings(int index) const {
  return _impl_.bindings_.Get(index);
}
inline const ::clojureRT::protobuf::Node& LetNode::bindings(int index) const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.LetNode.bindings)
  return _internal_bindings(index);
}
inline ::clojureRT::protobuf::Node* LetNode::_internal_add_bindings() {
  return _impl_.bindings_.Add();
}
inline ::clojureRT::protobuf::Node* LetNode::add_bindings() {
  ::clojureRT::protobuf::Node* _add = _internal_add_bindings();
  // @@protoc_insertion_point(field_add:clojureRT.protobuf.LetNode.bindings)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >&
LetNode::bindings() const {
  // @@protoc_insertion_point(field_list:clojureRT.protobuf.LetNode.bindings)
  return _impl_.bindings_;
}

// .clojureRT.protobuf.Node body = 2;
inline bool LetNode::_internal_has_body() const {
  return this != internal_default_instance() && _impl_.body_ != nullptr;
}
inline bool LetNode::has_body() const {
  return _internal_has_body();
}
inline void LetNode::clear_body() {
  if (GetArenaForAllocation() == nullptr && _impl_.body_ != nullptr) {
    delete _impl_.body_;
  }
  _impl_.body_ = nullptr;
}
inline const ::clojureRT::protobuf::Node& LetNode::_internal_body() const {
  const ::clojureRT::protobuf::Node* p = _impl_.body_;
  return p != nullptr ? *p : reinterpret_cast<const ::clojureRT::protobuf::Node&>(
      ::clojureRT::protobuf::_Node_default_instance_);
}
inline const ::clojureRT::protobuf::Node& LetNode::body() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.LetNode.body)
  return _internal_body();
}
inline void LetNode::unsafe_arena_set_allocated_body(
    ::clojureRT::protobuf::Node* body) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.body_);
  }
  _impl_.body_ = body;
  if (body) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.LetNode.body)
}
inline ::clojureRT::protobuf::Node* LetNode::release_body() {
  
  ::clojureRT::protobuf::Node* temp = _impl_.body_;
  _impl_.body_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clojureRT::protobuf::Node* LetNode::unsafe_arena_release_body() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.LetNode.body)
  
  ::clojureRT::protobuf::Node* temp = _impl_.body_;
  _impl_.body_ = nullptr;
  return temp;
}
inline ::clojureRT::protobuf::Node* LetNode::_internal_mutable_body() {
  
  if (_impl_.body_ == nullptr) {
    auto* p = CreateMaybeMessage<::clojureRT::protobuf::Node>(GetArenaForAllocation());
    _impl_.body_ = p;
  }
  return _impl_.body_;
}
inline ::clojureRT::protobuf::Node* LetNode::mutable_body() {
  ::clojureRT::protobuf::Node* _msg = _internal_mutable_body();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.LetNode.body)
  return _msg;
}
inline void LetNode::set_allocated_body(::clojureRT::protobuf::Node* body) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.body_;
  }
  if (body) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(body);
    if (message_arena != submessage_arena) {
      body = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, body, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.body_ = body;
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.LetNode.body)
}

// -------------------------------------------------------------------

// LetfnNode

// repeated .clojureRT.protobuf.Node bindings = 1;
inline int LetfnNode::_internal_bindings_size() const {
  return _impl_.bindings_.size();
}
inline int LetfnNode::bindings_size() const {
  return _internal_bindings_size();
}
inline void LetfnNode::clear_bindings() {
  _impl_.bindings_.Clear();
}
inline ::clojureRT::protobuf::Node* LetfnNode::mutable_bindings(int index) {
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.LetfnNode.bindings)
  return _impl_.bindings_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >*
LetfnNode::mutable_bindings() {
  // @@protoc_insertion_point(field_mutable_list:clojureRT.protobuf.LetfnNode.bindings)
  return &_impl_.bindings_;
}
inline const ::clojureRT::protobuf::Node& LetfnNode::_internal_bindings(int index) const {
  return _impl_.bindings_.Get(index);
}
inline const ::clojureRT::protobuf::Node& LetfnNode::bindings(int index) const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.LetfnNode.bindings)
  return _internal_bindings(index);
}
inline ::clojureRT::protobuf::Node* LetfnNode::_internal_add_bindings() {
  return _impl_.bindings_.Add();
}
inline ::clojureRT::protobuf::Node* LetfnNode::add_bindings() {
  ::clojureRT::protobuf::Node* _add = _internal_add_bindings();
  // @@protoc_insertion_point(field_add:clojureRT.protobuf.LetfnNode.bindings)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >&
LetfnNode::bindings() const {
  // @@protoc_insertion_point(field_list:clojureRT.protobuf.LetfnNode.bindings)
  return _impl_.bindings_;
}

// .clojureRT.protobuf.Node body = 2;
inline bool LetfnNode::_internal_has_body() const {
  return this != internal_default_instance() && _impl_.body_ != nullptr;
}
inline bool LetfnNode::has_body() const {
  return _internal_has_body();
}
inline void LetfnNode::clear_body() {
  if (GetArenaForAllocation() == nullptr && _impl_.body_ != nullptr) {
    delete _impl_.body_;
  }
  _impl_.body_ = nullptr;
}
inline const ::clojureRT::protobuf::Node& LetfnNode::_internal_body() const {
  const ::clojureRT::protobuf::Node* p = _impl_.body_;
  return p != nullptr ? *p : reinterpret_cast<const ::clojureRT::protobuf::Node&>(
      ::clojureRT::protobuf::_Node_default_instance_);
}
inline const ::clojureRT::protobuf::Node& LetfnNode::body() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.LetfnNode.body)
  return _internal_body();
}
inline void LetfnNode::unsafe_arena_set_allocated_body(
    ::clojureRT::protobuf::Node* body) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.body_);
  }
  _impl_.body_ = body;
  if (body) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.LetfnNode.body)
}
inline ::clojureRT::protobuf::Node* LetfnNode::release_body() {
  
  ::clojureRT::protobuf::Node* temp = _impl_.body_;
  _impl_.body_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clojureRT::protobuf::Node* LetfnNode::unsafe_arena_release_body() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.LetfnNode.body)
  
  ::clojureRT::protobuf::Node* temp = _impl_.body_;
  _impl_.body_ = nullptr;
  return temp;
}
inline ::clojureRT::protobuf::Node* LetfnNode::_internal_mutable_body() {
  
  if (_impl_.body_ == nullptr) {
    auto* p = CreateMaybeMessage<::clojureRT::protobuf::Node>(GetArenaForAllocation());
    _impl_.body_ = p;
  }
  return _impl_.body_;
}
inline ::clojureRT::protobuf::Node* LetfnNode::mutable_body() {
  ::clojureRT::protobuf::Node* _msg = _internal_mutable_body();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.LetfnNode.body)
  return _msg;
}
inline void LetfnNode::set_allocated_body(::clojureRT::protobuf::Node* body) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.body_;
  }
  if (body) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(body);
    if (message_arena != submessage_arena) {
      body = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, body, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.body_ = body;
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.LetfnNode.body)
}

// -------------------------------------------------------------------

// LocalNode

// optional uint32 argId = 1;
inline bool LocalNode::_internal_has_argid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LocalNode::has_argid() const {
  return _internal_has_argid();
}
inline void LocalNode::clear_argid() {
  _impl_.argid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t LocalNode::_internal_argid() const {
  return _impl_.argid_;
}
inline uint32_t LocalNode::argid() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.LocalNode.argId)
  return _internal_argid();
}
inline void LocalNode::_internal_set_argid(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.argid_ = value;
}
inline void LocalNode::set_argid(uint32_t value) {
  _internal_set_argid(value);
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.LocalNode.argId)
}

// bool isAssignable = 2;
inline void LocalNode::clear_isassignable() {
  _impl_.isassignable_ = false;
}
inline bool LocalNode::_internal_isassignable() const {
  return _impl_.isassignable_;
}
inline bool LocalNode::isassignable() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.LocalNode.isAssignable)
  return _internal_isassignable();
}
inline void LocalNode::_internal_set_isassignable(bool value) {
  
  _impl_.isassignable_ = value;
}
inline void LocalNode::set_isassignable(bool value) {
  _internal_set_isassignable(value);
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.LocalNode.isAssignable)
}

// .clojureRT.protobuf.LocalType local = 3;
inline void LocalNode::clear_local() {
  _impl_.local_ = 0;
}
inline ::clojureRT::protobuf::LocalType LocalNode::_internal_local() const {
  return static_cast< ::clojureRT::protobuf::LocalType >(_impl_.local_);
}
inline ::clojureRT::protobuf::LocalType LocalNode::local() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.LocalNode.local)
  return _internal_local();
}
inline void LocalNode::_internal_set_local(::clojureRT::protobuf::LocalType value) {
  
  _impl_.local_ = value;
}
inline void LocalNode::set_local(::clojureRT::protobuf::LocalType value) {
  _internal_set_local(value);
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.LocalNode.local)
}

// string name = 4;
inline void LocalNode::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& LocalNode::name() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.LocalNode.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LocalNode::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.LocalNode.name)
}
inline std::string* LocalNode::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.LocalNode.name)
  return _s;
}
inline const std::string& LocalNode::_internal_name() const {
  return _impl_.name_.Get();
}
inline void LocalNode::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* LocalNode::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* LocalNode::release_name() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.LocalNode.name)
  return _impl_.name_.Release();
}
inline void LocalNode::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.LocalNode.name)
}

// optional bool isVariadic = 5;
inline bool LocalNode::_internal_has_isvariadic() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LocalNode::has_isvariadic() const {
  return _internal_has_isvariadic();
}
inline void LocalNode::clear_isvariadic() {
  _impl_.isvariadic_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool LocalNode::_internal_isvariadic() const {
  return _impl_.isvariadic_;
}
inline bool LocalNode::isvariadic() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.LocalNode.isVariadic)
  return _internal_isvariadic();
}
inline void LocalNode::_internal_set_isvariadic(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.isvariadic_ = value;
}
inline void LocalNode::set_isvariadic(bool value) {
  _internal_set_isvariadic(value);
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.LocalNode.isVariadic)
}

// -------------------------------------------------------------------

// LoopNode

// repeated .clojureRT.protobuf.Node bindings = 1;
inline int LoopNode::_internal_bindings_size() const {
  return _impl_.bindings_.size();
}
inline int LoopNode::bindings_size() const {
  return _internal_bindings_size();
}
inline void LoopNode::clear_bindings() {
  _impl_.bindings_.Clear();
}
inline ::clojureRT::protobuf::Node* LoopNode::mutable_bindings(int index) {
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.LoopNode.bindings)
  return _impl_.bindings_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >*
LoopNode::mutable_bindings() {
  // @@protoc_insertion_point(field_mutable_list:clojureRT.protobuf.LoopNode.bindings)
  return &_impl_.bindings_;
}
inline const ::clojureRT::protobuf::Node& LoopNode::_internal_bindings(int index) const {
  return _impl_.bindings_.Get(index);
}
inline const ::clojureRT::protobuf::Node& LoopNode::bindings(int index) const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.LoopNode.bindings)
  return _internal_bindings(index);
}
inline ::clojureRT::protobuf::Node* LoopNode::_internal_add_bindings() {
  return _impl_.bindings_.Add();
}
inline ::clojureRT::protobuf::Node* LoopNode::add_bindings() {
  ::clojureRT::protobuf::Node* _add = _internal_add_bindings();
  // @@protoc_insertion_point(field_add:clojureRT.protobuf.LoopNode.bindings)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >&
LoopNode::bindings() const {
  // @@protoc_insertion_point(field_list:clojureRT.protobuf.LoopNode.bindings)
  return _impl_.bindings_;
}

// .clojureRT.protobuf.Node body = 2;
inline bool LoopNode::_internal_has_body() const {
  return this != internal_default_instance() && _impl_.body_ != nullptr;
}
inline bool LoopNode::has_body() const {
  return _internal_has_body();
}
inline void LoopNode::clear_body() {
  if (GetArenaForAllocation() == nullptr && _impl_.body_ != nullptr) {
    delete _impl_.body_;
  }
  _impl_.body_ = nullptr;
}
inline const ::clojureRT::protobuf::Node& LoopNode::_internal_body() const {
  const ::clojureRT::protobuf::Node* p = _impl_.body_;
  return p != nullptr ? *p : reinterpret_cast<const ::clojureRT::protobuf::Node&>(
      ::clojureRT::protobuf::_Node_default_instance_);
}
inline const ::clojureRT::protobuf::Node& LoopNode::body() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.LoopNode.body)
  return _internal_body();
}
inline void LoopNode::unsafe_arena_set_allocated_body(
    ::clojureRT::protobuf::Node* body) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.body_);
  }
  _impl_.body_ = body;
  if (body) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.LoopNode.body)
}
inline ::clojureRT::protobuf::Node* LoopNode::release_body() {
  
  ::clojureRT::protobuf::Node* temp = _impl_.body_;
  _impl_.body_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clojureRT::protobuf::Node* LoopNode::unsafe_arena_release_body() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.LoopNode.body)
  
  ::clojureRT::protobuf::Node* temp = _impl_.body_;
  _impl_.body_ = nullptr;
  return temp;
}
inline ::clojureRT::protobuf::Node* LoopNode::_internal_mutable_body() {
  
  if (_impl_.body_ == nullptr) {
    auto* p = CreateMaybeMessage<::clojureRT::protobuf::Node>(GetArenaForAllocation());
    _impl_.body_ = p;
  }
  return _impl_.body_;
}
inline ::clojureRT::protobuf::Node* LoopNode::mutable_body() {
  ::clojureRT::protobuf::Node* _msg = _internal_mutable_body();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.LoopNode.body)
  return _msg;
}
inline void LoopNode::set_allocated_body(::clojureRT::protobuf::Node* body) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.body_;
  }
  if (body) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(body);
    if (message_arena != submessage_arena) {
      body = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, body, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.body_ = body;
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.LoopNode.body)
}

// string loopId = 3;
inline void LoopNode::clear_loopid() {
  _impl_.loopid_.ClearToEmpty();
}
inline const std::string& LoopNode::loopid() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.LoopNode.loopId)
  return _internal_loopid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoopNode::set_loopid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.loopid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.LoopNode.loopId)
}
inline std::string* LoopNode::mutable_loopid() {
  std::string* _s = _internal_mutable_loopid();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.LoopNode.loopId)
  return _s;
}
inline const std::string& LoopNode::_internal_loopid() const {
  return _impl_.loopid_.Get();
}
inline void LoopNode::_internal_set_loopid(const std::string& value) {
  
  _impl_.loopid_.Set(value, GetArenaForAllocation());
}
inline std::string* LoopNode::_internal_mutable_loopid() {
  
  return _impl_.loopid_.Mutable(GetArenaForAllocation());
}
inline std::string* LoopNode::release_loopid() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.LoopNode.loopId)
  return _impl_.loopid_.Release();
}
inline void LoopNode::set_allocated_loopid(std::string* loopid) {
  if (loopid != nullptr) {
    
  } else {
    
  }
  _impl_.loopid_.SetAllocated(loopid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.loopid_.IsDefault()) {
    _impl_.loopid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.LoopNode.loopId)
}

// -------------------------------------------------------------------

// MapNode

// repeated .clojureRT.protobuf.Node keys = 1;
inline int MapNode::_internal_keys_size() const {
  return _impl_.keys_.size();
}
inline int MapNode::keys_size() const {
  return _internal_keys_size();
}
inline void MapNode::clear_keys() {
  _impl_.keys_.Clear();
}
inline ::clojureRT::protobuf::Node* MapNode::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.MapNode.keys)
  return _impl_.keys_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >*
MapNode::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:clojureRT.protobuf.MapNode.keys)
  return &_impl_.keys_;
}
inline const ::clojureRT::protobuf::Node& MapNode::_internal_keys(int index) const {
  return _impl_.keys_.Get(index);
}
inline const ::clojureRT::protobuf::Node& MapNode::keys(int index) const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.MapNode.keys)
  return _internal_keys(index);
}
inline ::clojureRT::protobuf::Node* MapNode::_internal_add_keys() {
  return _impl_.keys_.Add();
}
inline ::clojureRT::protobuf::Node* MapNode::add_keys() {
  ::clojureRT::protobuf::Node* _add = _internal_add_keys();
  // @@protoc_insertion_point(field_add:clojureRT.protobuf.MapNode.keys)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >&
MapNode::keys() const {
  // @@protoc_insertion_point(field_list:clojureRT.protobuf.MapNode.keys)
  return _impl_.keys_;
}

// repeated .clojureRT.protobuf.Node vals = 2;
inline int MapNode::_internal_vals_size() const {
  return _impl_.vals_.size();
}
inline int MapNode::vals_size() const {
  return _internal_vals_size();
}
inline void MapNode::clear_vals() {
  _impl_.vals_.Clear();
}
inline ::clojureRT::protobuf::Node* MapNode::mutable_vals(int index) {
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.MapNode.vals)
  return _impl_.vals_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >*
MapNode::mutable_vals() {
  // @@protoc_insertion_point(field_mutable_list:clojureRT.protobuf.MapNode.vals)
  return &_impl_.vals_;
}
inline const ::clojureRT::protobuf::Node& MapNode::_internal_vals(int index) const {
  return _impl_.vals_.Get(index);
}
inline const ::clojureRT::protobuf::Node& MapNode::vals(int index) const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.MapNode.vals)
  return _internal_vals(index);
}
inline ::clojureRT::protobuf::Node* MapNode::_internal_add_vals() {
  return _impl_.vals_.Add();
}
inline ::clojureRT::protobuf::Node* MapNode::add_vals() {
  ::clojureRT::protobuf::Node* _add = _internal_add_vals();
  // @@protoc_insertion_point(field_add:clojureRT.protobuf.MapNode.vals)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >&
MapNode::vals() const {
  // @@protoc_insertion_point(field_list:clojureRT.protobuf.MapNode.vals)
  return _impl_.vals_;
}

// -------------------------------------------------------------------

// MethodNode

// .clojureRT.protobuf.Node body = 1;
inline bool MethodNode::_internal_has_body() const {
  return this != internal_default_instance() && _impl_.body_ != nullptr;
}
inline bool MethodNode::has_body() const {
  return _internal_has_body();
}
inline void MethodNode::clear_body() {
  if (GetArenaForAllocation() == nullptr && _impl_.body_ != nullptr) {
    delete _impl_.body_;
  }
  _impl_.body_ = nullptr;
}
inline const ::clojureRT::protobuf::Node& MethodNode::_internal_body() const {
  const ::clojureRT::protobuf::Node* p = _impl_.body_;
  return p != nullptr ? *p : reinterpret_cast<const ::clojureRT::protobuf::Node&>(
      ::clojureRT::protobuf::_Node_default_instance_);
}
inline const ::clojureRT::protobuf::Node& MethodNode::body() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.MethodNode.body)
  return _internal_body();
}
inline void MethodNode::unsafe_arena_set_allocated_body(
    ::clojureRT::protobuf::Node* body) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.body_);
  }
  _impl_.body_ = body;
  if (body) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.MethodNode.body)
}
inline ::clojureRT::protobuf::Node* MethodNode::release_body() {
  
  ::clojureRT::protobuf::Node* temp = _impl_.body_;
  _impl_.body_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clojureRT::protobuf::Node* MethodNode::unsafe_arena_release_body() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.MethodNode.body)
  
  ::clojureRT::protobuf::Node* temp = _impl_.body_;
  _impl_.body_ = nullptr;
  return temp;
}
inline ::clojureRT::protobuf::Node* MethodNode::_internal_mutable_body() {
  
  if (_impl_.body_ == nullptr) {
    auto* p = CreateMaybeMessage<::clojureRT::protobuf::Node>(GetArenaForAllocation());
    _impl_.body_ = p;
  }
  return _impl_.body_;
}
inline ::clojureRT::protobuf::Node* MethodNode::mutable_body() {
  ::clojureRT::protobuf::Node* _msg = _internal_mutable_body();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.MethodNode.body)
  return _msg;
}
inline void MethodNode::set_allocated_body(::clojureRT::protobuf::Node* body) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.body_;
  }
  if (body) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(body);
    if (message_arena != submessage_arena) {
      body = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, body, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.body_ = body;
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.MethodNode.body)
}

// repeated string bridges = 2;
inline int MethodNode::_internal_bridges_size() const {
  return _impl_.bridges_.size();
}
inline int MethodNode::bridges_size() const {
  return _internal_bridges_size();
}
inline void MethodNode::clear_bridges() {
  _impl_.bridges_.Clear();
}
inline std::string* MethodNode::add_bridges() {
  std::string* _s = _internal_add_bridges();
  // @@protoc_insertion_point(field_add_mutable:clojureRT.protobuf.MethodNode.bridges)
  return _s;
}
inline const std::string& MethodNode::_internal_bridges(int index) const {
  return _impl_.bridges_.Get(index);
}
inline const std::string& MethodNode::bridges(int index) const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.MethodNode.bridges)
  return _internal_bridges(index);
}
inline std::string* MethodNode::mutable_bridges(int index) {
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.MethodNode.bridges)
  return _impl_.bridges_.Mutable(index);
}
inline void MethodNode::set_bridges(int index, const std::string& value) {
  _impl_.bridges_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.MethodNode.bridges)
}
inline void MethodNode::set_bridges(int index, std::string&& value) {
  _impl_.bridges_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.MethodNode.bridges)
}
inline void MethodNode::set_bridges(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.bridges_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:clojureRT.protobuf.MethodNode.bridges)
}
inline void MethodNode::set_bridges(int index, const char* value, size_t size) {
  _impl_.bridges_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:clojureRT.protobuf.MethodNode.bridges)
}
inline std::string* MethodNode::_internal_add_bridges() {
  return _impl_.bridges_.Add();
}
inline void MethodNode::add_bridges(const std::string& value) {
  _impl_.bridges_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:clojureRT.protobuf.MethodNode.bridges)
}
inline void MethodNode::add_bridges(std::string&& value) {
  _impl_.bridges_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:clojureRT.protobuf.MethodNode.bridges)
}
inline void MethodNode::add_bridges(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.bridges_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:clojureRT.protobuf.MethodNode.bridges)
}
inline void MethodNode::add_bridges(const char* value, size_t size) {
  _impl_.bridges_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:clojureRT.protobuf.MethodNode.bridges)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MethodNode::bridges() const {
  // @@protoc_insertion_point(field_list:clojureRT.protobuf.MethodNode.bridges)
  return _impl_.bridges_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
MethodNode::mutable_bridges() {
  // @@protoc_insertion_point(field_mutable_list:clojureRT.protobuf.MethodNode.bridges)
  return &_impl_.bridges_;
}

// uint32 fixedArity = 3;
inline void MethodNode::clear_fixedarity() {
  _impl_.fixedarity_ = 0u;
}
inline uint32_t MethodNode::_internal_fixedarity() const {
  return _impl_.fixedarity_;
}
inline uint32_t MethodNode::fixedarity() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.MethodNode.fixedArity)
  return _internal_fixedarity();
}
inline void MethodNode::_internal_set_fixedarity(uint32_t value) {
  
  _impl_.fixedarity_ = value;
}
inline void MethodNode::set_fixedarity(uint32_t value) {
  _internal_set_fixedarity(value);
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.MethodNode.fixedArity)
}

// string interface = 4;
inline void MethodNode::clear_interface() {
  _impl_.interface_.ClearToEmpty();
}
inline const std::string& MethodNode::interface() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.MethodNode.interface)
  return _internal_interface();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MethodNode::set_interface(ArgT0&& arg0, ArgT... args) {
 
 _impl_.interface_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.MethodNode.interface)
}
inline std::string* MethodNode::mutable_interface() {
  std::string* _s = _internal_mutable_interface();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.MethodNode.interface)
  return _s;
}
inline const std::string& MethodNode::_internal_interface() const {
  return _impl_.interface_.Get();
}
inline void MethodNode::_internal_set_interface(const std::string& value) {
  
  _impl_.interface_.Set(value, GetArenaForAllocation());
}
inline std::string* MethodNode::_internal_mutable_interface() {
  
  return _impl_.interface_.Mutable(GetArenaForAllocation());
}
inline std::string* MethodNode::release_interface() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.MethodNode.interface)
  return _impl_.interface_.Release();
}
inline void MethodNode::set_allocated_interface(std::string* interface) {
  if (interface != nullptr) {
    
  } else {
    
  }
  _impl_.interface_.SetAllocated(interface, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.interface_.IsDefault()) {
    _impl_.interface_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.MethodNode.interface)
}

// string loopId = 5;
inline void MethodNode::clear_loopid() {
  _impl_.loopid_.ClearToEmpty();
}
inline const std::string& MethodNode::loopid() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.MethodNode.loopId)
  return _internal_loopid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MethodNode::set_loopid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.loopid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.MethodNode.loopId)
}
inline std::string* MethodNode::mutable_loopid() {
  std::string* _s = _internal_mutable_loopid();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.MethodNode.loopId)
  return _s;
}
inline const std::string& MethodNode::_internal_loopid() const {
  return _impl_.loopid_.Get();
}
inline void MethodNode::_internal_set_loopid(const std::string& value) {
  
  _impl_.loopid_.Set(value, GetArenaForAllocation());
}
inline std::string* MethodNode::_internal_mutable_loopid() {
  
  return _impl_.loopid_.Mutable(GetArenaForAllocation());
}
inline std::string* MethodNode::release_loopid() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.MethodNode.loopId)
  return _impl_.loopid_.Release();
}
inline void MethodNode::set_allocated_loopid(std::string* loopid) {
  if (loopid != nullptr) {
    
  } else {
    
  }
  _impl_.loopid_.SetAllocated(loopid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.loopid_.IsDefault()) {
    _impl_.loopid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.MethodNode.loopId)
}

// string name = 6;
inline void MethodNode::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& MethodNode::name() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.MethodNode.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MethodNode::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.MethodNode.name)
}
inline std::string* MethodNode::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.MethodNode.name)
  return _s;
}
inline const std::string& MethodNode::_internal_name() const {
  return _impl_.name_.Get();
}
inline void MethodNode::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* MethodNode::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* MethodNode::release_name() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.MethodNode.name)
  return _impl_.name_.Release();
}
inline void MethodNode::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.MethodNode.name)
}

// repeated .clojureRT.protobuf.Node params = 7;
inline int MethodNode::_internal_params_size() const {
  return _impl_.params_.size();
}
inline int MethodNode::params_size() const {
  return _internal_params_size();
}
inline void MethodNode::clear_params() {
  _impl_.params_.Clear();
}
inline ::clojureRT::protobuf::Node* MethodNode::mutable_params(int index) {
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.MethodNode.params)
  return _impl_.params_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >*
MethodNode::mutable_params() {
  // @@protoc_insertion_point(field_mutable_list:clojureRT.protobuf.MethodNode.params)
  return &_impl_.params_;
}
inline const ::clojureRT::protobuf::Node& MethodNode::_internal_params(int index) const {
  return _impl_.params_.Get(index);
}
inline const ::clojureRT::protobuf::Node& MethodNode::params(int index) const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.MethodNode.params)
  return _internal_params(index);
}
inline ::clojureRT::protobuf::Node* MethodNode::_internal_add_params() {
  return _impl_.params_.Add();
}
inline ::clojureRT::protobuf::Node* MethodNode::add_params() {
  ::clojureRT::protobuf::Node* _add = _internal_add_params();
  // @@protoc_insertion_point(field_add:clojureRT.protobuf.MethodNode.params)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >&
MethodNode::params() const {
  // @@protoc_insertion_point(field_list:clojureRT.protobuf.MethodNode.params)
  return _impl_.params_;
}

// .clojureRT.protobuf.Node this = 8;
inline bool MethodNode::_internal_has_this_() const {
  return this != internal_default_instance() && _impl_.this__ != nullptr;
}
inline bool MethodNode::has_this_() const {
  return _internal_has_this_();
}
inline void MethodNode::clear_this_() {
  if (GetArenaForAllocation() == nullptr && _impl_.this__ != nullptr) {
    delete _impl_.this__;
  }
  _impl_.this__ = nullptr;
}
inline const ::clojureRT::protobuf::Node& MethodNode::_internal_this_() const {
  const ::clojureRT::protobuf::Node* p = _impl_.this__;
  return p != nullptr ? *p : reinterpret_cast<const ::clojureRT::protobuf::Node&>(
      ::clojureRT::protobuf::_Node_default_instance_);
}
inline const ::clojureRT::protobuf::Node& MethodNode::this_() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.MethodNode.this)
  return _internal_this_();
}
inline void MethodNode::unsafe_arena_set_allocated_this_(
    ::clojureRT::protobuf::Node* this_) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.this__);
  }
  _impl_.this__ = this_;
  if (this_) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.MethodNode.this)
}
inline ::clojureRT::protobuf::Node* MethodNode::release_this_() {
  
  ::clojureRT::protobuf::Node* temp = _impl_.this__;
  _impl_.this__ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clojureRT::protobuf::Node* MethodNode::unsafe_arena_release_this_() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.MethodNode.this)
  
  ::clojureRT::protobuf::Node* temp = _impl_.this__;
  _impl_.this__ = nullptr;
  return temp;
}
inline ::clojureRT::protobuf::Node* MethodNode::_internal_mutable_this_() {
  
  if (_impl_.this__ == nullptr) {
    auto* p = CreateMaybeMessage<::clojureRT::protobuf::Node>(GetArenaForAllocation());
    _impl_.this__ = p;
  }
  return _impl_.this__;
}
inline ::clojureRT::protobuf::Node* MethodNode::mutable_this_() {
  ::clojureRT::protobuf::Node* _msg = _internal_mutable_this_();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.MethodNode.this)
  return _msg;
}
inline void MethodNode::set_allocated_this_(::clojureRT::protobuf::Node* this_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.this__;
  }
  if (this_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(this_);
    if (message_arena != submessage_arena) {
      this_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, this_, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.this__ = this_;
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.MethodNode.this)
}

// -------------------------------------------------------------------

// MonitorEnterNode

// .clojureRT.protobuf.Node target = 1;
inline bool MonitorEnterNode::_internal_has_target() const {
  return this != internal_default_instance() && _impl_.target_ != nullptr;
}
inline bool MonitorEnterNode::has_target() const {
  return _internal_has_target();
}
inline void MonitorEnterNode::clear_target() {
  if (GetArenaForAllocation() == nullptr && _impl_.target_ != nullptr) {
    delete _impl_.target_;
  }
  _impl_.target_ = nullptr;
}
inline const ::clojureRT::protobuf::Node& MonitorEnterNode::_internal_target() const {
  const ::clojureRT::protobuf::Node* p = _impl_.target_;
  return p != nullptr ? *p : reinterpret_cast<const ::clojureRT::protobuf::Node&>(
      ::clojureRT::protobuf::_Node_default_instance_);
}
inline const ::clojureRT::protobuf::Node& MonitorEnterNode::target() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.MonitorEnterNode.target)
  return _internal_target();
}
inline void MonitorEnterNode::unsafe_arena_set_allocated_target(
    ::clojureRT::protobuf::Node* target) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.target_);
  }
  _impl_.target_ = target;
  if (target) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.MonitorEnterNode.target)
}
inline ::clojureRT::protobuf::Node* MonitorEnterNode::release_target() {
  
  ::clojureRT::protobuf::Node* temp = _impl_.target_;
  _impl_.target_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clojureRT::protobuf::Node* MonitorEnterNode::unsafe_arena_release_target() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.MonitorEnterNode.target)
  
  ::clojureRT::protobuf::Node* temp = _impl_.target_;
  _impl_.target_ = nullptr;
  return temp;
}
inline ::clojureRT::protobuf::Node* MonitorEnterNode::_internal_mutable_target() {
  
  if (_impl_.target_ == nullptr) {
    auto* p = CreateMaybeMessage<::clojureRT::protobuf::Node>(GetArenaForAllocation());
    _impl_.target_ = p;
  }
  return _impl_.target_;
}
inline ::clojureRT::protobuf::Node* MonitorEnterNode::mutable_target() {
  ::clojureRT::protobuf::Node* _msg = _internal_mutable_target();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.MonitorEnterNode.target)
  return _msg;
}
inline void MonitorEnterNode::set_allocated_target(::clojureRT::protobuf::Node* target) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.target_;
  }
  if (target) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(target);
    if (message_arena != submessage_arena) {
      target = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.target_ = target;
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.MonitorEnterNode.target)
}

// -------------------------------------------------------------------

// MonitorExitNode

// .clojureRT.protobuf.Node target = 1;
inline bool MonitorExitNode::_internal_has_target() const {
  return this != internal_default_instance() && _impl_.target_ != nullptr;
}
inline bool MonitorExitNode::has_target() const {
  return _internal_has_target();
}
inline void MonitorExitNode::clear_target() {
  if (GetArenaForAllocation() == nullptr && _impl_.target_ != nullptr) {
    delete _impl_.target_;
  }
  _impl_.target_ = nullptr;
}
inline const ::clojureRT::protobuf::Node& MonitorExitNode::_internal_target() const {
  const ::clojureRT::protobuf::Node* p = _impl_.target_;
  return p != nullptr ? *p : reinterpret_cast<const ::clojureRT::protobuf::Node&>(
      ::clojureRT::protobuf::_Node_default_instance_);
}
inline const ::clojureRT::protobuf::Node& MonitorExitNode::target() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.MonitorExitNode.target)
  return _internal_target();
}
inline void MonitorExitNode::unsafe_arena_set_allocated_target(
    ::clojureRT::protobuf::Node* target) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.target_);
  }
  _impl_.target_ = target;
  if (target) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.MonitorExitNode.target)
}
inline ::clojureRT::protobuf::Node* MonitorExitNode::release_target() {
  
  ::clojureRT::protobuf::Node* temp = _impl_.target_;
  _impl_.target_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clojureRT::protobuf::Node* MonitorExitNode::unsafe_arena_release_target() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.MonitorExitNode.target)
  
  ::clojureRT::protobuf::Node* temp = _impl_.target_;
  _impl_.target_ = nullptr;
  return temp;
}
inline ::clojureRT::protobuf::Node* MonitorExitNode::_internal_mutable_target() {
  
  if (_impl_.target_ == nullptr) {
    auto* p = CreateMaybeMessage<::clojureRT::protobuf::Node>(GetArenaForAllocation());
    _impl_.target_ = p;
  }
  return _impl_.target_;
}
inline ::clojureRT::protobuf::Node* MonitorExitNode::mutable_target() {
  ::clojureRT::protobuf::Node* _msg = _internal_mutable_target();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.MonitorExitNode.target)
  return _msg;
}
inline void MonitorExitNode::set_allocated_target(::clojureRT::protobuf::Node* target) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.target_;
  }
  if (target) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(target);
    if (message_arena != submessage_arena) {
      target = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.target_ = target;
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.MonitorExitNode.target)
}

// -------------------------------------------------------------------

// NewNode

// repeated .clojureRT.protobuf.Node args = 1;
inline int NewNode::_internal_args_size() const {
  return _impl_.args_.size();
}
inline int NewNode::args_size() const {
  return _internal_args_size();
}
inline void NewNode::clear_args() {
  _impl_.args_.Clear();
}
inline ::clojureRT::protobuf::Node* NewNode::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.NewNode.args)
  return _impl_.args_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >*
NewNode::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:clojureRT.protobuf.NewNode.args)
  return &_impl_.args_;
}
inline const ::clojureRT::protobuf::Node& NewNode::_internal_args(int index) const {
  return _impl_.args_.Get(index);
}
inline const ::clojureRT::protobuf::Node& NewNode::args(int index) const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.NewNode.args)
  return _internal_args(index);
}
inline ::clojureRT::protobuf::Node* NewNode::_internal_add_args() {
  return _impl_.args_.Add();
}
inline ::clojureRT::protobuf::Node* NewNode::add_args() {
  ::clojureRT::protobuf::Node* _add = _internal_add_args();
  // @@protoc_insertion_point(field_add:clojureRT.protobuf.NewNode.args)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >&
NewNode::args() const {
  // @@protoc_insertion_point(field_list:clojureRT.protobuf.NewNode.args)
  return _impl_.args_;
}

// .clojureRT.protobuf.Node class = 2;
inline bool NewNode::_internal_has_class_() const {
  return this != internal_default_instance() && _impl_.class__ != nullptr;
}
inline bool NewNode::has_class_() const {
  return _internal_has_class_();
}
inline void NewNode::clear_class_() {
  if (GetArenaForAllocation() == nullptr && _impl_.class__ != nullptr) {
    delete _impl_.class__;
  }
  _impl_.class__ = nullptr;
}
inline const ::clojureRT::protobuf::Node& NewNode::_internal_class_() const {
  const ::clojureRT::protobuf::Node* p = _impl_.class__;
  return p != nullptr ? *p : reinterpret_cast<const ::clojureRT::protobuf::Node&>(
      ::clojureRT::protobuf::_Node_default_instance_);
}
inline const ::clojureRT::protobuf::Node& NewNode::class_() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.NewNode.class)
  return _internal_class_();
}
inline void NewNode::unsafe_arena_set_allocated_class_(
    ::clojureRT::protobuf::Node* class_) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.class__);
  }
  _impl_.class__ = class_;
  if (class_) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.NewNode.class)
}
inline ::clojureRT::protobuf::Node* NewNode::release_class_() {
  
  ::clojureRT::protobuf::Node* temp = _impl_.class__;
  _impl_.class__ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clojureRT::protobuf::Node* NewNode::unsafe_arena_release_class_() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.NewNode.class)
  
  ::clojureRT::protobuf::Node* temp = _impl_.class__;
  _impl_.class__ = nullptr;
  return temp;
}
inline ::clojureRT::protobuf::Node* NewNode::_internal_mutable_class_() {
  
  if (_impl_.class__ == nullptr) {
    auto* p = CreateMaybeMessage<::clojureRT::protobuf::Node>(GetArenaForAllocation());
    _impl_.class__ = p;
  }
  return _impl_.class__;
}
inline ::clojureRT::protobuf::Node* NewNode::mutable_class_() {
  ::clojureRT::protobuf::Node* _msg = _internal_mutable_class_();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.NewNode.class)
  return _msg;
}
inline void NewNode::set_allocated_class_(::clojureRT::protobuf::Node* class_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.class__;
  }
  if (class_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(class_);
    if (message_arena != submessage_arena) {
      class_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, class_, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.class__ = class_;
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.NewNode.class)
}

// optional bool isValidated = 3;
inline bool NewNode::_internal_has_isvalidated() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NewNode::has_isvalidated() const {
  return _internal_has_isvalidated();
}
inline void NewNode::clear_isvalidated() {
  _impl_.isvalidated_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool NewNode::_internal_isvalidated() const {
  return _impl_.isvalidated_;
}
inline bool NewNode::isvalidated() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.NewNode.isValidated)
  return _internal_isvalidated();
}
inline void NewNode::_internal_set_isvalidated(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.isvalidated_ = value;
}
inline void NewNode::set_isvalidated(bool value) {
  _internal_set_isvalidated(value);
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.NewNode.isValidated)
}

// -------------------------------------------------------------------

// PrimInvokeNode

// repeated .clojureRT.protobuf.Node args = 1;
inline int PrimInvokeNode::_internal_args_size() const {
  return _impl_.args_.size();
}
inline int PrimInvokeNode::args_size() const {
  return _internal_args_size();
}
inline void PrimInvokeNode::clear_args() {
  _impl_.args_.Clear();
}
inline ::clojureRT::protobuf::Node* PrimInvokeNode::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.PrimInvokeNode.args)
  return _impl_.args_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >*
PrimInvokeNode::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:clojureRT.protobuf.PrimInvokeNode.args)
  return &_impl_.args_;
}
inline const ::clojureRT::protobuf::Node& PrimInvokeNode::_internal_args(int index) const {
  return _impl_.args_.Get(index);
}
inline const ::clojureRT::protobuf::Node& PrimInvokeNode::args(int index) const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.PrimInvokeNode.args)
  return _internal_args(index);
}
inline ::clojureRT::protobuf::Node* PrimInvokeNode::_internal_add_args() {
  return _impl_.args_.Add();
}
inline ::clojureRT::protobuf::Node* PrimInvokeNode::add_args() {
  ::clojureRT::protobuf::Node* _add = _internal_add_args();
  // @@protoc_insertion_point(field_add:clojureRT.protobuf.PrimInvokeNode.args)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >&
PrimInvokeNode::args() const {
  // @@protoc_insertion_point(field_list:clojureRT.protobuf.PrimInvokeNode.args)
  return _impl_.args_;
}

// .clojureRT.protobuf.Node fn = 2;
inline bool PrimInvokeNode::_internal_has_fn() const {
  return this != internal_default_instance() && _impl_.fn_ != nullptr;
}
inline bool PrimInvokeNode::has_fn() const {
  return _internal_has_fn();
}
inline void PrimInvokeNode::clear_fn() {
  if (GetArenaForAllocation() == nullptr && _impl_.fn_ != nullptr) {
    delete _impl_.fn_;
  }
  _impl_.fn_ = nullptr;
}
inline const ::clojureRT::protobuf::Node& PrimInvokeNode::_internal_fn() const {
  const ::clojureRT::protobuf::Node* p = _impl_.fn_;
  return p != nullptr ? *p : reinterpret_cast<const ::clojureRT::protobuf::Node&>(
      ::clojureRT::protobuf::_Node_default_instance_);
}
inline const ::clojureRT::protobuf::Node& PrimInvokeNode::fn() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.PrimInvokeNode.fn)
  return _internal_fn();
}
inline void PrimInvokeNode::unsafe_arena_set_allocated_fn(
    ::clojureRT::protobuf::Node* fn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fn_);
  }
  _impl_.fn_ = fn;
  if (fn) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.PrimInvokeNode.fn)
}
inline ::clojureRT::protobuf::Node* PrimInvokeNode::release_fn() {
  
  ::clojureRT::protobuf::Node* temp = _impl_.fn_;
  _impl_.fn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clojureRT::protobuf::Node* PrimInvokeNode::unsafe_arena_release_fn() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.PrimInvokeNode.fn)
  
  ::clojureRT::protobuf::Node* temp = _impl_.fn_;
  _impl_.fn_ = nullptr;
  return temp;
}
inline ::clojureRT::protobuf::Node* PrimInvokeNode::_internal_mutable_fn() {
  
  if (_impl_.fn_ == nullptr) {
    auto* p = CreateMaybeMessage<::clojureRT::protobuf::Node>(GetArenaForAllocation());
    _impl_.fn_ = p;
  }
  return _impl_.fn_;
}
inline ::clojureRT::protobuf::Node* PrimInvokeNode::mutable_fn() {
  ::clojureRT::protobuf::Node* _msg = _internal_mutable_fn();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.PrimInvokeNode.fn)
  return _msg;
}
inline void PrimInvokeNode::set_allocated_fn(::clojureRT::protobuf::Node* fn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.fn_;
  }
  if (fn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fn);
    if (message_arena != submessage_arena) {
      fn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fn, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.fn_ = fn;
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.PrimInvokeNode.fn)
}

// optional string meta = 3;
inline bool PrimInvokeNode::_internal_has_meta() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PrimInvokeNode::has_meta() const {
  return _internal_has_meta();
}
inline void PrimInvokeNode::clear_meta() {
  _impl_.meta_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PrimInvokeNode::meta() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.PrimInvokeNode.meta)
  return _internal_meta();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PrimInvokeNode::set_meta(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.meta_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.PrimInvokeNode.meta)
}
inline std::string* PrimInvokeNode::mutable_meta() {
  std::string* _s = _internal_mutable_meta();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.PrimInvokeNode.meta)
  return _s;
}
inline const std::string& PrimInvokeNode::_internal_meta() const {
  return _impl_.meta_.Get();
}
inline void PrimInvokeNode::_internal_set_meta(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.meta_.Set(value, GetArenaForAllocation());
}
inline std::string* PrimInvokeNode::_internal_mutable_meta() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.meta_.Mutable(GetArenaForAllocation());
}
inline std::string* PrimInvokeNode::release_meta() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.PrimInvokeNode.meta)
  if (!_internal_has_meta()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.meta_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.meta_.IsDefault()) {
    _impl_.meta_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PrimInvokeNode::set_allocated_meta(std::string* meta) {
  if (meta != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.meta_.SetAllocated(meta, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.meta_.IsDefault()) {
    _impl_.meta_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.PrimInvokeNode.meta)
}

// string primInterface = 4;
inline void PrimInvokeNode::clear_priminterface() {
  _impl_.priminterface_.ClearToEmpty();
}
inline const std::string& PrimInvokeNode::priminterface() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.PrimInvokeNode.primInterface)
  return _internal_priminterface();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PrimInvokeNode::set_priminterface(ArgT0&& arg0, ArgT... args) {
 
 _impl_.priminterface_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.PrimInvokeNode.primInterface)
}
inline std::string* PrimInvokeNode::mutable_priminterface() {
  std::string* _s = _internal_mutable_priminterface();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.PrimInvokeNode.primInterface)
  return _s;
}
inline const std::string& PrimInvokeNode::_internal_priminterface() const {
  return _impl_.priminterface_.Get();
}
inline void PrimInvokeNode::_internal_set_priminterface(const std::string& value) {
  
  _impl_.priminterface_.Set(value, GetArenaForAllocation());
}
inline std::string* PrimInvokeNode::_internal_mutable_priminterface() {
  
  return _impl_.priminterface_.Mutable(GetArenaForAllocation());
}
inline std::string* PrimInvokeNode::release_priminterface() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.PrimInvokeNode.primInterface)
  return _impl_.priminterface_.Release();
}
inline void PrimInvokeNode::set_allocated_priminterface(std::string* priminterface) {
  if (priminterface != nullptr) {
    
  } else {
    
  }
  _impl_.priminterface_.SetAllocated(priminterface, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.priminterface_.IsDefault()) {
    _impl_.priminterface_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.PrimInvokeNode.primInterface)
}

// -------------------------------------------------------------------

// ProtocolInvokeNode

// repeated .clojureRT.protobuf.Node args = 1;
inline int ProtocolInvokeNode::_internal_args_size() const {
  return _impl_.args_.size();
}
inline int ProtocolInvokeNode::args_size() const {
  return _internal_args_size();
}
inline void ProtocolInvokeNode::clear_args() {
  _impl_.args_.Clear();
}
inline ::clojureRT::protobuf::Node* ProtocolInvokeNode::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.ProtocolInvokeNode.args)
  return _impl_.args_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >*
ProtocolInvokeNode::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:clojureRT.protobuf.ProtocolInvokeNode.args)
  return &_impl_.args_;
}
inline const ::clojureRT::protobuf::Node& ProtocolInvokeNode::_internal_args(int index) const {
  return _impl_.args_.Get(index);
}
inline const ::clojureRT::protobuf::Node& ProtocolInvokeNode::args(int index) const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.ProtocolInvokeNode.args)
  return _internal_args(index);
}
inline ::clojureRT::protobuf::Node* ProtocolInvokeNode::_internal_add_args() {
  return _impl_.args_.Add();
}
inline ::clojureRT::protobuf::Node* ProtocolInvokeNode::add_args() {
  ::clojureRT::protobuf::Node* _add = _internal_add_args();
  // @@protoc_insertion_point(field_add:clojureRT.protobuf.ProtocolInvokeNode.args)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >&
ProtocolInvokeNode::args() const {
  // @@protoc_insertion_point(field_list:clojureRT.protobuf.ProtocolInvokeNode.args)
  return _impl_.args_;
}

// .clojureRT.protobuf.Node protocolFn = 2;
inline bool ProtocolInvokeNode::_internal_has_protocolfn() const {
  return this != internal_default_instance() && _impl_.protocolfn_ != nullptr;
}
inline bool ProtocolInvokeNode::has_protocolfn() const {
  return _internal_has_protocolfn();
}
inline void ProtocolInvokeNode::clear_protocolfn() {
  if (GetArenaForAllocation() == nullptr && _impl_.protocolfn_ != nullptr) {
    delete _impl_.protocolfn_;
  }
  _impl_.protocolfn_ = nullptr;
}
inline const ::clojureRT::protobuf::Node& ProtocolInvokeNode::_internal_protocolfn() const {
  const ::clojureRT::protobuf::Node* p = _impl_.protocolfn_;
  return p != nullptr ? *p : reinterpret_cast<const ::clojureRT::protobuf::Node&>(
      ::clojureRT::protobuf::_Node_default_instance_);
}
inline const ::clojureRT::protobuf::Node& ProtocolInvokeNode::protocolfn() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.ProtocolInvokeNode.protocolFn)
  return _internal_protocolfn();
}
inline void ProtocolInvokeNode::unsafe_arena_set_allocated_protocolfn(
    ::clojureRT::protobuf::Node* protocolfn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.protocolfn_);
  }
  _impl_.protocolfn_ = protocolfn;
  if (protocolfn) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.ProtocolInvokeNode.protocolFn)
}
inline ::clojureRT::protobuf::Node* ProtocolInvokeNode::release_protocolfn() {
  
  ::clojureRT::protobuf::Node* temp = _impl_.protocolfn_;
  _impl_.protocolfn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clojureRT::protobuf::Node* ProtocolInvokeNode::unsafe_arena_release_protocolfn() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.ProtocolInvokeNode.protocolFn)
  
  ::clojureRT::protobuf::Node* temp = _impl_.protocolfn_;
  _impl_.protocolfn_ = nullptr;
  return temp;
}
inline ::clojureRT::protobuf::Node* ProtocolInvokeNode::_internal_mutable_protocolfn() {
  
  if (_impl_.protocolfn_ == nullptr) {
    auto* p = CreateMaybeMessage<::clojureRT::protobuf::Node>(GetArenaForAllocation());
    _impl_.protocolfn_ = p;
  }
  return _impl_.protocolfn_;
}
inline ::clojureRT::protobuf::Node* ProtocolInvokeNode::mutable_protocolfn() {
  ::clojureRT::protobuf::Node* _msg = _internal_mutable_protocolfn();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.ProtocolInvokeNode.protocolFn)
  return _msg;
}
inline void ProtocolInvokeNode::set_allocated_protocolfn(::clojureRT::protobuf::Node* protocolfn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.protocolfn_;
  }
  if (protocolfn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(protocolfn);
    if (message_arena != submessage_arena) {
      protocolfn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, protocolfn, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.protocolfn_ = protocolfn;
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.ProtocolInvokeNode.protocolFn)
}

// .clojureRT.protobuf.Node target = 3;
inline bool ProtocolInvokeNode::_internal_has_target() const {
  return this != internal_default_instance() && _impl_.target_ != nullptr;
}
inline bool ProtocolInvokeNode::has_target() const {
  return _internal_has_target();
}
inline void ProtocolInvokeNode::clear_target() {
  if (GetArenaForAllocation() == nullptr && _impl_.target_ != nullptr) {
    delete _impl_.target_;
  }
  _impl_.target_ = nullptr;
}
inline const ::clojureRT::protobuf::Node& ProtocolInvokeNode::_internal_target() const {
  const ::clojureRT::protobuf::Node* p = _impl_.target_;
  return p != nullptr ? *p : reinterpret_cast<const ::clojureRT::protobuf::Node&>(
      ::clojureRT::protobuf::_Node_default_instance_);
}
inline const ::clojureRT::protobuf::Node& ProtocolInvokeNode::target() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.ProtocolInvokeNode.target)
  return _internal_target();
}
inline void ProtocolInvokeNode::unsafe_arena_set_allocated_target(
    ::clojureRT::protobuf::Node* target) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.target_);
  }
  _impl_.target_ = target;
  if (target) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.ProtocolInvokeNode.target)
}
inline ::clojureRT::protobuf::Node* ProtocolInvokeNode::release_target() {
  
  ::clojureRT::protobuf::Node* temp = _impl_.target_;
  _impl_.target_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clojureRT::protobuf::Node* ProtocolInvokeNode::unsafe_arena_release_target() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.ProtocolInvokeNode.target)
  
  ::clojureRT::protobuf::Node* temp = _impl_.target_;
  _impl_.target_ = nullptr;
  return temp;
}
inline ::clojureRT::protobuf::Node* ProtocolInvokeNode::_internal_mutable_target() {
  
  if (_impl_.target_ == nullptr) {
    auto* p = CreateMaybeMessage<::clojureRT::protobuf::Node>(GetArenaForAllocation());
    _impl_.target_ = p;
  }
  return _impl_.target_;
}
inline ::clojureRT::protobuf::Node* ProtocolInvokeNode::mutable_target() {
  ::clojureRT::protobuf::Node* _msg = _internal_mutable_target();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.ProtocolInvokeNode.target)
  return _msg;
}
inline void ProtocolInvokeNode::set_allocated_target(::clojureRT::protobuf::Node* target) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.target_;
  }
  if (target) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(target);
    if (message_arena != submessage_arena) {
      target = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.target_ = target;
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.ProtocolInvokeNode.target)
}

// -------------------------------------------------------------------

// QuoteNode

// .clojureRT.protobuf.Node expr = 1;
inline bool QuoteNode::_internal_has_expr() const {
  return this != internal_default_instance() && _impl_.expr_ != nullptr;
}
inline bool QuoteNode::has_expr() const {
  return _internal_has_expr();
}
inline void QuoteNode::clear_expr() {
  if (GetArenaForAllocation() == nullptr && _impl_.expr_ != nullptr) {
    delete _impl_.expr_;
  }
  _impl_.expr_ = nullptr;
}
inline const ::clojureRT::protobuf::Node& QuoteNode::_internal_expr() const {
  const ::clojureRT::protobuf::Node* p = _impl_.expr_;
  return p != nullptr ? *p : reinterpret_cast<const ::clojureRT::protobuf::Node&>(
      ::clojureRT::protobuf::_Node_default_instance_);
}
inline const ::clojureRT::protobuf::Node& QuoteNode::expr() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.QuoteNode.expr)
  return _internal_expr();
}
inline void QuoteNode::unsafe_arena_set_allocated_expr(
    ::clojureRT::protobuf::Node* expr) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.expr_);
  }
  _impl_.expr_ = expr;
  if (expr) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.QuoteNode.expr)
}
inline ::clojureRT::protobuf::Node* QuoteNode::release_expr() {
  
  ::clojureRT::protobuf::Node* temp = _impl_.expr_;
  _impl_.expr_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clojureRT::protobuf::Node* QuoteNode::unsafe_arena_release_expr() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.QuoteNode.expr)
  
  ::clojureRT::protobuf::Node* temp = _impl_.expr_;
  _impl_.expr_ = nullptr;
  return temp;
}
inline ::clojureRT::protobuf::Node* QuoteNode::_internal_mutable_expr() {
  
  if (_impl_.expr_ == nullptr) {
    auto* p = CreateMaybeMessage<::clojureRT::protobuf::Node>(GetArenaForAllocation());
    _impl_.expr_ = p;
  }
  return _impl_.expr_;
}
inline ::clojureRT::protobuf::Node* QuoteNode::mutable_expr() {
  ::clojureRT::protobuf::Node* _msg = _internal_mutable_expr();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.QuoteNode.expr)
  return _msg;
}
inline void QuoteNode::set_allocated_expr(::clojureRT::protobuf::Node* expr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.expr_;
  }
  if (expr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(expr);
    if (message_arena != submessage_arena) {
      expr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, expr, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.expr_ = expr;
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.QuoteNode.expr)
}

// bool isLiteral = 2;
inline void QuoteNode::clear_isliteral() {
  _impl_.isliteral_ = false;
}
inline bool QuoteNode::_internal_isliteral() const {
  return _impl_.isliteral_;
}
inline bool QuoteNode::isliteral() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.QuoteNode.isLiteral)
  return _internal_isliteral();
}
inline void QuoteNode::_internal_set_isliteral(bool value) {
  
  _impl_.isliteral_ = value;
}
inline void QuoteNode::set_isliteral(bool value) {
  _internal_set_isliteral(value);
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.QuoteNode.isLiteral)
}

// -------------------------------------------------------------------

// RecurNode

// repeated .clojureRT.protobuf.Node exprs = 1;
inline int RecurNode::_internal_exprs_size() const {
  return _impl_.exprs_.size();
}
inline int RecurNode::exprs_size() const {
  return _internal_exprs_size();
}
inline void RecurNode::clear_exprs() {
  _impl_.exprs_.Clear();
}
inline ::clojureRT::protobuf::Node* RecurNode::mutable_exprs(int index) {
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.RecurNode.exprs)
  return _impl_.exprs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >*
RecurNode::mutable_exprs() {
  // @@protoc_insertion_point(field_mutable_list:clojureRT.protobuf.RecurNode.exprs)
  return &_impl_.exprs_;
}
inline const ::clojureRT::protobuf::Node& RecurNode::_internal_exprs(int index) const {
  return _impl_.exprs_.Get(index);
}
inline const ::clojureRT::protobuf::Node& RecurNode::exprs(int index) const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.RecurNode.exprs)
  return _internal_exprs(index);
}
inline ::clojureRT::protobuf::Node* RecurNode::_internal_add_exprs() {
  return _impl_.exprs_.Add();
}
inline ::clojureRT::protobuf::Node* RecurNode::add_exprs() {
  ::clojureRT::protobuf::Node* _add = _internal_add_exprs();
  // @@protoc_insertion_point(field_add:clojureRT.protobuf.RecurNode.exprs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >&
RecurNode::exprs() const {
  // @@protoc_insertion_point(field_list:clojureRT.protobuf.RecurNode.exprs)
  return _impl_.exprs_;
}

// string loopId = 2;
inline void RecurNode::clear_loopid() {
  _impl_.loopid_.ClearToEmpty();
}
inline const std::string& RecurNode::loopid() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.RecurNode.loopId)
  return _internal_loopid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RecurNode::set_loopid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.loopid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.RecurNode.loopId)
}
inline std::string* RecurNode::mutable_loopid() {
  std::string* _s = _internal_mutable_loopid();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.RecurNode.loopId)
  return _s;
}
inline const std::string& RecurNode::_internal_loopid() const {
  return _impl_.loopid_.Get();
}
inline void RecurNode::_internal_set_loopid(const std::string& value) {
  
  _impl_.loopid_.Set(value, GetArenaForAllocation());
}
inline std::string* RecurNode::_internal_mutable_loopid() {
  
  return _impl_.loopid_.Mutable(GetArenaForAllocation());
}
inline std::string* RecurNode::release_loopid() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.RecurNode.loopId)
  return _impl_.loopid_.Release();
}
inline void RecurNode::set_allocated_loopid(std::string* loopid) {
  if (loopid != nullptr) {
    
  } else {
    
  }
  _impl_.loopid_.SetAllocated(loopid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.loopid_.IsDefault()) {
    _impl_.loopid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.RecurNode.loopId)
}

// -------------------------------------------------------------------

// ReifyNode

// string className = 1;
inline void ReifyNode::clear_classname() {
  _impl_.classname_.ClearToEmpty();
}
inline const std::string& ReifyNode::classname() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.ReifyNode.className)
  return _internal_classname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReifyNode::set_classname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.classname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.ReifyNode.className)
}
inline std::string* ReifyNode::mutable_classname() {
  std::string* _s = _internal_mutable_classname();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.ReifyNode.className)
  return _s;
}
inline const std::string& ReifyNode::_internal_classname() const {
  return _impl_.classname_.Get();
}
inline void ReifyNode::_internal_set_classname(const std::string& value) {
  
  _impl_.classname_.Set(value, GetArenaForAllocation());
}
inline std::string* ReifyNode::_internal_mutable_classname() {
  
  return _impl_.classname_.Mutable(GetArenaForAllocation());
}
inline std::string* ReifyNode::release_classname() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.ReifyNode.className)
  return _impl_.classname_.Release();
}
inline void ReifyNode::set_allocated_classname(std::string* classname) {
  if (classname != nullptr) {
    
  } else {
    
  }
  _impl_.classname_.SetAllocated(classname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.classname_.IsDefault()) {
    _impl_.classname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.ReifyNode.className)
}

// repeated string interfaces = 2;
inline int ReifyNode::_internal_interfaces_size() const {
  return _impl_.interfaces_.size();
}
inline int ReifyNode::interfaces_size() const {
  return _internal_interfaces_size();
}
inline void ReifyNode::clear_interfaces() {
  _impl_.interfaces_.Clear();
}
inline std::string* ReifyNode::add_interfaces() {
  std::string* _s = _internal_add_interfaces();
  // @@protoc_insertion_point(field_add_mutable:clojureRT.protobuf.ReifyNode.interfaces)
  return _s;
}
inline const std::string& ReifyNode::_internal_interfaces(int index) const {
  return _impl_.interfaces_.Get(index);
}
inline const std::string& ReifyNode::interfaces(int index) const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.ReifyNode.interfaces)
  return _internal_interfaces(index);
}
inline std::string* ReifyNode::mutable_interfaces(int index) {
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.ReifyNode.interfaces)
  return _impl_.interfaces_.Mutable(index);
}
inline void ReifyNode::set_interfaces(int index, const std::string& value) {
  _impl_.interfaces_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.ReifyNode.interfaces)
}
inline void ReifyNode::set_interfaces(int index, std::string&& value) {
  _impl_.interfaces_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.ReifyNode.interfaces)
}
inline void ReifyNode::set_interfaces(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.interfaces_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:clojureRT.protobuf.ReifyNode.interfaces)
}
inline void ReifyNode::set_interfaces(int index, const char* value, size_t size) {
  _impl_.interfaces_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:clojureRT.protobuf.ReifyNode.interfaces)
}
inline std::string* ReifyNode::_internal_add_interfaces() {
  return _impl_.interfaces_.Add();
}
inline void ReifyNode::add_interfaces(const std::string& value) {
  _impl_.interfaces_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:clojureRT.protobuf.ReifyNode.interfaces)
}
inline void ReifyNode::add_interfaces(std::string&& value) {
  _impl_.interfaces_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:clojureRT.protobuf.ReifyNode.interfaces)
}
inline void ReifyNode::add_interfaces(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.interfaces_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:clojureRT.protobuf.ReifyNode.interfaces)
}
inline void ReifyNode::add_interfaces(const char* value, size_t size) {
  _impl_.interfaces_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:clojureRT.protobuf.ReifyNode.interfaces)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ReifyNode::interfaces() const {
  // @@protoc_insertion_point(field_list:clojureRT.protobuf.ReifyNode.interfaces)
  return _impl_.interfaces_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ReifyNode::mutable_interfaces() {
  // @@protoc_insertion_point(field_mutable_list:clojureRT.protobuf.ReifyNode.interfaces)
  return &_impl_.interfaces_;
}

// repeated .clojureRT.protobuf.Node methods = 3;
inline int ReifyNode::_internal_methods_size() const {
  return _impl_.methods_.size();
}
inline int ReifyNode::methods_size() const {
  return _internal_methods_size();
}
inline void ReifyNode::clear_methods() {
  _impl_.methods_.Clear();
}
inline ::clojureRT::protobuf::Node* ReifyNode::mutable_methods(int index) {
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.ReifyNode.methods)
  return _impl_.methods_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >*
ReifyNode::mutable_methods() {
  // @@protoc_insertion_point(field_mutable_list:clojureRT.protobuf.ReifyNode.methods)
  return &_impl_.methods_;
}
inline const ::clojureRT::protobuf::Node& ReifyNode::_internal_methods(int index) const {
  return _impl_.methods_.Get(index);
}
inline const ::clojureRT::protobuf::Node& ReifyNode::methods(int index) const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.ReifyNode.methods)
  return _internal_methods(index);
}
inline ::clojureRT::protobuf::Node* ReifyNode::_internal_add_methods() {
  return _impl_.methods_.Add();
}
inline ::clojureRT::protobuf::Node* ReifyNode::add_methods() {
  ::clojureRT::protobuf::Node* _add = _internal_add_methods();
  // @@protoc_insertion_point(field_add:clojureRT.protobuf.ReifyNode.methods)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >&
ReifyNode::methods() const {
  // @@protoc_insertion_point(field_list:clojureRT.protobuf.ReifyNode.methods)
  return _impl_.methods_;
}

// -------------------------------------------------------------------

// SetNode

// repeated .clojureRT.protobuf.Node items = 1;
inline int SetNode::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int SetNode::items_size() const {
  return _internal_items_size();
}
inline void SetNode::clear_items() {
  _impl_.items_.Clear();
}
inline ::clojureRT::protobuf::Node* SetNode::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.SetNode.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >*
SetNode::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:clojureRT.protobuf.SetNode.items)
  return &_impl_.items_;
}
inline const ::clojureRT::protobuf::Node& SetNode::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::clojureRT::protobuf::Node& SetNode::items(int index) const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.SetNode.items)
  return _internal_items(index);
}
inline ::clojureRT::protobuf::Node* SetNode::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::clojureRT::protobuf::Node* SetNode::add_items() {
  ::clojureRT::protobuf::Node* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:clojureRT.protobuf.SetNode.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >&
SetNode::items() const {
  // @@protoc_insertion_point(field_list:clojureRT.protobuf.SetNode.items)
  return _impl_.items_;
}

// -------------------------------------------------------------------

// MutateSetNode

// .clojureRT.protobuf.Node target = 1;
inline bool MutateSetNode::_internal_has_target() const {
  return this != internal_default_instance() && _impl_.target_ != nullptr;
}
inline bool MutateSetNode::has_target() const {
  return _internal_has_target();
}
inline void MutateSetNode::clear_target() {
  if (GetArenaForAllocation() == nullptr && _impl_.target_ != nullptr) {
    delete _impl_.target_;
  }
  _impl_.target_ = nullptr;
}
inline const ::clojureRT::protobuf::Node& MutateSetNode::_internal_target() const {
  const ::clojureRT::protobuf::Node* p = _impl_.target_;
  return p != nullptr ? *p : reinterpret_cast<const ::clojureRT::protobuf::Node&>(
      ::clojureRT::protobuf::_Node_default_instance_);
}
inline const ::clojureRT::protobuf::Node& MutateSetNode::target() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.MutateSetNode.target)
  return _internal_target();
}
inline void MutateSetNode::unsafe_arena_set_allocated_target(
    ::clojureRT::protobuf::Node* target) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.target_);
  }
  _impl_.target_ = target;
  if (target) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.MutateSetNode.target)
}
inline ::clojureRT::protobuf::Node* MutateSetNode::release_target() {
  
  ::clojureRT::protobuf::Node* temp = _impl_.target_;
  _impl_.target_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clojureRT::protobuf::Node* MutateSetNode::unsafe_arena_release_target() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.MutateSetNode.target)
  
  ::clojureRT::protobuf::Node* temp = _impl_.target_;
  _impl_.target_ = nullptr;
  return temp;
}
inline ::clojureRT::protobuf::Node* MutateSetNode::_internal_mutable_target() {
  
  if (_impl_.target_ == nullptr) {
    auto* p = CreateMaybeMessage<::clojureRT::protobuf::Node>(GetArenaForAllocation());
    _impl_.target_ = p;
  }
  return _impl_.target_;
}
inline ::clojureRT::protobuf::Node* MutateSetNode::mutable_target() {
  ::clojureRT::protobuf::Node* _msg = _internal_mutable_target();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.MutateSetNode.target)
  return _msg;
}
inline void MutateSetNode::set_allocated_target(::clojureRT::protobuf::Node* target) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.target_;
  }
  if (target) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(target);
    if (message_arena != submessage_arena) {
      target = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.target_ = target;
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.MutateSetNode.target)
}

// .clojureRT.protobuf.Node val = 2;
inline bool MutateSetNode::_internal_has_val() const {
  return this != internal_default_instance() && _impl_.val_ != nullptr;
}
inline bool MutateSetNode::has_val() const {
  return _internal_has_val();
}
inline void MutateSetNode::clear_val() {
  if (GetArenaForAllocation() == nullptr && _impl_.val_ != nullptr) {
    delete _impl_.val_;
  }
  _impl_.val_ = nullptr;
}
inline const ::clojureRT::protobuf::Node& MutateSetNode::_internal_val() const {
  const ::clojureRT::protobuf::Node* p = _impl_.val_;
  return p != nullptr ? *p : reinterpret_cast<const ::clojureRT::protobuf::Node&>(
      ::clojureRT::protobuf::_Node_default_instance_);
}
inline const ::clojureRT::protobuf::Node& MutateSetNode::val() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.MutateSetNode.val)
  return _internal_val();
}
inline void MutateSetNode::unsafe_arena_set_allocated_val(
    ::clojureRT::protobuf::Node* val) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.val_);
  }
  _impl_.val_ = val;
  if (val) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.MutateSetNode.val)
}
inline ::clojureRT::protobuf::Node* MutateSetNode::release_val() {
  
  ::clojureRT::protobuf::Node* temp = _impl_.val_;
  _impl_.val_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clojureRT::protobuf::Node* MutateSetNode::unsafe_arena_release_val() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.MutateSetNode.val)
  
  ::clojureRT::protobuf::Node* temp = _impl_.val_;
  _impl_.val_ = nullptr;
  return temp;
}
inline ::clojureRT::protobuf::Node* MutateSetNode::_internal_mutable_val() {
  
  if (_impl_.val_ == nullptr) {
    auto* p = CreateMaybeMessage<::clojureRT::protobuf::Node>(GetArenaForAllocation());
    _impl_.val_ = p;
  }
  return _impl_.val_;
}
inline ::clojureRT::protobuf::Node* MutateSetNode::mutable_val() {
  ::clojureRT::protobuf::Node* _msg = _internal_mutable_val();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.MutateSetNode.val)
  return _msg;
}
inline void MutateSetNode::set_allocated_val(::clojureRT::protobuf::Node* val) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.val_;
  }
  if (val) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(val);
    if (message_arena != submessage_arena) {
      val = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, val, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.val_ = val;
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.MutateSetNode.val)
}

// -------------------------------------------------------------------

// StaticCallNode

// repeated .clojureRT.protobuf.Node args = 1;
inline int StaticCallNode::_internal_args_size() const {
  return _impl_.args_.size();
}
inline int StaticCallNode::args_size() const {
  return _internal_args_size();
}
inline void StaticCallNode::clear_args() {
  _impl_.args_.Clear();
}
inline ::clojureRT::protobuf::Node* StaticCallNode::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.StaticCallNode.args)
  return _impl_.args_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >*
StaticCallNode::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:clojureRT.protobuf.StaticCallNode.args)
  return &_impl_.args_;
}
inline const ::clojureRT::protobuf::Node& StaticCallNode::_internal_args(int index) const {
  return _impl_.args_.Get(index);
}
inline const ::clojureRT::protobuf::Node& StaticCallNode::args(int index) const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.StaticCallNode.args)
  return _internal_args(index);
}
inline ::clojureRT::protobuf::Node* StaticCallNode::_internal_add_args() {
  return _impl_.args_.Add();
}
inline ::clojureRT::protobuf::Node* StaticCallNode::add_args() {
  ::clojureRT::protobuf::Node* _add = _internal_add_args();
  // @@protoc_insertion_point(field_add:clojureRT.protobuf.StaticCallNode.args)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >&
StaticCallNode::args() const {
  // @@protoc_insertion_point(field_list:clojureRT.protobuf.StaticCallNode.args)
  return _impl_.args_;
}

// string class = 2;
inline void StaticCallNode::clear_class_() {
  _impl_.class__.ClearToEmpty();
}
inline const std::string& StaticCallNode::class_() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.StaticCallNode.class)
  return _internal_class_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StaticCallNode::set_class_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.class__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.StaticCallNode.class)
}
inline std::string* StaticCallNode::mutable_class_() {
  std::string* _s = _internal_mutable_class_();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.StaticCallNode.class)
  return _s;
}
inline const std::string& StaticCallNode::_internal_class_() const {
  return _impl_.class__.Get();
}
inline void StaticCallNode::_internal_set_class_(const std::string& value) {
  
  _impl_.class__.Set(value, GetArenaForAllocation());
}
inline std::string* StaticCallNode::_internal_mutable_class_() {
  
  return _impl_.class__.Mutable(GetArenaForAllocation());
}
inline std::string* StaticCallNode::release_class_() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.StaticCallNode.class)
  return _impl_.class__.Release();
}
inline void StaticCallNode::set_allocated_class_(std::string* class_) {
  if (class_ != nullptr) {
    
  } else {
    
  }
  _impl_.class__.SetAllocated(class_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.class__.IsDefault()) {
    _impl_.class__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.StaticCallNode.class)
}

// string method = 3;
inline void StaticCallNode::clear_method() {
  _impl_.method_.ClearToEmpty();
}
inline const std::string& StaticCallNode::method() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.StaticCallNode.method)
  return _internal_method();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StaticCallNode::set_method(ArgT0&& arg0, ArgT... args) {
 
 _impl_.method_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.StaticCallNode.method)
}
inline std::string* StaticCallNode::mutable_method() {
  std::string* _s = _internal_mutable_method();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.StaticCallNode.method)
  return _s;
}
inline const std::string& StaticCallNode::_internal_method() const {
  return _impl_.method_.Get();
}
inline void StaticCallNode::_internal_set_method(const std::string& value) {
  
  _impl_.method_.Set(value, GetArenaForAllocation());
}
inline std::string* StaticCallNode::_internal_mutable_method() {
  
  return _impl_.method_.Mutable(GetArenaForAllocation());
}
inline std::string* StaticCallNode::release_method() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.StaticCallNode.method)
  return _impl_.method_.Release();
}
inline void StaticCallNode::set_allocated_method(std::string* method) {
  if (method != nullptr) {
    
  } else {
    
  }
  _impl_.method_.SetAllocated(method, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.method_.IsDefault()) {
    _impl_.method_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.StaticCallNode.method)
}

// optional bool isValidated = 4;
inline bool StaticCallNode::_internal_has_isvalidated() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StaticCallNode::has_isvalidated() const {
  return _internal_has_isvalidated();
}
inline void StaticCallNode::clear_isvalidated() {
  _impl_.isvalidated_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool StaticCallNode::_internal_isvalidated() const {
  return _impl_.isvalidated_;
}
inline bool StaticCallNode::isvalidated() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.StaticCallNode.isValidated)
  return _internal_isvalidated();
}
inline void StaticCallNode::_internal_set_isvalidated(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.isvalidated_ = value;
}
inline void StaticCallNode::set_isvalidated(bool value) {
  _internal_set_isvalidated(value);
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.StaticCallNode.isValidated)
}

// -------------------------------------------------------------------

// StaticFieldNode

// optional bool isAssignable = 1;
inline bool StaticFieldNode::_internal_has_isassignable() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StaticFieldNode::has_isassignable() const {
  return _internal_has_isassignable();
}
inline void StaticFieldNode::clear_isassignable() {
  _impl_.isassignable_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool StaticFieldNode::_internal_isassignable() const {
  return _impl_.isassignable_;
}
inline bool StaticFieldNode::isassignable() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.StaticFieldNode.isAssignable)
  return _internal_isassignable();
}
inline void StaticFieldNode::_internal_set_isassignable(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.isassignable_ = value;
}
inline void StaticFieldNode::set_isassignable(bool value) {
  _internal_set_isassignable(value);
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.StaticFieldNode.isAssignable)
}

// string class = 2;
inline void StaticFieldNode::clear_class_() {
  _impl_.class__.ClearToEmpty();
}
inline const std::string& StaticFieldNode::class_() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.StaticFieldNode.class)
  return _internal_class_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StaticFieldNode::set_class_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.class__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.StaticFieldNode.class)
}
inline std::string* StaticFieldNode::mutable_class_() {
  std::string* _s = _internal_mutable_class_();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.StaticFieldNode.class)
  return _s;
}
inline const std::string& StaticFieldNode::_internal_class_() const {
  return _impl_.class__.Get();
}
inline void StaticFieldNode::_internal_set_class_(const std::string& value) {
  
  _impl_.class__.Set(value, GetArenaForAllocation());
}
inline std::string* StaticFieldNode::_internal_mutable_class_() {
  
  return _impl_.class__.Mutable(GetArenaForAllocation());
}
inline std::string* StaticFieldNode::release_class_() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.StaticFieldNode.class)
  return _impl_.class__.Release();
}
inline void StaticFieldNode::set_allocated_class_(std::string* class_) {
  if (class_ != nullptr) {
    
  } else {
    
  }
  _impl_.class__.SetAllocated(class_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.class__.IsDefault()) {
    _impl_.class__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.StaticFieldNode.class)
}

// string field = 3;
inline void StaticFieldNode::clear_field() {
  _impl_.field_.ClearToEmpty();
}
inline const std::string& StaticFieldNode::field() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.StaticFieldNode.field)
  return _internal_field();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StaticFieldNode::set_field(ArgT0&& arg0, ArgT... args) {
 
 _impl_.field_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.StaticFieldNode.field)
}
inline std::string* StaticFieldNode::mutable_field() {
  std::string* _s = _internal_mutable_field();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.StaticFieldNode.field)
  return _s;
}
inline const std::string& StaticFieldNode::_internal_field() const {
  return _impl_.field_.Get();
}
inline void StaticFieldNode::_internal_set_field(const std::string& value) {
  
  _impl_.field_.Set(value, GetArenaForAllocation());
}
inline std::string* StaticFieldNode::_internal_mutable_field() {
  
  return _impl_.field_.Mutable(GetArenaForAllocation());
}
inline std::string* StaticFieldNode::release_field() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.StaticFieldNode.field)
  return _impl_.field_.Release();
}
inline void StaticFieldNode::set_allocated_field(std::string* field) {
  if (field != nullptr) {
    
  } else {
    
  }
  _impl_.field_.SetAllocated(field, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field_.IsDefault()) {
    _impl_.field_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.StaticFieldNode.field)
}

// -------------------------------------------------------------------

// TheVarNode

// string var = 1;
inline void TheVarNode::clear_var() {
  _impl_.var_.ClearToEmpty();
}
inline const std::string& TheVarNode::var() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.TheVarNode.var)
  return _internal_var();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TheVarNode::set_var(ArgT0&& arg0, ArgT... args) {
 
 _impl_.var_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.TheVarNode.var)
}
inline std::string* TheVarNode::mutable_var() {
  std::string* _s = _internal_mutable_var();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.TheVarNode.var)
  return _s;
}
inline const std::string& TheVarNode::_internal_var() const {
  return _impl_.var_.Get();
}
inline void TheVarNode::_internal_set_var(const std::string& value) {
  
  _impl_.var_.Set(value, GetArenaForAllocation());
}
inline std::string* TheVarNode::_internal_mutable_var() {
  
  return _impl_.var_.Mutable(GetArenaForAllocation());
}
inline std::string* TheVarNode::release_var() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.TheVarNode.var)
  return _impl_.var_.Release();
}
inline void TheVarNode::set_allocated_var(std::string* var) {
  if (var != nullptr) {
    
  } else {
    
  }
  _impl_.var_.SetAllocated(var, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.var_.IsDefault()) {
    _impl_.var_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.TheVarNode.var)
}

// -------------------------------------------------------------------

// ThrowNode

// .clojureRT.protobuf.Node exception = 1;
inline bool ThrowNode::_internal_has_exception() const {
  return this != internal_default_instance() && _impl_.exception_ != nullptr;
}
inline bool ThrowNode::has_exception() const {
  return _internal_has_exception();
}
inline void ThrowNode::clear_exception() {
  if (GetArenaForAllocation() == nullptr && _impl_.exception_ != nullptr) {
    delete _impl_.exception_;
  }
  _impl_.exception_ = nullptr;
}
inline const ::clojureRT::protobuf::Node& ThrowNode::_internal_exception() const {
  const ::clojureRT::protobuf::Node* p = _impl_.exception_;
  return p != nullptr ? *p : reinterpret_cast<const ::clojureRT::protobuf::Node&>(
      ::clojureRT::protobuf::_Node_default_instance_);
}
inline const ::clojureRT::protobuf::Node& ThrowNode::exception() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.ThrowNode.exception)
  return _internal_exception();
}
inline void ThrowNode::unsafe_arena_set_allocated_exception(
    ::clojureRT::protobuf::Node* exception) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.exception_);
  }
  _impl_.exception_ = exception;
  if (exception) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.ThrowNode.exception)
}
inline ::clojureRT::protobuf::Node* ThrowNode::release_exception() {
  
  ::clojureRT::protobuf::Node* temp = _impl_.exception_;
  _impl_.exception_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clojureRT::protobuf::Node* ThrowNode::unsafe_arena_release_exception() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.ThrowNode.exception)
  
  ::clojureRT::protobuf::Node* temp = _impl_.exception_;
  _impl_.exception_ = nullptr;
  return temp;
}
inline ::clojureRT::protobuf::Node* ThrowNode::_internal_mutable_exception() {
  
  if (_impl_.exception_ == nullptr) {
    auto* p = CreateMaybeMessage<::clojureRT::protobuf::Node>(GetArenaForAllocation());
    _impl_.exception_ = p;
  }
  return _impl_.exception_;
}
inline ::clojureRT::protobuf::Node* ThrowNode::mutable_exception() {
  ::clojureRT::protobuf::Node* _msg = _internal_mutable_exception();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.ThrowNode.exception)
  return _msg;
}
inline void ThrowNode::set_allocated_exception(::clojureRT::protobuf::Node* exception) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.exception_;
  }
  if (exception) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(exception);
    if (message_arena != submessage_arena) {
      exception = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, exception, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.exception_ = exception;
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.ThrowNode.exception)
}

// -------------------------------------------------------------------

// TryNode

// .clojureRT.protobuf.Node body = 1;
inline bool TryNode::_internal_has_body() const {
  return this != internal_default_instance() && _impl_.body_ != nullptr;
}
inline bool TryNode::has_body() const {
  return _internal_has_body();
}
inline void TryNode::clear_body() {
  if (GetArenaForAllocation() == nullptr && _impl_.body_ != nullptr) {
    delete _impl_.body_;
  }
  _impl_.body_ = nullptr;
}
inline const ::clojureRT::protobuf::Node& TryNode::_internal_body() const {
  const ::clojureRT::protobuf::Node* p = _impl_.body_;
  return p != nullptr ? *p : reinterpret_cast<const ::clojureRT::protobuf::Node&>(
      ::clojureRT::protobuf::_Node_default_instance_);
}
inline const ::clojureRT::protobuf::Node& TryNode::body() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.TryNode.body)
  return _internal_body();
}
inline void TryNode::unsafe_arena_set_allocated_body(
    ::clojureRT::protobuf::Node* body) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.body_);
  }
  _impl_.body_ = body;
  if (body) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.TryNode.body)
}
inline ::clojureRT::protobuf::Node* TryNode::release_body() {
  
  ::clojureRT::protobuf::Node* temp = _impl_.body_;
  _impl_.body_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clojureRT::protobuf::Node* TryNode::unsafe_arena_release_body() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.TryNode.body)
  
  ::clojureRT::protobuf::Node* temp = _impl_.body_;
  _impl_.body_ = nullptr;
  return temp;
}
inline ::clojureRT::protobuf::Node* TryNode::_internal_mutable_body() {
  
  if (_impl_.body_ == nullptr) {
    auto* p = CreateMaybeMessage<::clojureRT::protobuf::Node>(GetArenaForAllocation());
    _impl_.body_ = p;
  }
  return _impl_.body_;
}
inline ::clojureRT::protobuf::Node* TryNode::mutable_body() {
  ::clojureRT::protobuf::Node* _msg = _internal_mutable_body();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.TryNode.body)
  return _msg;
}
inline void TryNode::set_allocated_body(::clojureRT::protobuf::Node* body) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.body_;
  }
  if (body) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(body);
    if (message_arena != submessage_arena) {
      body = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, body, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.body_ = body;
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.TryNode.body)
}

// repeated .clojureRT.protobuf.Node catches = 2;
inline int TryNode::_internal_catches_size() const {
  return _impl_.catches_.size();
}
inline int TryNode::catches_size() const {
  return _internal_catches_size();
}
inline void TryNode::clear_catches() {
  _impl_.catches_.Clear();
}
inline ::clojureRT::protobuf::Node* TryNode::mutable_catches(int index) {
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.TryNode.catches)
  return _impl_.catches_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >*
TryNode::mutable_catches() {
  // @@protoc_insertion_point(field_mutable_list:clojureRT.protobuf.TryNode.catches)
  return &_impl_.catches_;
}
inline const ::clojureRT::protobuf::Node& TryNode::_internal_catches(int index) const {
  return _impl_.catches_.Get(index);
}
inline const ::clojureRT::protobuf::Node& TryNode::catches(int index) const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.TryNode.catches)
  return _internal_catches(index);
}
inline ::clojureRT::protobuf::Node* TryNode::_internal_add_catches() {
  return _impl_.catches_.Add();
}
inline ::clojureRT::protobuf::Node* TryNode::add_catches() {
  ::clojureRT::protobuf::Node* _add = _internal_add_catches();
  // @@protoc_insertion_point(field_add:clojureRT.protobuf.TryNode.catches)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >&
TryNode::catches() const {
  // @@protoc_insertion_point(field_list:clojureRT.protobuf.TryNode.catches)
  return _impl_.catches_;
}

// optional .clojureRT.protobuf.Node finally = 3;
inline bool TryNode::_internal_has_finally() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.finally_ != nullptr);
  return value;
}
inline bool TryNode::has_finally() const {
  return _internal_has_finally();
}
inline void TryNode::clear_finally() {
  if (_impl_.finally_ != nullptr) _impl_.finally_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::clojureRT::protobuf::Node& TryNode::_internal_finally() const {
  const ::clojureRT::protobuf::Node* p = _impl_.finally_;
  return p != nullptr ? *p : reinterpret_cast<const ::clojureRT::protobuf::Node&>(
      ::clojureRT::protobuf::_Node_default_instance_);
}
inline const ::clojureRT::protobuf::Node& TryNode::finally() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.TryNode.finally)
  return _internal_finally();
}
inline void TryNode::unsafe_arena_set_allocated_finally(
    ::clojureRT::protobuf::Node* finally) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.finally_);
  }
  _impl_.finally_ = finally;
  if (finally) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.TryNode.finally)
}
inline ::clojureRT::protobuf::Node* TryNode::release_finally() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::clojureRT::protobuf::Node* temp = _impl_.finally_;
  _impl_.finally_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clojureRT::protobuf::Node* TryNode::unsafe_arena_release_finally() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.TryNode.finally)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::clojureRT::protobuf::Node* temp = _impl_.finally_;
  _impl_.finally_ = nullptr;
  return temp;
}
inline ::clojureRT::protobuf::Node* TryNode::_internal_mutable_finally() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.finally_ == nullptr) {
    auto* p = CreateMaybeMessage<::clojureRT::protobuf::Node>(GetArenaForAllocation());
    _impl_.finally_ = p;
  }
  return _impl_.finally_;
}
inline ::clojureRT::protobuf::Node* TryNode::mutable_finally() {
  ::clojureRT::protobuf::Node* _msg = _internal_mutable_finally();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.TryNode.finally)
  return _msg;
}
inline void TryNode::set_allocated_finally(::clojureRT::protobuf::Node* finally) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.finally_;
  }
  if (finally) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(finally);
    if (message_arena != submessage_arena) {
      finally = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, finally, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.finally_ = finally;
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.TryNode.finally)
}

// -------------------------------------------------------------------

// VarNode

// optional bool isAssignable = 1;
inline bool VarNode::_internal_has_isassignable() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VarNode::has_isassignable() const {
  return _internal_has_isassignable();
}
inline void VarNode::clear_isassignable() {
  _impl_.isassignable_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool VarNode::_internal_isassignable() const {
  return _impl_.isassignable_;
}
inline bool VarNode::isassignable() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.VarNode.isAssignable)
  return _internal_isassignable();
}
inline void VarNode::_internal_set_isassignable(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.isassignable_ = value;
}
inline void VarNode::set_isassignable(bool value) {
  _internal_set_isassignable(value);
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.VarNode.isAssignable)
}

// string var = 2;
inline void VarNode::clear_var() {
  _impl_.var_.ClearToEmpty();
}
inline const std::string& VarNode::var() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.VarNode.var)
  return _internal_var();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VarNode::set_var(ArgT0&& arg0, ArgT... args) {
 
 _impl_.var_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.VarNode.var)
}
inline std::string* VarNode::mutable_var() {
  std::string* _s = _internal_mutable_var();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.VarNode.var)
  return _s;
}
inline const std::string& VarNode::_internal_var() const {
  return _impl_.var_.Get();
}
inline void VarNode::_internal_set_var(const std::string& value) {
  
  _impl_.var_.Set(value, GetArenaForAllocation());
}
inline std::string* VarNode::_internal_mutable_var() {
  
  return _impl_.var_.Mutable(GetArenaForAllocation());
}
inline std::string* VarNode::release_var() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.VarNode.var)
  return _impl_.var_.Release();
}
inline void VarNode::set_allocated_var(std::string* var) {
  if (var != nullptr) {
    
  } else {
    
  }
  _impl_.var_.SetAllocated(var, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.var_.IsDefault()) {
    _impl_.var_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.VarNode.var)
}

// -------------------------------------------------------------------

// VectorNode

// repeated .clojureRT.protobuf.Node items = 1;
inline int VectorNode::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int VectorNode::items_size() const {
  return _internal_items_size();
}
inline void VectorNode::clear_items() {
  _impl_.items_.Clear();
}
inline ::clojureRT::protobuf::Node* VectorNode::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.VectorNode.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >*
VectorNode::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:clojureRT.protobuf.VectorNode.items)
  return &_impl_.items_;
}
inline const ::clojureRT::protobuf::Node& VectorNode::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::clojureRT::protobuf::Node& VectorNode::items(int index) const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.VectorNode.items)
  return _internal_items(index);
}
inline ::clojureRT::protobuf::Node* VectorNode::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::clojureRT::protobuf::Node* VectorNode::add_items() {
  ::clojureRT::protobuf::Node* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:clojureRT.protobuf.VectorNode.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clojureRT::protobuf::Node >&
VectorNode::items() const {
  // @@protoc_insertion_point(field_list:clojureRT.protobuf.VectorNode.items)
  return _impl_.items_;
}

// -------------------------------------------------------------------

// WithMetaNode

// .clojureRT.protobuf.Node expr = 1;
inline bool WithMetaNode::_internal_has_expr() const {
  return this != internal_default_instance() && _impl_.expr_ != nullptr;
}
inline bool WithMetaNode::has_expr() const {
  return _internal_has_expr();
}
inline void WithMetaNode::clear_expr() {
  if (GetArenaForAllocation() == nullptr && _impl_.expr_ != nullptr) {
    delete _impl_.expr_;
  }
  _impl_.expr_ = nullptr;
}
inline const ::clojureRT::protobuf::Node& WithMetaNode::_internal_expr() const {
  const ::clojureRT::protobuf::Node* p = _impl_.expr_;
  return p != nullptr ? *p : reinterpret_cast<const ::clojureRT::protobuf::Node&>(
      ::clojureRT::protobuf::_Node_default_instance_);
}
inline const ::clojureRT::protobuf::Node& WithMetaNode::expr() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.WithMetaNode.expr)
  return _internal_expr();
}
inline void WithMetaNode::unsafe_arena_set_allocated_expr(
    ::clojureRT::protobuf::Node* expr) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.expr_);
  }
  _impl_.expr_ = expr;
  if (expr) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.WithMetaNode.expr)
}
inline ::clojureRT::protobuf::Node* WithMetaNode::release_expr() {
  
  ::clojureRT::protobuf::Node* temp = _impl_.expr_;
  _impl_.expr_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clojureRT::protobuf::Node* WithMetaNode::unsafe_arena_release_expr() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.WithMetaNode.expr)
  
  ::clojureRT::protobuf::Node* temp = _impl_.expr_;
  _impl_.expr_ = nullptr;
  return temp;
}
inline ::clojureRT::protobuf::Node* WithMetaNode::_internal_mutable_expr() {
  
  if (_impl_.expr_ == nullptr) {
    auto* p = CreateMaybeMessage<::clojureRT::protobuf::Node>(GetArenaForAllocation());
    _impl_.expr_ = p;
  }
  return _impl_.expr_;
}
inline ::clojureRT::protobuf::Node* WithMetaNode::mutable_expr() {
  ::clojureRT::protobuf::Node* _msg = _internal_mutable_expr();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.WithMetaNode.expr)
  return _msg;
}
inline void WithMetaNode::set_allocated_expr(::clojureRT::protobuf::Node* expr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.expr_;
  }
  if (expr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(expr);
    if (message_arena != submessage_arena) {
      expr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, expr, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.expr_ = expr;
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.WithMetaNode.expr)
}

// .clojureRT.protobuf.Node meta = 2;
inline bool WithMetaNode::_internal_has_meta() const {
  return this != internal_default_instance() && _impl_.meta_ != nullptr;
}
inline bool WithMetaNode::has_meta() const {
  return _internal_has_meta();
}
inline void WithMetaNode::clear_meta() {
  if (GetArenaForAllocation() == nullptr && _impl_.meta_ != nullptr) {
    delete _impl_.meta_;
  }
  _impl_.meta_ = nullptr;
}
inline const ::clojureRT::protobuf::Node& WithMetaNode::_internal_meta() const {
  const ::clojureRT::protobuf::Node* p = _impl_.meta_;
  return p != nullptr ? *p : reinterpret_cast<const ::clojureRT::protobuf::Node&>(
      ::clojureRT::protobuf::_Node_default_instance_);
}
inline const ::clojureRT::protobuf::Node& WithMetaNode::meta() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.WithMetaNode.meta)
  return _internal_meta();
}
inline void WithMetaNode::unsafe_arena_set_allocated_meta(
    ::clojureRT::protobuf::Node* meta) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.meta_);
  }
  _impl_.meta_ = meta;
  if (meta) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.WithMetaNode.meta)
}
inline ::clojureRT::protobuf::Node* WithMetaNode::release_meta() {
  
  ::clojureRT::protobuf::Node* temp = _impl_.meta_;
  _impl_.meta_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clojureRT::protobuf::Node* WithMetaNode::unsafe_arena_release_meta() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.WithMetaNode.meta)
  
  ::clojureRT::protobuf::Node* temp = _impl_.meta_;
  _impl_.meta_ = nullptr;
  return temp;
}
inline ::clojureRT::protobuf::Node* WithMetaNode::_internal_mutable_meta() {
  
  if (_impl_.meta_ == nullptr) {
    auto* p = CreateMaybeMessage<::clojureRT::protobuf::Node>(GetArenaForAllocation());
    _impl_.meta_ = p;
  }
  return _impl_.meta_;
}
inline ::clojureRT::protobuf::Node* WithMetaNode::mutable_meta() {
  ::clojureRT::protobuf::Node* _msg = _internal_mutable_meta();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.WithMetaNode.meta)
  return _msg;
}
inline void WithMetaNode::set_allocated_meta(::clojureRT::protobuf::Node* meta) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.meta_;
  }
  if (meta) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(meta);
    if (message_arena != submessage_arena) {
      meta = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, meta, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.meta_ = meta;
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.WithMetaNode.meta)
}

// -------------------------------------------------------------------

// Node

// string env = 1;
inline void Node::clear_env() {
  _impl_.env_.ClearToEmpty();
}
inline const std::string& Node::env() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.Node.env)
  return _internal_env();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Node::set_env(ArgT0&& arg0, ArgT... args) {
 
 _impl_.env_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.Node.env)
}
inline std::string* Node::mutable_env() {
  std::string* _s = _internal_mutable_env();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.Node.env)
  return _s;
}
inline const std::string& Node::_internal_env() const {
  return _impl_.env_.Get();
}
inline void Node::_internal_set_env(const std::string& value) {
  
  _impl_.env_.Set(value, GetArenaForAllocation());
}
inline std::string* Node::_internal_mutable_env() {
  
  return _impl_.env_.Mutable(GetArenaForAllocation());
}
inline std::string* Node::release_env() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.Node.env)
  return _impl_.env_.Release();
}
inline void Node::set_allocated_env(std::string* env) {
  if (env != nullptr) {
    
  } else {
    
  }
  _impl_.env_.SetAllocated(env, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.env_.IsDefault()) {
    _impl_.env_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.Node.env)
}

// string form = 2;
inline void Node::clear_form() {
  _impl_.form_.ClearToEmpty();
}
inline const std::string& Node::form() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.Node.form)
  return _internal_form();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Node::set_form(ArgT0&& arg0, ArgT... args) {
 
 _impl_.form_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.Node.form)
}
inline std::string* Node::mutable_form() {
  std::string* _s = _internal_mutable_form();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.Node.form)
  return _s;
}
inline const std::string& Node::_internal_form() const {
  return _impl_.form_.Get();
}
inline void Node::_internal_set_form(const std::string& value) {
  
  _impl_.form_.Set(value, GetArenaForAllocation());
}
inline std::string* Node::_internal_mutable_form() {
  
  return _impl_.form_.Mutable(GetArenaForAllocation());
}
inline std::string* Node::release_form() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.Node.form)
  return _impl_.form_.Release();
}
inline void Node::set_allocated_form(std::string* form) {
  if (form != nullptr) {
    
  } else {
    
  }
  _impl_.form_.SetAllocated(form, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.form_.IsDefault()) {
    _impl_.form_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.Node.form)
}

// optional bool ignoreTag = 3;
inline bool Node::_internal_has_ignoretag() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Node::has_ignoretag() const {
  return _internal_has_ignoretag();
}
inline void Node::clear_ignoretag() {
  _impl_.ignoretag_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool Node::_internal_ignoretag() const {
  return _impl_.ignoretag_;
}
inline bool Node::ignoretag() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.Node.ignoreTag)
  return _internal_ignoretag();
}
inline void Node::_internal_set_ignoretag(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ignoretag_ = value;
}
inline void Node::set_ignoretag(bool value) {
  _internal_set_ignoretag(value);
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.Node.ignoreTag)
}

// repeated string loops = 4;
inline int Node::_internal_loops_size() const {
  return _impl_.loops_.size();
}
inline int Node::loops_size() const {
  return _internal_loops_size();
}
inline void Node::clear_loops() {
  _impl_.loops_.Clear();
}
inline std::string* Node::add_loops() {
  std::string* _s = _internal_add_loops();
  // @@protoc_insertion_point(field_add_mutable:clojureRT.protobuf.Node.loops)
  return _s;
}
inline const std::string& Node::_internal_loops(int index) const {
  return _impl_.loops_.Get(index);
}
inline const std::string& Node::loops(int index) const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.Node.loops)
  return _internal_loops(index);
}
inline std::string* Node::mutable_loops(int index) {
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.Node.loops)
  return _impl_.loops_.Mutable(index);
}
inline void Node::set_loops(int index, const std::string& value) {
  _impl_.loops_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.Node.loops)
}
inline void Node::set_loops(int index, std::string&& value) {
  _impl_.loops_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.Node.loops)
}
inline void Node::set_loops(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.loops_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:clojureRT.protobuf.Node.loops)
}
inline void Node::set_loops(int index, const char* value, size_t size) {
  _impl_.loops_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:clojureRT.protobuf.Node.loops)
}
inline std::string* Node::_internal_add_loops() {
  return _impl_.loops_.Add();
}
inline void Node::add_loops(const std::string& value) {
  _impl_.loops_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:clojureRT.protobuf.Node.loops)
}
inline void Node::add_loops(std::string&& value) {
  _impl_.loops_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:clojureRT.protobuf.Node.loops)
}
inline void Node::add_loops(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.loops_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:clojureRT.protobuf.Node.loops)
}
inline void Node::add_loops(const char* value, size_t size) {
  _impl_.loops_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:clojureRT.protobuf.Node.loops)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Node::loops() const {
  // @@protoc_insertion_point(field_list:clojureRT.protobuf.Node.loops)
  return _impl_.loops_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Node::mutable_loops() {
  // @@protoc_insertion_point(field_mutable_list:clojureRT.protobuf.Node.loops)
  return &_impl_.loops_;
}

// string oTag = 5;
inline void Node::clear_otag() {
  _impl_.otag_.ClearToEmpty();
}
inline const std::string& Node::otag() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.Node.oTag)
  return _internal_otag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Node::set_otag(ArgT0&& arg0, ArgT... args) {
 
 _impl_.otag_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.Node.oTag)
}
inline std::string* Node::mutable_otag() {
  std::string* _s = _internal_mutable_otag();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.Node.oTag)
  return _s;
}
inline const std::string& Node::_internal_otag() const {
  return _impl_.otag_.Get();
}
inline void Node::_internal_set_otag(const std::string& value) {
  
  _impl_.otag_.Set(value, GetArenaForAllocation());
}
inline std::string* Node::_internal_mutable_otag() {
  
  return _impl_.otag_.Mutable(GetArenaForAllocation());
}
inline std::string* Node::release_otag() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.Node.oTag)
  return _impl_.otag_.Release();
}
inline void Node::set_allocated_otag(std::string* otag) {
  if (otag != nullptr) {
    
  } else {
    
  }
  _impl_.otag_.SetAllocated(otag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.otag_.IsDefault()) {
    _impl_.otag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.Node.oTag)
}

// .clojureRT.protobuf.Op op = 6;
inline void Node::clear_op() {
  _impl_.op_ = 0;
}
inline ::clojureRT::protobuf::Op Node::_internal_op() const {
  return static_cast< ::clojureRT::protobuf::Op >(_impl_.op_);
}
inline ::clojureRT::protobuf::Op Node::op() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.Node.op)
  return _internal_op();
}
inline void Node::_internal_set_op(::clojureRT::protobuf::Op value) {
  
  _impl_.op_ = value;
}
inline void Node::set_op(::clojureRT::protobuf::Op value) {
  _internal_set_op(value);
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.Node.op)
}

// repeated string rawForms = 7;
inline int Node::_internal_rawforms_size() const {
  return _impl_.rawforms_.size();
}
inline int Node::rawforms_size() const {
  return _internal_rawforms_size();
}
inline void Node::clear_rawforms() {
  _impl_.rawforms_.Clear();
}
inline std::string* Node::add_rawforms() {
  std::string* _s = _internal_add_rawforms();
  // @@protoc_insertion_point(field_add_mutable:clojureRT.protobuf.Node.rawForms)
  return _s;
}
inline const std::string& Node::_internal_rawforms(int index) const {
  return _impl_.rawforms_.Get(index);
}
inline const std::string& Node::rawforms(int index) const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.Node.rawForms)
  return _internal_rawforms(index);
}
inline std::string* Node::mutable_rawforms(int index) {
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.Node.rawForms)
  return _impl_.rawforms_.Mutable(index);
}
inline void Node::set_rawforms(int index, const std::string& value) {
  _impl_.rawforms_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.Node.rawForms)
}
inline void Node::set_rawforms(int index, std::string&& value) {
  _impl_.rawforms_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.Node.rawForms)
}
inline void Node::set_rawforms(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.rawforms_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:clojureRT.protobuf.Node.rawForms)
}
inline void Node::set_rawforms(int index, const char* value, size_t size) {
  _impl_.rawforms_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:clojureRT.protobuf.Node.rawForms)
}
inline std::string* Node::_internal_add_rawforms() {
  return _impl_.rawforms_.Add();
}
inline void Node::add_rawforms(const std::string& value) {
  _impl_.rawforms_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:clojureRT.protobuf.Node.rawForms)
}
inline void Node::add_rawforms(std::string&& value) {
  _impl_.rawforms_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:clojureRT.protobuf.Node.rawForms)
}
inline void Node::add_rawforms(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.rawforms_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:clojureRT.protobuf.Node.rawForms)
}
inline void Node::add_rawforms(const char* value, size_t size) {
  _impl_.rawforms_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:clojureRT.protobuf.Node.rawForms)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Node::rawforms() const {
  // @@protoc_insertion_point(field_list:clojureRT.protobuf.Node.rawForms)
  return _impl_.rawforms_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Node::mutable_rawforms() {
  // @@protoc_insertion_point(field_mutable_list:clojureRT.protobuf.Node.rawForms)
  return &_impl_.rawforms_;
}

// .clojureRT.protobuf.Subnode subnode = 8;
inline bool Node::_internal_has_subnode() const {
  return this != internal_default_instance() && _impl_.subnode_ != nullptr;
}
inline bool Node::has_subnode() const {
  return _internal_has_subnode();
}
inline void Node::clear_subnode() {
  if (GetArenaForAllocation() == nullptr && _impl_.subnode_ != nullptr) {
    delete _impl_.subnode_;
  }
  _impl_.subnode_ = nullptr;
}
inline const ::clojureRT::protobuf::Subnode& Node::_internal_subnode() const {
  const ::clojureRT::protobuf::Subnode* p = _impl_.subnode_;
  return p != nullptr ? *p : reinterpret_cast<const ::clojureRT::protobuf::Subnode&>(
      ::clojureRT::protobuf::_Subnode_default_instance_);
}
inline const ::clojureRT::protobuf::Subnode& Node::subnode() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.Node.subnode)
  return _internal_subnode();
}
inline void Node::unsafe_arena_set_allocated_subnode(
    ::clojureRT::protobuf::Subnode* subnode) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.subnode_);
  }
  _impl_.subnode_ = subnode;
  if (subnode) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clojureRT.protobuf.Node.subnode)
}
inline ::clojureRT::protobuf::Subnode* Node::release_subnode() {
  
  ::clojureRT::protobuf::Subnode* temp = _impl_.subnode_;
  _impl_.subnode_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::clojureRT::protobuf::Subnode* Node::unsafe_arena_release_subnode() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.Node.subnode)
  
  ::clojureRT::protobuf::Subnode* temp = _impl_.subnode_;
  _impl_.subnode_ = nullptr;
  return temp;
}
inline ::clojureRT::protobuf::Subnode* Node::_internal_mutable_subnode() {
  
  if (_impl_.subnode_ == nullptr) {
    auto* p = CreateMaybeMessage<::clojureRT::protobuf::Subnode>(GetArenaForAllocation());
    _impl_.subnode_ = p;
  }
  return _impl_.subnode_;
}
inline ::clojureRT::protobuf::Subnode* Node::mutable_subnode() {
  ::clojureRT::protobuf::Subnode* _msg = _internal_mutable_subnode();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.Node.subnode)
  return _msg;
}
inline void Node::set_allocated_subnode(::clojureRT::protobuf::Subnode* subnode) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.subnode_;
  }
  if (subnode) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(subnode);
    if (message_arena != submessage_arena) {
      subnode = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subnode, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.subnode_ = subnode;
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.Node.subnode)
}

// string tag = 9;
inline void Node::clear_tag() {
  _impl_.tag_.ClearToEmpty();
}
inline const std::string& Node::tag() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.Node.tag)
  return _internal_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Node::set_tag(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tag_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.Node.tag)
}
inline std::string* Node::mutable_tag() {
  std::string* _s = _internal_mutable_tag();
  // @@protoc_insertion_point(field_mutable:clojureRT.protobuf.Node.tag)
  return _s;
}
inline const std::string& Node::_internal_tag() const {
  return _impl_.tag_.Get();
}
inline void Node::_internal_set_tag(const std::string& value) {
  
  _impl_.tag_.Set(value, GetArenaForAllocation());
}
inline std::string* Node::_internal_mutable_tag() {
  
  return _impl_.tag_.Mutable(GetArenaForAllocation());
}
inline std::string* Node::release_tag() {
  // @@protoc_insertion_point(field_release:clojureRT.protobuf.Node.tag)
  return _impl_.tag_.Release();
}
inline void Node::set_allocated_tag(std::string* tag) {
  if (tag != nullptr) {
    
  } else {
    
  }
  _impl_.tag_.SetAllocated(tag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tag_.IsDefault()) {
    _impl_.tag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:clojureRT.protobuf.Node.tag)
}

// optional bool topLevel = 10;
inline bool Node::_internal_has_toplevel() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Node::has_toplevel() const {
  return _internal_has_toplevel();
}
inline void Node::clear_toplevel() {
  _impl_.toplevel_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool Node::_internal_toplevel() const {
  return _impl_.toplevel_;
}
inline bool Node::toplevel() const {
  // @@protoc_insertion_point(field_get:clojureRT.protobuf.Node.topLevel)
  return _internal_toplevel();
}
inline void Node::_internal_set_toplevel(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.toplevel_ = value;
}
inline void Node::set_toplevel(bool value) {
  _internal_set_toplevel(value);
  // @@protoc_insertion_point(field_set:clojureRT.protobuf.Node.topLevel)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protobuf
}  // namespace clojureRT

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::clojureRT::protobuf::CaseNode_SwitchType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::clojureRT::protobuf::CaseNode_SwitchType>() {
  return ::clojureRT::protobuf::CaseNode_SwitchType_descriptor();
}
template <> struct is_proto_enum< ::clojureRT::protobuf::CaseNode_TestType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::clojureRT::protobuf::CaseNode_TestType>() {
  return ::clojureRT::protobuf::CaseNode_TestType_descriptor();
}
template <> struct is_proto_enum< ::clojureRT::protobuf::ConstNode_ConstType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::clojureRT::protobuf::ConstNode_ConstType>() {
  return ::clojureRT::protobuf::ConstNode_ConstType_descriptor();
}
template <> struct is_proto_enum< ::clojureRT::protobuf::Op> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::clojureRT::protobuf::Op>() {
  return ::clojureRT::protobuf::Op_descriptor();
}
template <> struct is_proto_enum< ::clojureRT::protobuf::LocalType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::clojureRT::protobuf::LocalType>() {
  return ::clojureRT::protobuf::LocalType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_bytecode_2eproto
